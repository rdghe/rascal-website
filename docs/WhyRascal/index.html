<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-WhyRascal">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="The Rascal Meta Programming Language RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="The Rascal Meta Programming Language Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="The Rascal Meta Programming Language" href="/opensearch.xml">
<link rel="alternate" type="application/rss+xml" href="/release-notes/rss.xml" title="The Rascal Meta Programming Language RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/release-notes/atom.xml" title="The Rascal Meta Programming Language Atom Feed"><title data-rh="true">Why Rascal? | The Rascal Meta Programming Language</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://rascal-mpl.org/docs/WhyRascal"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Why Rascal? | The Rascal Meta Programming Language"><meta data-rh="true" name="description" content="Synopsis."><meta data-rh="true" property="og:description" content="Synopsis."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://rascal-mpl.org/docs/WhyRascal"><link data-rh="true" rel="alternate" href="https://rascal-mpl.org/docs/WhyRascal" hreflang="en"><link data-rh="true" rel="alternate" href="https://rascal-mpl.org/docs/WhyRascal" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://FKSZQR9CR0-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.44e7e7d2.css">
<link rel="preload" href="/assets/js/runtime~main.0f6650ea.js" as="script">
<link rel="preload" href="/assets/js/main.90594841.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/rascal_large_no_text.png" alt="Rascal logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/rascal_large_no_text.png" alt="Rascal logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">The Rascal Meta Programming Language</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/WhyRascal">Docs</a><a class="navbar__item navbar__link" href="/casestudies">Case Studies</a><a class="navbar__item navbar__link" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/release-notes">Release notes</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/projects">Projects</a><a class="navbar__item navbar__link" href="/team">Team</a><a href="https://github.com/usethesource" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/WhyRascal">Why Rascal?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/GettingStarted">Getting Started</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/GettingHelp">Getting Help</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/RascalConcepts">Concepts</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/Rascal">Language Reference</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/Libraries">Libraries</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/RascalShell">Rascal Shell</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/TypePal">TypePal</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/RunTimeErrors">Runtime Errors</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/CompileTimeErrors">Compile Time Errors</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/Rascalopedia">Glossary</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/Recipes">Recipes</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/syntax-demo">-- Syntax Highlighting Demo --</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Why Rascal?</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Why Rascal?</h1></header><p><strong>Synopsis.</strong></p><p>What is the motivation for Rascal and which problems can you solve with it?</p><p><strong>Description.</strong></p><p>We give various answers to these questions:</p><ul><li><p>In <a href="#motivation">Motivation</a> we summarize the distinguishing features of Rascal and describe some
application domains.</p></li><li><p><a href="#EASY">The Extract-Analyze-SYnthesize (EASY) paradigm</a> can be used in many Rascal applications.</p></li><li><p>We have also collected <a href="#solution-strategies">Solution Strategies</a> for a wide range of problems.</p></li><li><p>Last but not least we give a quick <a href="#comparison">Comparison with other Paradigms</a>.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="motivation">Motivation<a class="hash-link" href="#motivation" title="Direct link to heading">​</a></h2><p><strong>Synopsis.</strong></p><p>The distinguishing features of Rascal and how they solve real problems.</p><p><strong>Description.</strong></p><p><em>Meta-programs</em> are programs that analyze, transform or generate other programs. Ordinary programs work on data;
meta-programs work on programs.</p><p>The <em>range of programs</em> to which meta-programming can be applied is large: from programs in standard languages like C
and Java to domain-specific languages for describing high-level system models or applications in specialized areas like
gaming or finance. In some cases, even test results or performance data are used as input for meta-programs.</p><p>The <em>range of kinds of meta programs</em> that can be applied is also large. There are simple meta programs that generate
boilerplate code from a list of items. There are complex meta programs that reverse engineer and statically analyse a
big software system before visualizing the results. The point of Rascal is that in all these kinds of meta programs one
needs similar operations and similar data-types.</p><p>The <em>point of Rascal</em> is to provide a reusable set of primitives to build and manipulate program representations. The
point is <em>not</em> to be or provide a unified representation of programs to let generic algorithms operate on. In meta
programming the devil is often in the details. Rascal makes sure to not a priori abstract from the important details
programming language syntax and semantics.</p><p><em>Rascal is a domain specific programming language</em>. We emphasize programming here because Rascal is intended as an
engineering tool for programmers that need to construct meta programs. Rascal programs allow running, inspecting,
debugging, tracing, profiling, etc. just as normal programs do. The skills of any good programmer are enough to easily
write good Rascal programs.</p><p><strong>Examples.</strong></p><p>Typical applications of Rascal are:</p><ul><li><p>Refactoring of Java source code.</p></li><li><p>Analyzing PHP code.</p></li><li><p>Searching for buffer overflows in C code.</p></li><li><p>Analyzing the version history of a large software project.</p></li><li><p>Implementing a <em>domain-specific language</em> (DSL) for describing games or business processes.</p></li><li><p>Writing compilers.</p></li></ul><p>All these cases involve a form of meta-programming: software programs (in a wide sense) are the objects-of-interest that
are being analyzed, transformed or generated. Rascal can be applied in domains ranging from compiler construction and
implementing domain-specific languages to constraint solving and software renovation.</p><p>Since representation of information is central to the approach, Rascal provides a rich set of built-in data types. To
support extraction and analysis, parsing and advanced pattern matching are provided. High-level control structures make
analysis and synthesis of complex data structures simple.</p><ul><li><p><em>Familiar syntax</em> in a <em>what-you-see is-what-you-get</em> style is used even for sophisticated concepts and this makes
the language easy to learn and easy to use.</p></li><li><p><em>Sophisticated built-in data types</em> provide standard solutions for many meta-programming problems.</p></li><li><p><em>Safety</em> is achieved by finding most errors before the program is executed and by making common errors like missing
initializations or invalid pointers impossible.</p></li><li><p><em>Local type inference</em> makes local variable declarations redundant.</p></li><li><p><em>Pattern matching</em> can be used to analyze all complex data structures.</p></li><li><p><em>Syntax definitions</em> make it possible to define new and existing languages and to write tools for them.</p></li><li><p><em>Visiting</em> makes it easy to traverse data structures and to extract information from them or to synthesize results.</p></li><li><p><em>Templates</em> enable easy code generation.</p></li><li><p><em>Functions as values</em> permit programming styles with high re-use.</p></li><li><p><em>Generic types</em> allow writing functions that are applicable for many different types.</p></li><li><p><em>Eclipse integration</em> makes Rascal programming a breeze. All familiar tools are at your fingertips.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="EASY">The Extract-Analyze-SYnthesize (EASY) paradigm<a class="hash-link" href="#EASY" title="Direct link to heading">​</a></h2><p><strong>Synopsis.</strong></p><p>Rascal excels in supporting the Extract-Analyze-SYnthesize (EASY) paradigm.</p><p><img loading="lazy" alt="easy workflow" src="/assets/images/easy-workflow-0249a107066e7e1ec8eda72986161b23.png" width="768" height="751" class="img_ev3q"></p><p><strong>Description.</strong></p><p>Many meta-programming problems follow a fixed pattern. Starting with some input system (a black box that we usually call
<em>system-of-interest</em>), first relevant information is extracted from it and stored in an internal representation. This
internal representation is then analyzed and used to synthesize results. If the synthesis indicates this, these steps
can be repeated over and over again. These steps are shown in the figure. This is an abstract view on solving
meta-programming problems, but is rather common.</p><p>Rascal has been designed to fully support problem solving that fits the EASY paradigm. We will discuss the following use
cases represented by different <em>personas</em>:</p><ul><li><p><a href="#concurrency">Concurrency</a>: Concurrency analysis.</p></li><li><p><a href="#forensics">Forensics</a>: Domain-specific language for forensics research.</p></li><li><p><a href="#MDE">Model-Driven Engineering</a>: Tools for Model-Driven Engineering.</p></li><li><p><a href="#renovation">Renovation</a>: System renovation.</p></li><li><p><a href="#security">Security</a>: Security analysis.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="concurrency">Concurrency<a class="hash-link" href="#concurrency" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Concurrency analysis.</p><p><strong>Description.</strong></p><p><em>Daniel</em> is a concurrency researcher at one of the largest hardware manufacturers worldwide. He is working from an
office in the Bay Area. Concurrency is the big issue for his company: it is becoming harder and harder to make CPUs
faster, therefore more and more of them are bundled on a single chip. Programming these multi-core chips is difficult
and many programs that worked fine on a single CPU contain hard to detect concurrency errors due to subtle differences
in the order of execution that results from executing the code on more than one CPU. Here is where Daniel enters the
picture. He is working on tools for finding concurrency errors. First he extracts facts from the code that are relevant
for concurrency problems and have to do with calls, threads, shared variables and locks. Next, he analyzes these facts
and synthesizes an abstract model that captures the essentials of the concurrency behaviour of the program. Finally he
runs a third-party verification tool with this model as input to do the actual verification.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="forensics">Forensics<a class="hash-link" href="#forensics" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Domain-specific language for forensics research.</p><p><strong>Description.</strong></p><p><em>Bernd</em> is a senior software engineer working at the Berlin headquarters of a forensic investigation lab of the German
government. His daily work is to find common patterns in files stored on digital media that have been confiscated during
criminal investigations. Text, audio and video files are stored in zillions of different data formats and each data
format requires its own analysis technique. For each new investigation ad hoc combinations of tools are used. This makes
the process very labour-intensive and error-prone. Bernd convinces his manager that designing a new domain-specific
language (DSL) for forensic investigations may relieve the pressure on their lab. After designing the DSL---let’s call
it DERRICK---he makes an EASY implementation for it. Given a DERRICK program for a specific case under investigation, he
first extracts relevant information from it and analyzes it: which media formats are relevant? Which patterns to look
for? How should search results be combined? Given this new information, Java code is synthesized that uses the various
existing tools and combines their results.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="MDE">Model-Driven Engineering<a class="hash-link" href="#MDE" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Tools for Model-Driven Engineering.</p><p><strong>Description.</strong></p><p><em>Elisabeth</em> is a software architect at a large airplane manufacturer and her concern is reliability and dependability of
airplane control software. She and her team have designed a UML model of the control software and have extended it with
annotations that describe the reliability of individual components. She will use this annotated model in two ways:</p><ul><li><p>to extract relevant information from it to synthesize input for a statistical tool that will compute overall system
reliability from the reliability of individual components;</p></li><li><p>to generate executable code that takes the reliability issues into account.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="renovation">Renovation<a class="hash-link" href="#renovation" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>System renovation.</p><p><img loading="lazy" alt="Extract-Analyze-View Paradigm" src="/assets/images/extract-analyze-view-paradigm-16afa89916cdd851b56731a9212b709d.png" width="679" height="614" class="img_ev3q"></p><p><strong>Description.</strong></p><p><em>Charlotte</em> is software engineer at a large financial institution in Paris and she is looking for options to connect an
old and dusty software system to a web interface.</p><p>She will need to analyze the sources of that system to understand how it can be changed to meet the new requirements.
The objects-of-interest are in this case the source files, documentation, test scripts and any other available
information. They have to be parsed in some way in order to extract relevant information, say the calls between various
parts of the system. The call information can be represented as a binary relation between caller and callee (the
internal representation in this example). This relation with 1-step calls is analyzed and further extended with 2-step
calls, 3-step calls and so on. In this way call chains of arbitrary length become available. With this new information,
we can synthesize results by determining the entry points of the software system, i.e., the points where calls from the
outside world enter the system.</p><p>Having completed this first cycle, Charlotte may be interested in which procedures can be called from the entry points
and so on and so forth. Results will be typically represented as pictures that display the relationships that were
found. In the case of source code analysis, a variation of our workflow scheme is quite common. It is then called the
extract-analyze-view paradigm and is shown in the figure.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="security">Security<a class="hash-link" href="#security" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Security analysis.</p><p><strong>Description.</strong></p><p><em>Alice</em> is system administrator of a large online marketplace and she is looking for security breaches in her system.
The objects-of-interest are the system’s log files. First relevant entries are extracted. This will include, for
instance, messages from the SecureShell demon that reports failed login attempts. From each entry login name and
originating IP address are extracted and put in a table (the internal representation in this example). These data are
analyzed by detecting duplicates and counting frequencies. Finally results are synthesized by listing the most
frequently used login names and IP addresses.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solution-strategies">Solution Strategies<a class="hash-link" href="#solution-strategies" title="Direct link to heading">​</a></h2><p><strong>Synopsis.</strong></p><p>Strategies to solve problems in various domains using Rascal.</p><p><img loading="lazy" alt="Problem Solving Workflow" src="/assets/images/problem-solving-e29c50811d2d2b35826e529643e1931c.png" width="458" height="725" class="img_ev3q"></p><p><strong>Description.</strong></p><p>Before you study more complicated examples, it is useful to discuss some general problem solving strategies that are
relevant in Rascal’s application domain.</p><p>To appreciate these general strategies, it is good to keep some specific problem areas in mind:</p><ul><li><p><em>Documentation generation</em>: extract facts from source code and use them to generate textual documentation. A typical
example is generating web-based documentation for legacy languages like Cobol and PL/I.</p></li><li><p><em>Metrics calculation</em>: extract facts from source code (and possibly other sources like test runs) and use them to
calculate code metrics. Examples are cohesion and coupling of modules and test coverage.</p></li><li><p><em>Model extraction</em>: extract facts from source code and use them to build an abstract model of the source code. An
example is extracting lock and unlock calls from source code and to build an automaton that guarantees that
lock/unlock occurs in pairs along every control flow path.</p></li><li><p><em>Model-based code generation</em>: given a high-level model of a software system, described in UML or some other
modelling language, transform this model into executable code. UML-to-Java code generation falls in this category.</p></li><li><p><em>Source-to-source transformation</em>: large-scale, fully automated, source code transformation with certain objectives
like removing deprecated language features, upgrading to newer APIs and the like.</p></li><li><p><em>Interactive refactoring</em>: given known <em>code smells</em> a user can interactively indicate how these smells should be
removed. The refactoring features in Eclipse and Visual Studio are examples.</p></li></ul><p>With these examples in mind, we can study the overall problem solving workflow as shown in the figure above.
It consists of three optional phases:</p><ul><li><p>Is extraction needed to solve the problem, then define the extraction phase, see
<a href="#extraction">Extraction</a>.</p></li><li><p>Is analysis needed, then define the analysis phase, see <a href="#analysis">Analysis</a>.</p></li><li><p>Is synthesis needed, then define the synthesis phase, see <a href="#synthesis">Synthesis</a>.</p></li></ul><p><img loading="lazy" alt="Validation Workflow" src="/assets/images/validation-9d9656edaf7509c7eeeba74043f09382.png" width="553" height="436" class="img_ev3q"></p><p>Each phase is subject to a validation and improvement workflow as shown in the second figure
above. Each individual phase as well as the combination of phases may introduce errors
and has thus to be carefully validated. In combination with the detailed strategies for each phase, this forms a
complete approach for problem solving and validation using Rascal.</p><p><img loading="lazy" alt="Requirements Workflow" src="/assets/images/requirements-bac17528df86b048ac961830abe79ba0.png" width="515" height="355" class="img_ev3q"></p><p>A major question in every problem solving situation is how to determine the requirements for each phase of the solution.
For instance, how do we know what to extract from the source code if we do not know what the desired end results of the
project are? The standard solution is to use a workflow for requirements gathering that is the inverse of the phases
needed to solve the complete problem. This is shown in the third figure above and
amounts to the phases:</p><ul><li><p>Requirements of the synthesis phase. This amounts to making an inventory of the desired results of the whole project
and may include generated source code, abstract models, or visualizations.</p></li><li><p>Requirements of the analysis phase. Once these results of the synthesis phase are known, it is possible to list the
analysis results that are needed to synthesize desired results. Possible results of the analysis phase include type
information, structural information of the original source.</p></li><li><p>Requirements of the extraction phase. As a last step, one can make an inventory of the facts that have to be
extracted to form the starting point for the analysis phase. Typical facts include method calls, inheritance
relations, control flow graphs, usage patterns of specific library functions or language constructs.</p></li></ul><p>You will have no problem in identifying requirements for each phase when you apply them to a specific example from the
list given earlier.</p><p>When these requirements have been established, it becomes much easier to actually carry out the project using the three
phases of the first figure above.</p><p>We will discuss:</p><ul><li><p><a href="#extraction">Extraction</a>: Strategies to extract facts from software systems.</p></li><li><p><a href="#analysis">Analysis</a>: Strategies to analyze software systems.</p></li><li><p><a href="#synthesis">Synthesis</a>: Strategies to synthesise results.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="extraction">Extraction<a class="hash-link" href="#extraction" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Strategies to extract facts from software systems.</p><p><img loading="lazy" alt="Extraction Workflow" src="/assets/images/define-extraction-05557091ab296ece0b761172a7016639.png" width="714" height="1008" class="img_ev3q"></p><p><strong>Description.</strong></p><p>How can we extract facts from the <em>System under Investigation</em> (SUI) that we are interested in? The extraction workflow
is shown in the figure above and consists of the following steps:</p><ul><li><p>First and foremost we have to determine which facts we need. This sounds trivial, but it is not. The problem is that
we have to anticipate which facts will be needed in the next---not yet defined---analysis phase. A common approach
is to use look-ahead and to sketch the queries that are likely to be used in the analysis phase and to determine
which facts are needed for them. Start with extracting these facts and refine the extraction phase when the analysis
phase is completely defined.</p></li><li><p>If relevant facts are already available (and they are reliable<!-- -->!<!-- -->) then we are done. This may happen when you are
working on a system that has already been analyzed by others.</p></li><li><p>Otherwise you need the source code of the SUI. This requires:</p><ul><li><p>Checking that all sources are available (and can be compiled by the host system on which they are usually
compiled and executed). Due to missing or unreliable configuration management on the original system this may be
a labour-intensive step that requires many iterations.</p></li><li><p>Determining in which languages the sources are written. In larger systems it is common that three or more
different languages are being used.</p></li></ul></li><li><p>If there are reliable third-party extraction tools available for this language mix, then we only have to apply them
and we are done. Here again, validation is needed that the extracted facts are as expected.</p></li><li><p>The extraction may require syntax analysis. This is the case when more structural properties of the source code are
needed such as the flow-of-control, nesting of declarations, and the like. There two approaches here:</p></li><li><p>Use a third-party parser, convert the source code to parse trees and do the further processing of these parse trees
in Rascal. The advantage is that the parser can be re-used, the disadvantage is that data conversion is needed to
adapt the generated parse tree to Rascal. Validate that the parser indeed accepts the language the SUI is written
in, since you will not be the first who has been bitten by the language dialect monster when it turns out that the
SUI uses a local variant that slightly deviates from a mainstream language.</p></li><li><p>Use an existing syntax definition of the source language or write your own definition. Be aware, however, that
writing a grammar for a non-trivial language is a major undertaking and may require weeks to month of work. Whatever
approach you choose, validate that the resulting grammar is compliant with the original grammar of the source
language.</p></li><li><p>The extraction phase may only require lexical analysis. This happens when more superficial, textual, facts have to
be extracted like procedure calls, counts of certain statements and the like. Use Rascal’s full regular expression
facilities to do the lexical analysis.</p></li></ul><p>It may happen that the facts extracted from the source code are <em>wrong</em>. Typical error classes are:</p><ul><li><p>Extracted facts are <em>wrong</em>: the extracted facts incorrectly state that procedure P calls procedure Q but this is
contradicted by a source code inspection. This may happen when the fact extractor uses a conservative approximation
when precise information is not statically available. In the language C, when procedure P performs an indirect call
via a pointer variable, the approximation may be that P calls all procedures in the procedures.</p></li><li><p>Extracted facts are <em>incomplete</em>: the inheritance between certain classes in Java code is missing.</p></li></ul><p>The strategy to validate extracted facts differ per case but here are three strategies:</p><ul><li><p>Post process the extracted facts (using Rascal, of course) to obtain trivial facts about the source code such as
total lines of source code and number of procedures, classes, interfaces and the like. Next validate these trivial
facts with tools like wc (word and line count), grep (regular expression matching) and others.</p></li><li><p>Do a manual fact extraction on a small subset of the code and compare this with the automatically extracted facts.</p></li><li><p>Use another tool on the same source and compare results whenever possible. A typical example is a comparison of a
call relation extracted with different tools.</p></li></ul><p>The Rascal features that are most frequently used for extraction are:</p><ul><li><p>Regular expression patterns to extract textual facts from source code.</p></li><li><p>Syntax definitions and concrete patterns to match syntactic structures in source code.</p></li><li><p>Pattern matching (used in many Rascal statements).</p></li><li><p>Visits to traverse syntax trees and to locally extract information.</p></li><li><p>The repertoire of built-in datatypes (like lists, maps, sets and relations) to represent the extracted facts.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="analysis">Analysis<a class="hash-link" href="#analysis" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Strategies to analyze software systems.</p><p><img loading="lazy" alt="Analysis Workflow" src="/assets/images/define-analysis-e475ec1a02621a48c955412b801ef4f8.png" width="714" height="361" class="img_ev3q"></p><p><strong>Description.</strong></p><p>The analysis workflow is shown in the figure above and consists of two steps:</p><ul><li><p>Determine the results that are needed for the synthesis phase.</p></li><li><p>Write the Rascal code to perform the analysis. This may amount to:</p><ul><li><p>Reordering extracted facts to make them more suitable for the synthesis phase.</p></li><li><p>Enriching extracted facts. Examples are computing transitive closures of extracted facts (e.g., A may call B in
one or more calls), or performing data reduction by abstracting aways details (i.e., reducing a program to a
finite automaton).</p></li><li><p>Combining enriched, extracted, facts to create new facts.</p></li></ul></li></ul><p>As before, validate, validate and validate the results of analysis. Essentially the same approach can be used as for
validating the facts. Manual checking of answers on random samples of the SUI may be mandatory. It also happens
frequently that answers inspire new queries that lead to new answers, and so on.</p><p>The Rascal features that are frequently used for analysis are:</p><ul><li><p>List, set and map comprehensions.</p></li><li><p>The built-in operators and library functions, in particular for lists, maps, sets and relations.</p></li><li><p>Pattern matching (used in many Rascal statements).</p></li><li><p>Visits and switches to further process extracted facts.</p></li><li><p>The solve statement for constraint solving.</p></li><li><p>Rewrite rules to simplify results and to enforce constraints.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="synthesis">Synthesis<a class="hash-link" href="#synthesis" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Strategies to synthesise results.</p><p><img loading="lazy" alt="Synthesis Workflow" src="/assets/images/define-synthesis-75080d2b5bb9551f574415fdfdcc0131.png" width="745" height="870" class="img_ev3q"></p><p><strong>Description.</strong></p><p>Results are synthesized as shown in the figure above. This consists of the
following steps:</p><ul><li><p>Determine the results of the synthesis phase. Wide range of results is possible including:</p><ul><li><p>Generated source code.</p></li><li><p>Generated abstract representations, like finite automata or other formals models that capture properties of the
SUI.</p></li><li><p>Generated data for visualizations that will be used by visualization tools.</p></li></ul></li><li><p>If source code is to be generated, there are various options.</p><ul><li><p>Print strings with embedded variables.</p></li><li><p>Convert abstract syntax trees to strings (perhaps using forms of pretty printing).</p></li><li><p>Use a grammar of the target source language, also for code generation. Note that this approach guarantees the
generation of syntactically correct source code as opposed to code generation using print statements or string
templates.</p></li></ul></li><li><p>If other output is needed (e.g., an automaton or other formal structure) write data declarations to represent that
output.</p></li><li><p>Finally, write functions and rewrite rules that generate the desired results.</p></li></ul><p>The Rascal features that are frequently used for synthesis are:</p><ul><li><p>Syntax definitions or data declarations to define output formats.</p></li><li><p>Pattern matching (used in many Rascal statements).</p></li><li><p>Visits of datastructures and on-the-fly code generation.</p></li><li><p>Rewrite rules.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="comparison">Comparison with other Paradigms<a class="hash-link" href="#comparison" title="Direct link to heading">​</a></h2><p><strong>Synopsis.</strong></p><p>Rascal compared with the imperative, object-oriented and algebraic paradigms</p><p><strong>Description.</strong></p><p>Rascal provides both familiar and unfamiliar features. These will be appreciated differently by programmers that are
expert in other language paradigms. We provide the following comparisons:</p><ul><li><p><a href="#asf-sdf">ASF+SDF</a>: Rascal explained for ASF+SDF programmers.</p></li><li><p><a href="#oo">Object-Oriented and Imperative Languages</a>: Rascal explained for OO and imperative
programmers.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="asf-sdf">ASF+SDF<a class="hash-link" href="#asf-sdf" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Rascal explained for ASF+SDF programmers.</p><p><strong>Description.</strong></p><p>Rascal is the successor of the specification language ASF+SDF that is part of the <a href="http://www.meta-environment.org" target="_blank" rel="noopener noreferrer">ASF+SDF
Meta-Environment</a>.</p><p>What are the differences between ASF+SDF and Rascal? What are the commonalities?</p><ul><li><p>Rascal has all the high level features of ASF+SDF and some more. Regarding functionality, old ASF+SDF specifications
could, in principle, be transformed into Rascal programs using a conversion tool. We do not provide such a tool
since it turns out to be better to redesign your specification from scratch to profit most from all the new features
in Rascal.</p></li><li><p>Rascal uses its own syntax definition notation that is richer than SDF. It also uses its own parser generation and
parsing technology. Parser generation is currently somewhat slower than for SDF, the generated parsers are, however,
substantially faster than SDF-based parsers. SDF specification can be automatically converted to Rascal, but here
again, manual conversion leads to better results.</p></li><li><p>Like in ASF+SDF, Rascal has modules that introduce a namespace scope for variables and functions, which can be
either private or public. Modules can have type parameters as in SDF, which are instantiated by import statements.</p></li><li><p>In Rascal, patterns and variables in concrete syntax may optionally be quoted and escaped, and explicit declaration
of the top non-terminal is supported to solve ambiguity.</p></li><li><p>Rascal does not support rewrite rules. Instead pattern-directed function definition and invocation can be used.</p></li><li><p>Unlike ASF+SDF, Rascal has native, efficient, implementations for lists, sets, relations and maps.</p></li><li><p>Unlike ASF+SDF, Rascal can be used without parsing or concrete syntax, supporting for example regular expressions
and abstract data types.</p></li><li><p>Rascal has native support for functions, which have a fixed syntax, always return a value and have a body consisting
of imperative control flow statements. Adding a function will not trigger the need for regenerating parse tables as
is the case in the ASF+SDF implementation. Function types can be polymorphic in their parameters and also allow
functions as arguments to implement reusable algorithms.</p></li><li><p>The imperative nature of Rascal allows you to factor out common code and nest conditionals, unlike in ASF+SDF where
alternative control flow paths have to be encoded by enumerating equations with non-overlapping conditions.</p></li><li><p>Rascal is an imperative language, which natively supports I/O and other side-effects without the workarounds that
are needed in ASF+SDF to achieve this.</p></li><li><p>Rascal has native support for traversals, instead of the add-on it used to be in ASF+SDF. The visit statement is
comparable to a traversal function in ASF+SDF, and is as type-safe as the traversal function, but it is more
programmeable.</p></li><li><p>Instead of accumulator values of traversal functions in ASF+SDF, Rascal simply supports lexically scoped variables
that can be updated using assignments.</p></li><li><p>Rascal natively supports specific expressions and datatypes for relational calculus, all borrowed directly from
RScript.</p></li><li><p>When programming using Rascal functions, instead of rules, the control flow of a program becomes easily traceable
and debuggable. It is simply like stepping through well structured code.</p></li><li><p>Rascal is based on a Java interpreter, or a Java run-time when compiled. So the code is more portable.</p></li><li><p>Rascal is supported by a modern, Eclipse-based, IDE, unlike the simple IDE of the ASF+SDF Meta-Environment. IDE
services like keyword highlighting, outlining, and more are available for the Rascal programmer.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="oo">Object-Oriented and Imperative Languages<a class="hash-link" href="#oo" title="Direct link to heading">​</a></h3><p><strong>Synopsis.</strong></p><p>Rascal explained for OO and imperative programmers.</p><p><strong>Description.</strong></p><p>Rascal is an imperative domain-specific language (DSL) for meta-programming. It provides high level statements and
expressions specifically targeted at the domain of analysis and transformation of source code.</p><p>How does Rascal differ from an OO language or an imperative language?</p><ul><li><p>Unlike OO languages, Rascal does not provide classes. Rascal has modules which can best be compared with a static
class in Java.</p></li><li><p>Objects in an OO language (class instances) can have mutable local state (i.e, each object can have instance
variables that can be modified after object creation). In Rascal all values are immutable after creation. Sharing a
value does not introduce a coupling like in OO, simply because changes are only visible to the code that changes the
values. Without mutability it is easy to combine stages of programs that perform different tasks.</p></li><li><p>Rascal does provide a mechanism for introducing user-defined types. An <em>Algebraic Data Type</em> introduces a new type
and is defined by a number of <em>constructor functions</em> to construct values of that type. The constructed values are
immutable. Although they are both called &quot;constructors&quot; there is a big difference between constructors in OO
languages and in Rascal. The former create mutable objects while the latter create immutable values.</p></li><li><p>Variables can, however, be associated with different immutable values during their lifetime. This is why we say that
Rascal is a weakly imperative language. Rascal is, however, closer, to functional languages than to OO languages or
imperative languages.</p></li><li><p>Rascal is safe: there are no null values.</p></li><li><p>Rascal is even more safe: it has a type system that prevents casting exceptions and other run-time failures. Still
the type system specifically allows many kinds of combinations. For example, unlike in Java a set of integers is a
subtype of a set of numbers (co-variance), which allows you to reuse algorithm for sets of numbers on sets of
integers. It also provides true polymorphic and functions (no erasure), and functions can safely be parameters to
other functions.</p></li><li><p>Rascal supports unchecked exceptions, throw and catch statements are available, but exceptions do not <em>have</em> to be
declared in function headers (but they <em>may</em> be declared for documentation purposes).</p></li><li><p>Rascal provides high-level statements and expressions for:</p><ul><li><p>Visitors in all kinds of orders, expressed very concisely, and type safe.</p></li><li><p>Pattern matching and construction (with and without concrete syntax<!-- -->!<!-- -->).</p></li><li><p>Equation/constraint solving.</p></li><li><p>Relational calculus.</p></li><li><p>Rewrite rules for normalization/canonicalization of any kind of data-structure</p></li><li><p>Support for parser generation and parsing using context-free grammars.</p></li><li><p>(De)Serialization of values.</p></li><li><p>Communication with databases.</p></li></ul></li><li><p>Rascal provides typed data constructors for common mathematical structures, such as:</p><ul><li><p>Terms (a.k.a. tree nodes or abstract data types).</p></li><li><p>Parse trees (derivations of context-free grammars, for concrete syntax and direct manipulation of source code).</p></li><li><p>Lists, tuples, maps, sets, relations, and graphs.</p></li></ul></li><li><p>In Rascal you can implement high-fidelity source-to-source transformations. Without too much overhead, programs can
do extensive rewriting of the source code without the loss of particular layout standards or source code comments.</p></li><li><p>Rascal is syntax-safe. When you use Rascal to generate or transform source code, it statically detects whether the
resulting source code is syntactically correct.</p></li><li><p>Rascal is executed by an interpreter written in Java, or it can be compiled to Java classes.</p></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/usethesource/rascal-website/tree/main/packages/create-docusaurus/templates/shared/docs/WhyRascal.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/docs/GettingStarted"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Getting Started</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#motivation" class="table-of-contents__link toc-highlight">Motivation</a></li><li><a href="#EASY" class="table-of-contents__link toc-highlight">The Extract-Analyze-SYnthesize (EASY) paradigm</a><ul><li><a href="#concurrency" class="table-of-contents__link toc-highlight">Concurrency</a></li><li><a href="#forensics" class="table-of-contents__link toc-highlight">Forensics</a></li><li><a href="#MDE" class="table-of-contents__link toc-highlight">Model-Driven Engineering</a></li><li><a href="#renovation" class="table-of-contents__link toc-highlight">Renovation</a></li><li><a href="#security" class="table-of-contents__link toc-highlight">Security</a></li></ul></li><li><a href="#solution-strategies" class="table-of-contents__link toc-highlight">Solution Strategies</a><ul><li><a href="#extraction" class="table-of-contents__link toc-highlight">Extraction</a></li><li><a href="#analysis" class="table-of-contents__link toc-highlight">Analysis</a></li><li><a href="#synthesis" class="table-of-contents__link toc-highlight">Synthesis</a></li></ul></li><li><a href="#comparison" class="table-of-contents__link toc-highlight">Comparison with other Paradigms</a><ul><li><a href="#asf-sdf" class="table-of-contents__link toc-highlight">ASF+SDF</a></li><li><a href="#oo" class="table-of-contents__link toc-highlight">Object-Oriented and Imperative Languages</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/GettingStarted">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/rascal" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/usethesource" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 UseTheSource. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.0f6650ea.js"></script>
<script src="/assets/js/main.90594841.js"></script>
</body>
</html>