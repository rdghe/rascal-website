"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[3774],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function f(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){f(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,f=function(e,t){if(null==e)return{};var n,a,f={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(f[n]=e[n]);return f}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(f[n]=e[n])}return f}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,f=e.mdxType,l=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(n),d=f,c=u["".concat(o,".").concat(d)]||u[d]||m[d]||l;return n?a.createElement(c,r(r({ref:t},p),{},{components:n})):a.createElement(c,r({ref:t},p))}));function d(e,t){var n=arguments,f=t&&t.mdxType;if("string"==typeof e||f){var l=n.length,r=new Array(l);r[0]=u;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:f,r[1]=i;for(var s=2;s<l;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},315:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return m}});var a=n(3117),f=n(102),l=(n(7294),n(3905)),r=["components"],i={sidebar_position:13,title:"Recipes"},o=void 0,s={unversionedId:"Recipes",id:"Recipes",title:"Recipes",description:"Synopsis.",source:"@site/docs/Recipes.md",sourceDirName:".",slug:"/Recipes",permalink:"/docs/Recipes",draft:!1,editUrl:"https://github.com/usethesource/rascal-website/tree/website-v2/docs/docs/Recipes.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13,title:"Recipes"},sidebar:"tutorialSidebar",previous:{title:"Glossary",permalink:"/docs/Rascalopedia"},next:{title:"Troubleshooting Installation Problems",permalink:"/docs/Troubleshooting"}},p={},m=[{value:"Basic",id:"basic",level:2},{value:"Hello",id:"hello",level:3},{value:"<code>hello</code> on command line",id:"hello-on-command-line",level:3},{value:"<code>hello</code> as function",id:"hello-as-function",level:3},{value:"<code>hello</code> as module",id:"hello-as-module",level:3},{value:"Factorial",id:"factorial",level:3},{value:"Squares",id:"squares",level:3},{value:"Bottles Of Beer",id:"bottles-of-beer",level:3},{value:"Bubble",id:"bubble",level:3},{value:"Even",id:"even",level:3},{value:"FizzBuzz",id:"fizzbuzz",level:3},{value:"Quine",id:"quine",level:3},{value:"Common",id:"common",level:2},{value:"Ad Hoc Data Exploration",id:"ad-hoc-data-exploration",level:3},{value:"Call Analysis",id:"call-analysis",level:3},{value:"Call Lifting",id:"call-lifting",level:3},{value:"Colored Trees",id:"colored-trees",level:3},{value:"Count Constructors",id:"count-constructors",level:3},{value:"Derivative",id:"derivative",level:3},{value:"String Template",id:"string-template",level:3},{value:"Word Count",id:"word-count",level:3},{value:"CountInLine1",id:"countinline1",level:3},{value:"CountInLine2",id:"countinline2",level:3},{value:"CountInLine3",id:"countinline3",level:3},{value:"Jabberwocky",id:"jabberwocky",level:3},{value:"Word Replacement",id:"word-replacement",level:3},{value:"Languages",id:"languages",level:2},{value:"Exp",id:"exp",level:3},{value:"Abstract",id:"abstract",level:3},{value:"Combined",id:"combined",level:3},{value:"Automatic",id:"automatic",level:5},{value:"Manual",id:"manual",level:5},{value:"Concrete",id:"concrete",level:3},{value:"No Layout",id:"no-layout",level:5},{value:"With Layout",id:"with-layout",level:5},{value:"Func",id:"func",level:3},{value:"Abstract Syntax",id:"abstract-syntax",level:3},{value:"Concrete Syntax",id:"concrete-syntax",level:3},{value:"Eval0",id:"eval0",level:3},{value:"Eval1",id:"eval1",level:3},{value:"Eval2",id:"eval2",level:3},{value:"Eval3",id:"eval3",level:3},{value:"Load AST",id:"load-ast",level:3},{value:"Parse",id:"parse",level:3},{value:"Lisra",id:"lisra",level:3},{value:"Syntax",id:"syntax",level:3},{value:"Runtime",id:"runtime",level:3},{value:"Parse",id:"parse-1",level:3},{value:"Pretty",id:"pretty",level:3},{value:"Eval",id:"eval",level:3},{value:"Test",id:"test",level:3},{value:"Pico",id:"pico",level:3},{value:"Abstract",id:"abstract-1",level:3},{value:"Assembly",id:"assembly",level:3},{value:"Compile",id:"compile",level:3},{value:"ControlFlow",id:"controlflow",level:3},{value:"Evaluate",id:"evaluate",level:3},{value:"IDE",id:"ide",level:3},{value:"Load",id:"load",level:3},{value:"Syntax",id:"syntax-1",level:3},{value:"Typecheck",id:"typecheck",level:3},{value:"Uninit",id:"uninit",level:3},{value:"UseDef",id:"usedef",level:3},{value:"Visualize",id:"visualize",level:3},{value:"Metrics",id:"metrics",level:2},{value:"Measuring Java",id:"measuring-java",level:3},{value:"Measuring Classes",id:"measuring-classes",level:3},{value:"Measuring Methods",id:"measuring-methods",level:3},{value:"Visualization",id:"visualization",level:2},{value:"ADT",id:"adt",level:3},{value:"Draw a Logo",id:"draw-a-logo",level:3},{value:"Interactive Box Height",id:"interactive-box-height",level:3},{value:"My First Box",id:"my-first-box",level:3},{value:"ParseTree",id:"parsetree",level:3},{value:"Playing With Properties",id:"playing-with-properties",level:3}],u={toc:m};function d(e){var t=e.components,i=(0,f.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Recipes for writing Rascal programs."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"These ",(0,l.kt)("em",{parentName:"p"},"Rascal Recipes")," are a work-in-progress but will gradually evolve into a collection of basic Rascal language\nexamples and use cases. It consists of the following parts:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Recipes-Basic"},"Basic"),": Some basic, ",(0,l.kt)("em",{parentName:"p"},"hello world"),"-like, examples of Rascal programs.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Recipes-Common"},"Common"),": Solutions for some common tasks.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Recipes-Languages"},"Languages"),": Definitions of several languages and their tools.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Recipes-Metrics"},"Metrics"),": Computing.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Recipes-Visualization"},"Visualization"),": Recipes for creating visualizations."))),(0,l.kt)("p",null,"The following features are covered:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Basic language features.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Common tasks.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Fact extraction.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Language definition.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Syntax definition.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Parsing.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Transformation.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Code generation.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"IDE extensions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Visualization."))),(0,l.kt)("h2",{id:"basic"},"Basic"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Some basic, ",(0,l.kt)("em",{parentName:"p"},"hello world"),"-like, examples of Rascal programs."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"We discuss the following examples:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-Hello"},"Hello"),": Variations on the ubiquitous ",(0,l.kt)("em",{parentName:"p"},"Hello World")," example.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-Factorial"},"Factorial"),": Compute the factorial function.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-Squares"},"Squares"),": Print a list of squares.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-BottlesOfBeer"},"Bottles Of Beer"),": A Rascal version of a generator for the ",(0,l.kt)("em",{parentName:"p"},"99 Bottles of Beer")," song.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-Bubble"},"Bubble"),": Variout styles to write bubble sort.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-Even"},"Even"),": Produce a list of even numbers.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-FizzBuzz"},"FizzBuzz"),": We solve a well-known job interview puzzle.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Basic-Quine"},"Quine"),": A self-reproducing program."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,l.kt)("p",null,"These programs illustrate various features of Rascal; they are ",(0,l.kt)("strong",{parentName:"p"},"not representative")," as use cases of the language."),(0,l.kt)("h3",{id:"hello"},"Hello"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Variations on the ubiquitous ",(0,l.kt)("em",{parentName:"p"},"Hello World")," example."),(0,l.kt)("h3",{id:"hello-on-command-line"},(0,l.kt)("inlineCode",{parentName:"h3"},"hello")," on command line"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"We demonstrate hello via an interactive session with the Rascal system. First we get the prompt ",(0,l.kt)("inlineCode",{parentName:"p"},"rascal>")," that shows\nthat Rascal is ready for our input. Next, we import the library module ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#io"},"IO")," since hello world\nrequires printing. Rascal responds with the feedback ",(0,l.kt)("inlineCode",{parentName:"p"},"ok")," so we know that all went well. Finally, we call ",(0,l.kt)("inlineCode",{parentName:"p"},"println")," and\nproudly observe our first Rascal output","!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nprintln("Hello world, this is my first Rascal program");\n')),(0,l.kt)("h3",{id:"hello-as-function"},(0,l.kt)("inlineCode",{parentName:"h3"},"hello")," as function"),(0,l.kt)("p",null,"A slightly more audacious approach is to wrap the print statement in a function and call it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nvoid hello() {\n   println("Hello world, this is my first Rascal program");\n}\n')),(0,l.kt)("p",null,"When you type in a command and continue it on a new line the Rascal systems prompts you with ",(0,l.kt)("inlineCode",{parentName:"p"},">>>>>>>")," to indicate that\nmore input is needed. Don\u2019t get scared by the ",(0,l.kt)("inlineCode",{parentName:"p"},"void (): void hello();")," that you get back when typing in the hello\nfunction. The first ",(0,l.kt)("inlineCode",{parentName:"p"},"void ()")," part says the result is a function that returns nothing, and the second part ",(0,l.kt)("inlineCode",{parentName:"p"},"void\nhello()")," summarizes its value (or would you prefer a hex dump?). Finally, we call the ",(0,l.kt)("inlineCode",{parentName:"p"},"hello")," function and enjoy its\noutput."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"hello();\n")),(0,l.kt)("h3",{id:"hello-as-module"},(0,l.kt)("inlineCode",{parentName:"h3"},"hello")," as module"),(0,l.kt)("p",null,"The summit of hello-engineering can be reached by placing all the above in a separate module:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::basic::Hello\n\nimport IO;\n\nvoid hello() {\n   println("Hello world, this is my first Rascal program");\n}\n')),(0,l.kt)("p",null,"This module should be placed in \\<project dir",">","/src/demo/basic/Hello.rsc."),(0,l.kt)("p",null,"Using this Hello module is now simple:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::Hello;\nhello();\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"hello")," function is by default visible outside the ",(0,l.kt)("inlineCode",{parentName:"p"},"Hello")," module. We could stress this by adding writing ",(0,l.kt)("inlineCode",{parentName:"p"},"public\nvoid hello() { \u2026\u200b }"),". Restricting visibility to the module itself can be achieved by adding the keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"private")," to the\ndefinition of ",(0,l.kt)("inlineCode",{parentName:"p"},"hello"),"."),(0,l.kt)("h3",{id:"factorial"},"Factorial"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Compute the factorial function."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Factorial"},"factorial")," of a number N is defined as ",(0,l.kt)("inlineCode",{parentName:"p"},"N * (N-1) * (N-2) * \u2026\u200b * 1"),". Here\nis the Rascal version:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::basic::Factorial\n\nint fac(int N) = N <= 0 ? 1 : N * fac(N - 1); \n\nint fac2(0) = 1;  \ndefault int fac2(int N) = N * fac2(N - 1); \n\nint fac3(int N)  { \n  if (N == 0)\n     return 1;\n  return N * fac3(N - 1);\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fac")," is defined using a conditional expression to distinguish cases.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fac2")," distinguishes cases using pattern-based dispatch (",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Function"},"Rascal Functions"),"). Here the\ncase for ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," is defined.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Here all other cases for ",(0,l.kt)("inlineCode",{parentName:"p"},"fac2")," are defined (as indicated by the ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," keyword).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fac3")," shows a more imperative implementation of factorial."))),(0,l.kt)("p",null,"Here is how to use ",(0,l.kt)("inlineCode",{parentName:"p"},"fac"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::Factorial;\nfac(47);\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},"Note")),(0,l.kt)("p",{parentName:"blockquote"},"Indeed, Rascal supports arbitrary length numbers.")),(0,l.kt)("p",null,"Here is an example of ",(0,l.kt)("inlineCode",{parentName:"p"},"fac2"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"fac2(47);\n")),(0,l.kt)("h3",{id:"squares"},"Squares"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Print a list of squares"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"How can we print a list of squares? Here is a solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::basic::Squares\n\nimport IO; \n\n// Print a table of squares\n\nvoid squares(int N){\n  println("Table of squares from 1 to <N>\\n"); \n  for(int I <- [1 .. N + 1])\n      println("<I> squared = <I * I>");        \n}\n\n// a solution with a multi line string template:\n\nstr squaresTemplate(int N) \n  = "Table of squares from 1 to <N>\n    \'<for (int I <- [1 .. N + 1]) {>\n    \'  <I> squared = <I * I><}>";\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#io"},"IO")," module is imported since we want to print things using ",(0,l.kt)("inlineCode",{parentName:"p"},"println"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#String"},"String")," interpolation is used several times. Here the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"N")," is inserted in the header\nmessage.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The values of ",(0,l.kt)("inlineCode",{parentName:"p"},"I")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"I * I")," are inserted in each line that is printed.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define an alternative implementation ",(0,l.kt)("inlineCode",{parentName:"p"},"squareTemplate")," that is based on string templates and returns a string value\ninstead of printing the results itself."))),(0,l.kt)("p",null,"Here is how ",(0,l.kt)("inlineCode",{parentName:"p"},"square")," can be used:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::Squares;\nsquares(9);\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"squaresTemplate")," gives a similar result but now as a string:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"squaresTemplate(9);\n")),(0,l.kt)("p",null,"To get a truly identical result we have to import the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#io"},"IO")," module and print the value of\n",(0,l.kt)("inlineCode",{parentName:"p"},"squaresTemplate"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\nprintln(squaresTemplate(9));\n")),(0,l.kt)("h3",{id:"bottles-of-beer"},"Bottles Of Beer"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A Rascal version of a generator for the ",(0,l.kt)("em",{parentName:"p"},"99 Bottles of Beer")," song."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Programs that generate the lyrics for the song ",(0,l.kt)("em",{parentName:"p"},"99 Bottles of Beer")," are a popular way to compare programming languages.\nAt ",(0,l.kt)("a",{parentName:"p",href:"http://99-bottles-of-beer.net/"},"99-bottles-of-beer.net")," you can find versions in nearly 1500 different languages and\nthe lyrics can be found ",(0,l.kt)("a",{parentName:"p",href:"http://99-bottles-of-beer.net/lyrics.html"},"here"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is our version:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::basic::Bottles\n\nimport IO;\n\nstr bottles(0)     = "no more bottles"; \nstr bottles(1)     = "1 bottle";\ndefault str bottles(int n) = "<n> bottles"; \n\nvoid sing(){ \n  for(n <- [99 .. 0]){\n       println("<bottles(n)> of beer on the wall, <bottles(n)> of beer.");\n       println("Take one down, pass it around, <bottles(n-1)> of beer on the wall.\\n");\n  }\n  println("No more bottles of beer on the wall, no more bottles of beer.");\n  println("Go to the store and buy some more, 99 bottles of beer on the wall.");\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We use an auxiliary function ",(0,l.kt)("inlineCode",{parentName:"p"},"bottles"),' that returns the word "bottle" adjusted for the actual number of bottles that\nis available. Observe how we use the patterns ',(0,l.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"int n")," in the definition of three variants of this\nfunction.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("em",{parentName:"p"},"Pattern-directed invocation")," (see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Function"},"function declaration"),") will determine at the call\nsite which function will be called. The general case is labeled with ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," to indicate that if the case for 0\nand 1 do not match, this alternative should handle the other cases.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The main function is ",(0,l.kt)("inlineCode",{parentName:"p"},"sing")," that iterates over the numbers 99 down to 1 (as described by the range ",(0,l.kt)("inlineCode",{parentName:"p"},"[99 .. 0]"),") and\nprints appropriate lyrics. Observe how the value of the ",(0,l.kt)("inlineCode",{parentName:"p"},"bottles")," function is interpolated several times in the\nstring."))),(0,l.kt)("p",null,"Here is the result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::Bottles;\nsing();\n")),(0,l.kt)("h3",{id:"bubble"},"Bubble"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Variout styles to write bubble sort."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Bubble_sort"},"Bubble sort")," is a classical (albeit not the most efficient) technique to sort\nlists of values. We present here several styles to implement bubble sort. Also see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#sort"},"sort")," for a\nmore efficient library function for sorting."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::basic::Bubble\n\nimport List;\n\n// Variations on Bubble sort\n\n// sort1: uses list indexing and a for-loop\n\nlist[int] sort1(list[int] numbers) {\n  if (size(numbers) > 0) {\n     for (int i <- [0 .. size(numbers)-1]) {\n       if (numbers[i] > numbers[i+1]) {\n         <numbers[i], numbers[i+1]> = <numbers[i+1], numbers[i]>;\n         return sort1(numbers);\n       }\n    }\n  }\n  return numbers;\n}\n\n// sort2: uses list matching and switch\n\nlist[int] sort2(list[int] numbers) {\n  switch(numbers){\n    case [*int nums1, int p, int q, *int nums2]:\n       if (p > q) {\n          return sort2(nums1 + [q, p] + nums2);\n       } else {\n          fail;\n       }\n     default: return numbers;\n   }\n}\n\n// sort3: uses list matching and while\n\nlist[int] sort3(list[int] numbers) {\n  while ([*int nums1, int p, *int nums2, int q, *int nums3] := numbers && p > q)\n        numbers = nums1 + [q] + nums2 + [p] + nums3;\n  return numbers;\n}\n\n// sort4: using recursion instead of iteration, and splicing instead of concat\nlist[int] sort4([*int nums1, int p, *int nums2, int q, *int nums3]) {\n  if (p > q)\n    return sort4([*nums1, q, *nums2, p, *nums3]);\n  else\n    fail sort4;\n}\n\ndefault list[int] sort4(list[int] x) = x;\n\n// sort5: inlines the condition into a when:\nlist[int] sort5([*int nums1, int p, *int nums2, int q, *int nums3])\n  = sort5([*nums1, q, *nums2, p, *nums3])\n  when p > q;\n\ndefault list[int] sort5(list[int] x) = x;\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sort1")," is a classic, imperative style, implementation of bubble sort: it iterates over consecutive pairs of elements\nand when a not-yet-sorted pair is encountered, the elements are exchanged, and ",(0,l.kt)("inlineCode",{parentName:"p"},"sort1")," is applied recursively to the\nwhole list."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sort2")," uses list matching and consists of a switch with two cases:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a case matching a list with two consecutive elements that are unsorted. Observe that when the pattern of a case\nmatches, the case as a whole can still fail.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a default case."))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sort3")," also uses list matching but in a more declarative style: as long as there are unsorted elements in the list\n(possibly with intervening elements), exchange them."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sort4")," is identical to ",(0,l.kt)("inlineCode",{parentName:"p"},"sort3"),", except that the shorter ",(0,l.kt)("inlineCode",{parentName:"p"},"*"),"-notation for list variables is used and that the type\ndeclaration for the the non-list variables has been omitted."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sort5")," uses tail recursion to reach a fixed point instead of a while loop. One alternative matches lists with\nout-of-order elements, while the default alternative returns the list if no out-of-order elements are found."),(0,l.kt)("p",null,"Let\u2019s put them to the test:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::Bubble;\nL = [9,8,7,6,5,4,3,2,1];\nsort1(L);\nsort2(L);\nsort3(L);\nsort4(L);\nsort5(L);\n")),(0,l.kt)("h3",{id:"even"},"Even"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Produce a list of even numbers."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Let\u2019s write a function that generates all the even numbers in a list up to a certain maximum. We will do it in a few\nalternative ways: from very imperative to very declarative and some steps in between."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even0(int max) {\n  list[int] result = [];\n  for (int i <- [0..max])\n    if (i % 2 == 0)\n      result += i;\n  return result;\n}\neven0(25);\n")),(0,l.kt)("p",null,"Now lets remove the temporary type declarations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even1(int max) {\n  result = [];\n  for (i <- [0..max])\n    if (i % 2 == 0)\n      result += i;\n  return result;\n}\neven1(25);\n")),(0,l.kt)("p",null,"To make the code shorter, we can inline the condition in the for loop:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even2(int max) {\n  result = [];\n  for (i <- [0..max], i % 2 == 0)\n    result += i;\n  return result;\n}\neven2(25);\n")),(0,l.kt)("p",null,"In fact, for loops may produce lists as values, using the append statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even3(int max) {\n  result = for (i <- [0..max], i % 2 == 0)\n    append i;\n  return result;\n}\neven3(25);\n")),(0,l.kt)("p",null,"So now, the result temporary is not necessary anymore:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even4(int max) {\n  return for (i <- [0..max], i % 2 == 0)\n           append i;\n}\neven4(25);\n")),(0,l.kt)("p",null,"This code is actually very close to a list comprehension already:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even5(int max) {\n  return [ i | i <- [0..max], i % 2 == 0];\n}\neven5(25);\n")),(0,l.kt)("p",null,"And now we can just define ",(0,l.kt)("inlineCode",{parentName:"p"},"even")," using an expression only:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"list[int] even6(int max) = [i | i <- [0..max], i % 2 == 0];\neven6(25);\n")),(0,l.kt)("p",null,"Or, perhaps we prefer creating a set instead of a list:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"set[int] even7(int max) = {i | i <- [0..max], i % 2 == 0};\neven7(25);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"You can program in for loops and use temporary variables if you like.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Comprehensions are shorter and more powerful.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There are comprehensions for lists, sets, and maps"))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trainwreck alert: if you start putting too many conditions in a single for loop or comprehension the code may become\nunreadable.")),(0,l.kt)("h3",{id:"fizzbuzz"},"FizzBuzz"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"We solve a well-known job interview puzzle."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html"},"FizzBuzz")," is a well-known puzzle that is\nused at job interviews. It is defined as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'Write a program that prints the numbers from 1 to 100.\nBut for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz".\nFor numbers which are multiples of both three and five print "FizzBuzz".\n')),(0,l.kt)("p",null,"Surprisingly, many candidates fail to pass this test. Solutions to FizzBuzz in various languages are available\n",(0,l.kt)("a",{parentName:"p",href:"http://www.geekschool.org/programming/fizzbuzz/"},"here"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here are a few possible Rascal solutions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::basic::FizzBuzz\n\nimport IO;\n\nvoid fizzbuzz() {\n   for (int n <- [1 .. 101]){\n      fb = ((n % 3 == 0) ? "Fizz" : "") + ((n % 5 == 0) ? "Buzz" : "");\n      println((fb == "") ?"<n>" : fb);\n   }\n}\n\nvoid fizzbuzz2() {\n  for (n <- [1..101])\n    switch(<n % 3 == 0, n % 5 == 0>) {\n      case <true,true>  : println("FizzBuzz");\n      case <true,false> : println("Fizz");\n      case <false,true> : println("Buzz");\n      default: println(n);\n    }\n}\n\nvoid fizzbuzz3() {\n  for (n <- [1..101]) {\n    if (n % 3 == 0) print("Fizz");\n    if (n % 5 == 0) print("Buzz");\n    else if (n % 3 != 0) print(n);\n    println("");\n  }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::FizzBuzz;\nfizzbuzz();\n")),(0,l.kt)("h3",{id:"quine"},"Quine"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A self-reproducing program."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"A ",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Quine_(computing)"},"quine")," is a computer program that takes no input and produces a\ncopy of its own source code. A quine is also called a ",(0,l.kt)("em",{parentName:"p"},"self-replicating")," or ",(0,l.kt)("em",{parentName:"p"},"self-reproducing")," program."),(0,l.kt)("p",null,"At the ",(0,l.kt)("a",{parentName:"p",href:"http://www.nyx.net/~gthompso/quine.htm"},"Quine Page")," you can find hundreds of quines in many different\nprogramming languages."),(0,l.kt)("p",null,"Learning about quines, is about learning how to quote and escape symbols in strings."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::basic::Quine\n\nimport IO;\nimport String;\n\nvoid quine(){\n  println(program); \n  println("\\"" + escape(program, ("\\"" : "\\\\\\"", "\\\\" : "\\\\\\\\")) + "\\";"); \n}\n\nstr program = \n"module demo::basic::Quine\n\nimport IO;\nimport String;\n\nvoid quine(){\n  println(program);\n  println(\\"\\\\\\"\\" + escape(program, (\\"\\\\\\"\\" : \\"\\\\\\\\\\\\\\"\\", \\"\\\\\\\\\\" : \\"\\\\\\\\\\\\\\\\\\")) + \\"\\\\\\";\\");\n}\n\nstr program ="; \n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A remarkable point in the code: the string variable ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," has as value the text of the module ",(0,l.kt)("inlineCode",{parentName:"p"},"Quine")," upto here.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," ends here. This string has a mesmerizing amount of escapes to which we will come back in\na moment.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"quine")," prints the string ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," twice, here as is and this produces the program upto\n",(0,l.kt)("img",{alt:"1",src:n(106).Z,width:"12",height:"12"})," above.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Here the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," is printed as a string (surrounded with string quotes) in order to reproduce the string\nvalue of ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," followed by a semi-colon (",(0,l.kt)("inlineCode",{parentName:"p"},";"),")."))),(0,l.kt)("p",null,"Now here is the catch: we have to be very carefull in handling special characters like quote (",(0,l.kt)("inlineCode",{parentName:"p"},'"'),") and backslash (",(0,l.kt)("inlineCode",{parentName:"p"},"\\"),")\nin strings."),(0,l.kt)("p",null,"Let\u2019s do a simple experiment:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nstr greeting = "\\"Good Morning, Dr. Watson\\", said Holmes";\nprintln("\\"" + greeting + "\\"");\n')),(0,l.kt)("p",null,"As you see the quotes inside the string are not escaped and the result is not a legal string. So what can we do? We\nescape all dangerous characters in the string before printing it using the ","[","Rascal:escape","]"," function. It takes a string\nand a map of characters to be escaped and returns a result in which all escaping has been carried out. Be aware that in\nthe map, also escaping is needed","!"," We want to say: escape ",(0,l.kt)("inlineCode",{parentName:"p"},'"')," and replace it by ",(0,l.kt)("inlineCode",{parentName:"p"},'\\"'),", but since both ",(0,l.kt)("inlineCode",{parentName:"p"},'"')," and ",(0,l.kt)("inlineCode",{parentName:"p"},"\\")," have to\nbe escaped themselves we have to say: escape ",(0,l.kt)("inlineCode",{parentName:"p"},'"\\""')," and replace it by ",(0,l.kt)("inlineCode",{parentName:"p"},'"\\\\\\""'),". The effect is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import String;\nprintln("\\"" + escape(greeting, ("\\"": "\\\\\\"")) + "\\"");\n')),(0,l.kt)("p",null,"And indeed, the two quotes are now properly escaped."),(0,l.kt)("p",null,"This is exactly what happens at ",(0,l.kt)("img",{alt:"4",src:n(3825).Z,width:"12",height:"12"})," in the definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"quine"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'println("\\"" + escape(program, ("\\"" : "\\\\\\"", "\\\\" : "\\\\\\\\")) + "\\";");\n')),(0,l.kt)("p",null,"We escape ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," and replace ",(0,l.kt)("inlineCode",{parentName:"p"},'"')," by ",(0,l.kt)("inlineCode",{parentName:"p"},'\\"'),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"\\")," by ",(0,l.kt)("inlineCode",{parentName:"p"},"\\\\"),". The mesmerizing amount of ",(0,l.kt)("inlineCode",{parentName:"p"},"\\")," characters can be explained\ndue to escaping ",(0,l.kt)("inlineCode",{parentName:"p"},'"')," and ",(0,l.kt)("inlineCode",{parentName:"p"},"\\"),"."),(0,l.kt)("p",null,"Now let\u2019s put ",(0,l.kt)("inlineCode",{parentName:"p"},"quine")," to the test."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::basic::Quine;\nquine();\n")),(0,l.kt)("p",null,"If you follow this output line-by-line you will see that it is identical to the original source code of module ",(0,l.kt)("inlineCode",{parentName:"p"},"Quine"),"."),(0,l.kt)("h2",{id:"common"},"Common"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Solutions for some common tasks."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"We discuss the following tasks:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-AdHocDataExploration"},"Ad Hoc Data Exploration"),": Using Rascal to explore an interesting data space.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-CallAnalysis"},"Call Analysis"),": Analyzing the call structure of an application.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-CallLifting"},"Call Lifting"),": Lift procedure calls to component calls.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-ColoredTrees"},"Colored Trees"),": Computations on binary trees.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-CountConstructors"},"Count Constructors"),": Generic function that can count constructors in a value of any\nalgebraic data type.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-Derivative"},"Derivative"),": Symbolic differentiation.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-StringTemplate"},"String Template"),": Using string templates to generate code.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-WordCount"},"Word Count"),": Counting words in strings."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#WordCount-CountInLine1"},"CountInLine1"),": Count words in a line.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#WordCount-CountInLine2"},"CountInLine2"),": Count words in a line.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#WordCount-CountInLine3"},"CountInLine3"),": Count words in a line.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#WordCount-Jabberwocky"},"Jabberwocky"),": Lewis Carroll\u2019s well-known poem.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Common-WordReplacement"},"Word Replacement"),": Replace words in a string."))),(0,l.kt)("h3",{id:"ad-hoc-data-exploration"},"Ad Hoc Data Exploration"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Using Rascal to explore an interesting data space."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"The problem we will look at comes from mathematics, and has a precise analytical solution, but let\u2019s use Rascal to\nexplore the state space, and see how it can help us to build intuition."),(0,l.kt)("p",null,"As you know, Rascal supports arbitrarily large numbers cleanly and simply, unlike more traditional languages like C or\nJava. For example, if you want to compute 1000","!",", then it\u2019s a simple matter of calling ",(0,l.kt)("inlineCode",{parentName:"p"},"fact(1000)")," at the command line.\nLet\u2019s use this definition of factorial:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"public int fact (int n) {\n    if (n <= 1) {\n        return 1;\n    } else {\n        return n * fact (n-1);\n    }\n}\n")),(0,l.kt)("p",null,"If you compute ",(0,l.kt)("inlineCode",{parentName:"p"},"fact(1000)")," at the Rascal command line, you get a large number, on the order of 4.02 x\n10",(0,l.kt)("sup",null,"2567"),". This is much, much bigger than, say a google, which is a mere 10\\<",(0,l.kt)("sup",null,">","100"),". (If Rascal runs\nout stack space, try computing 100","!",", then 200","!",", then \u2026\u200b then 1000","!","; the run-time will allocate more stack space\nincrementally and automatically if you sneak up to where you want to go)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"rascal> fact(1000);\nint: 402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n")),(0,l.kt)("p",null,"Now copy the numerical result above and paste it into an edit window to have a good look at it. Notice anything\ninteresting? The last 249 digits are all zeros. How did this happen and what does it mean?"),(0,l.kt)("p",null,"To be honest, when I did this calculation for the first time, I thought I\u2019d found a bug. So I looked at the values of\nN","!"," for N in the range 900 to 1000 and discovered that the zeros accumulate on the end of N","!"," as N gets bigger. Let\u2019s\nthink about it for a bit: N","!"," is a cumulative product, so once a zero has appeared on the end there is no way to get rid\nof it by multiplying by a positive integer."),(0,l.kt)("p",null,"How do the zeros appear? Well, this isn\u2019t to hard to figure out. Obviously, each time you reach a multiple of 10, you\nwill add (at least) one more zero to the cumulative product. But what about multiples of 5? Well, you would add one more\nzero if you can match the 5 to a 2 within the factors, and there are lots of lonely 2s in that list. So, to summarize,\neach time N is a multiple of 5, you add at least one zero onto the cumulative product N","!","."),(0,l.kt)("p",null,"So here\u2019s the question we\u2019re going to solve: For an arbitrary N, can you predict exactly how many trailing zeros there\nwill be in N","!","?"),(0,l.kt)("p",null,'Again, this can be solved analytically (and if you go looking on the web, you will discover that this is an old chestnut\nof a math problem that\u2019s sometimes used in job interviews to test analytical ability), but what I want to do here is to\nshow how we can use Rascal to play around with the problem space a bit to help us build up our intuition. This is very\nmuch like what we do in empirical software engineering, when we have lots of data to analyze, and we\u2019re trying to look\nfor patterns that might explain behaviours, such as why some functions are more likely to be associated with bugs than\nothers. In that kind of situation, we typically go through two stages: first, we wade through the data, exploring\nrelationships, looking for unusual lumps or recognizable patters; second, we build theories of how the world works, and\ntest them out using the data. In both stages, we not only look at the data, we play with it. We build little tools to\nhelp answer our questions, see where our hunches lead us. We use this "play" to improve our understanding of the problem\nspace, and build intuition about how it works as testable theories. In empirical software engineering, as in most other\nsciences, we usually don\u2019t get concrete proof of a theory; rather, we gather evidence towards ultimately accepting or\nrejecting the theories (tho often, we may choose to use this evidence to refine the theories and try again).'),(0,l.kt)("p",null,'In this case, however, there is a precise analytical solution, a proof, a "ground truth". But that doesn\u2019t mean that we\ncan\u2019t use the empirical approach to help build our intuition about the problem space, and ultimately devise a theory\nabout how to calculate the number of trailing zeros in N',"!",". Solving analytical problems is about having enough intuition\nto see possible solutions. And using this empirical approach is one way to build intuition."),(0,l.kt)("p",null,"So let\u2019s define a few helper functions and see where that leads us:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"public int countZeros (int n) {\n    if (n < 10) {\n        return 0;\n    } else if (n % 10 == 0) {\n        return 1 + countZeros (n / 10);\n    } else {\n        return countZeros (n / 10);\n    }\n}\nrascal> int i = fact(1000);\nint: 402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\nrascal> countZeros(i);\nint: 472\n")),(0,l.kt)("p",null,"This was my first try at the solution (really","!","), and there\u2019s a problem: 1000","!"," has exactly 249 trailing zeros, not 472."),(0,l.kt)("p",null,"What did I do wrong? Oh, right, ",(0,l.kt)("em",{parentName:"p"},"trailing")," zeros, and the above function counts ",(0,l.kt)("em",{parentName:"p"},"all")," of the zeros. Let\u2019s try again:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"public int countTrailingZeros (int n) {\n    if (n < 10) {\n        return 0;\n    } else if (n % 10 == 0) {\n        return 1 + countTrailingZeros (n / 10);\n    } else {\n        return 0 ;\n    }\n}\n\nrascal> countTrailingZeros(i);\nint: 249\n")),(0,l.kt)("p",null,"OK, so we\u2019re making progress. Let\u2019s define another function to help us explore the data space:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'public void printLastTwenty (int n){\n    for(int i <- [n-19..n+1]) {\n        println ("<i>! has <countTrailingZeros(fact(i))> trailing zeros.");\n    }\n}\n\nrascal>printLastTwenty(1000);\n981! has 243 trailing zeros.\n982! has 243 trailing zeros.\n983! has 243 trailing zeros.\n984! has 243 trailing zeros.\n985! has 244 trailing zeros.\n986! has 244 trailing zeros.\n987! has 244 trailing zeros.\n988! has 244 trailing zeros.\n989! has 244 trailing zeros.\n990! has 245 trailing zeros.\n991! has 245 trailing zeros.\n992! has 245 trailing zeros.\n993! has 245 trailing zeros.\n994! has 245 trailing zeros.\n995! has 246 trailing zeros.\n996! has 246 trailing zeros.\n997! has 246 trailing zeros.\n998! has 246 trailing zeros.\n999! has 246 trailing zeros.\n1000! has 249 trailing zeros.\nok\n')),(0,l.kt)("p",null,"So the pattern I see arising (confirmed by more playing that I won\u2019t show you) is that you add a zero every time N is\ndivisible by 5. But sometimes you add more than one zero: 1000","!"," adds three zeros."),(0,l.kt)("p",null,"We defined one function above to help us look at the data more compactly; now let\u2019s create another function to look for\nlumps in the data:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'// Printout all i in [0..n] where i! has more trailing zeros than (i-1)!\npublic void findLumps (int n) {\n    int iMinusOneFactZeros = 0;\n    for (int i <- [1..n+1]) {\n        int iFactZeros = countTrailingZeros(fact(i));\n        int diff = iFactZeros - iMinusOneFactZeros ;\n        if (diff >= 1) {\n            println ("<diff> more zeros at <i>!");\n        }\n        iMinusOneFactZeros = iFactZeros;\n    }\n}\n\nrascal>findLumps(1000);\n1 more zeros at 5!\n1 more zeros at 10!\n1 more zeros at 15!\n1 more zeros at 20!\n2 more zeros at 25!\n1 more zeros at 30!\n1 more zeros at 35!\n1 more zeros at 40!\n1 more zeros at 45!\n2 more zeros at 50!\n1 more zeros at 55!\n1 more zeros at 60!\n1 more zeros at 65!\n1 more zeros at 70!\n2 more zeros at 75!\n1 more zeros at 80!\n1 more zeros at 85!\n1 more zeros at 90!\n1 more zeros at 95!\n2 more zeros at 100!\n1 more zeros at 105!\n1 more zeros at 110!\n1 more zeros at 115!\n1 more zeros at 120!\n3 more zeros at 125!\n1 more zeros at 130!\n...\n1 more zeros at 245!\n3 more zeros at 250!\n1 more zeros at 255!\n1 more zeros at 495!\n3 more zeros at 500!\n1 more zeros at 505!\n...\n1 more zeros at 620!\n4 more zeros at 625!\n1 more zeros at 630!\n...\n1 more zeros at 985!\n1 more zeros at 990!\n1 more zeros at 995!\n3 more zeros at 1000!\nok\n')),(0,l.kt)("p",null,"So probably we\u2019re noticing some patterns here already, and maybe forming some intuition. But let\u2019s first revise our\nlump-finding function to produce even more concise output:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'// We can parameterize the threshold to look for jumps of 2, 3, or 4 zeros\npublic void findLumps2 (int n, int tao) {\n    int iMinusOneFactZeros = 0;\n    for (int i <- [1..n+1]) {\n        int iFactZeros = countTrailingZeros(fact(i));\n        int diff = iFactZeros - iMinusOneFactZeros ;\n        if (diff >= tao) {\n            println ("<diff> more zeros at <i>!");\n        }\n        iMinusOneFactZeros = iFactZeros;\n    }\n}\n\nrascal>findLumps2(1000,2);\n2 more zeros at 25!\n2 more zeros at 50!\n2 more zeros at 75!\n2 more zeros at 100!\n3 more zeros at 125!\n2 more zeros at 150!\n2 more zeros at 175!\n2 more zeros at 200!\n2 more zeros at 225!\n3 more zeros at 250!\n2 more zeros at 275!\n...\n2 more zeros at 950!\n2 more zeros at 975!\n3 more zeros at 1000!\nok\n\nrascal>findLumps2(1000,3);\n3 more zeros at 125!\n3 more zeros at 250!\n3 more zeros at 375!\n3 more zeros at 500!\n4 more zeros at 625!\n3 more zeros at 750!\n3 more zeros at 875!\n3 more zeros at 1000!\nok\n\nrascal>findLumps2(1000,4);\n4 more zeros at 625!\nok\n')),(0,l.kt)("p",null,"Notice anything yet? Here are some fun math facts to consider:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"5",(0,l.kt)("sup",null,"0")," = 1")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"5",(0,l.kt)("sup",null,"1")," = 5")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"5 ",(0,l.kt)("sup",null,"2")," = 25")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"5",(0,l.kt)("sup",null,"3")," = 125")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"5",(0,l.kt)("sup",null,"4")," = 625")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"5",(0,l.kt)("sup",null,"5")," = 3125"))),(0,l.kt)("p",null,"So here\u2019s the solution:"),(0,l.kt)("p",null,"Let N be a positive integer."),(0,l.kt)("p",null,"Let k = floor (log",(0,l.kt)("sub",null,"5")," N)"),(0,l.kt)("p",null,"Start a counter at zero, call it nz"),(0,l.kt)("p",null,"We want to examine i \u2190 ","[","1..N+1","]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If i is not divisible by 5, ignore it")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If i is divisible by 5, add 1 to nz")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If i is also divisible by 25, add 1 more")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u2026\u200b")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If i is also divisible by 2k, add 1 more"))),(0,l.kt)("p",null,"We can write this in Rascal as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"public int predictZeros (int N) {\n    int k = floorLogBase(N, 5);  // I wrote this\n    int nz = 0;\n    for (int i <- [1..N+1] ) {\n        int p5 = 1;\n        for (int j <- [1..k+1]) {\n            p5 *= 5;\n            if (i % p5 == 0) {\n                nz += 1;\n            } else {\n                break;\n            }\n        }\n    }\n    return nz;\n}\n")),(0,l.kt)("p",null,"Now a little hand validation might convince you that this should work, but let\u2019s write a little verifier function to be\nsure:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'public void verifyTheory (int N) {\n    int checkInterval = 100; // for printing\n    bool failed = false;\n    for (int i <- [1..N+1]) {\n        ifact=fact(i);\n        int p = predictZeros(i);\n        int c = countTrailingZeros(ifact);\n        if (p != c) {\n            failed = true;\n            println ("Found a counter example at i=<i>");\n            break;\n        } else {\n            if (i % checkInterval == 0) {\n                println ("<i>! has <p> trailing zeros");\n            }\n        }\n    }\n    if (!failed) {\n        println ("The theory works for i: 1..<N>");\n    }\n}\n\nrascal>verifyTheory(10);\nThe theory works for i: 1..10\nok\n\nrascal>verifyTheory(100);\n100! has 24 trailing zeros\nThe theory works for i: 1..100\nok\n\nrascal>verifyTheory(1000);\n100! has 24 trailing zeros\n200! has 49 trailing zeros\n300! has 74 trailing zeros\n400! has 99 trailing zeros\n500! has 124 trailing zeros\n600! has 148 trailing zeros\nFound a counter example at i=625\n    predicted zeros = 155\n    observed zeros  = 156\nok\n')),(0,l.kt)("p",null,"Yikes, what do we do? Well, first let\u2019s look under the hood at the engine. The function ",(0,l.kt)("inlineCode",{parentName:"p"},"predictZeros")," ",(0,l.kt)("em",{parentName:"p"},"is")," actually\ncorrect, assuming that the functions is calls are correct. So let\u2019s look at the auxiliary functions I wrote (but haven\u2019t\nshown you yet):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"// Log for an arbitrary base\npublic real logB(real a, real base) {\n    return log(a) / log(base);\n}\n\npublic real floor (real a) {\n    return toReal(round (a - 0.5));\n}\n\npublic int floorLogBase (int a, int b) {\n    return toInt(floor(logB(toReal(a), toReal(b))));\n}\n\nrascal>floorLogBase(625,5);\nint: 3\nrascal>logB(625.0,5.0);\nreal: 3.9999999999999998757330130880776320985295476764801684...\n")),(0,l.kt)("p",null,"Oh right, real numbers are prone to round off error. What should we do?"),(0,l.kt)("p",null,'Well, here\u2019s a bad solution (that "works"):'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"public real floor (real a) {\n    return toReal(round (a - 0.5 + 0.00001));\n}\n")),(0,l.kt)("p",null,"But how can I be sure that that\u2019s enought decimal places? What if someone likes my ",(0,l.kt)("inlineCode",{parentName:"p"},"floor")," function and sticks it into\nthe Rascal library, where it is subsequently used by the Eurpoean Space Agency for its next generation of flight control\nsoftware?"),(0,l.kt)("p",null,"Sometimes, the answer is to do a lot of homework. Lucky for us, here there is a fairly efficient exact solution using\nrepeated integer division:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"// Also change predictZeros to call this version\npublic int floorLogBase2 (int a, int b) {\n    int remaining = a;\n    int ans = 0;\n    while (remaining >= b) {\n        ans += 1;\n        remaining /= b;\n    }\n    return ans;\n}\n\nrascal>verifyTheory(1000);\n100! has 24 trailing zeros\n200! has 49 trailing zeros\n300! has 74 trailing zeros\n400! has 99 trailing zeros\n500! has 124 trailing zeros\n600! has 148 trailing zeros\n700! has 174 trailing zeros\n800! has 199 trailing zeros\n900! has 224 trailing zeros\n1000! has 249 trailing zeros\nThe theory works for i: 1..1000\nok\n")),(0,l.kt)("p",null,"And we\u2019re done. But what did we learn here? Here\u2019s what I think:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Explore the terrain, take notes, build intuition, develop theories, test them."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Refine and repeat")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Double check","!")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'Build infrastructure with natural "break points"'),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Understandable is better than fast, esp. in the beginning")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The correct way is better than the easy way"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The correct way may be pretty easy too"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Document and later challenge your assumptions"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Are you measuring what you think you are measuring? How do you know?")))),(0,l.kt)("h3",{id:"call-analysis"},"Call Analysis"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Analyzing the call structure of an application."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Suppose a mystery box ends up on your desk. When you open it, it contains a huge software system with several questions\nattached to it:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"How many procedure calls occur in this system?")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"How many procedures does it contains?")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"What are the entry points for this system, i.e., procedures that call others but are not called themselves?")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"What are the leaves of this application, i.e., procedures that are called but do not make any calls themselves?")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Which procedures call each other indirectly?")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Which procedures are called directly or indirectly from each entry point?")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Which procedures are called from all entry points?"))),(0,l.kt)("p",null,"Let\u2019s see how these questions can be answered using Rascal."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Consider the following call graph (a box represents a procedure and an arrow represents a call from one procedure to\nanother procedure):"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"calls",src:n(6931).Z,width:"435",height:"231"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import Set;\nimport Relation;\nimport analysis::graphs::Graph;\n")),(0,l.kt)("p",null,"Rascal supports basic data types like integers and strings which are sufficient to formulate and answer the questions at\nhand. However, we can gain readability by introducing separately named types for the items we are describing. First, we\nintroduce therefore a new type ",(0,l.kt)("inlineCode",{parentName:"p"},"Proc")," (an alias for strings) to denote procedures:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"alias Proc = str;\n")),(0,l.kt)("p",null,"Next, we have to represent the call relation as a Rascal datatype, and the relation is the most appropriate for it. As\npreparation, we also import the libraries ","[","$Rascal:Prelude/Set","]",", ","[","$Rascal:Prelude/Relation","]"," and\n","[","$Rascal:Libraries/analysis/graphs/Graph","]"," that will come in handy."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rel[Proc, Proc] Calls = {<"a", "b">, <"b", "c">, <"b", "d">, <"d", "c">,\n                         <"d", "e">, <"f", "e">, <"f", "g">, <"g", "e">};\n')),(0,l.kt)("p",null,"Now we are in a good position to start asking some questions."),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"How many calls occur in this system?")," We use the function ","[","Rascal:Set/size","]"," to determine the number of elements in a\nset or relation. Since each tuple in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Calls")," relation represents a call between procedures, the number of tuples is\nequal to the number of calls."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"size(Calls);\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"How many procedures occur in this system?")," This question is more subtle, since a procedure may call (or be called) by\nseveral others and the number of tuples is therefore not indicative. What we need are the set of procedures that occur\n(as first or second element) in ",(0,l.kt)("em",{parentName:"p"},"any")," tuple. This is precisely what the function\n","[","$Rascal:Libraries/Prelude/Relation/carrier","]"," gives us:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"carrier(Calls);\n")),(0,l.kt)("p",null,"and computing the number of procedures is now easy:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"size(carrier(Calls));\n")),(0,l.kt)("p",null,"As an aside, functions ","[","$Rascal:Prelude/Relation/domain","]"," and ","[","$Rascal:Prelude/Relation/range","]"," do the same for the\nfirst, respectively, second element of the pairs in a relation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"domain(Calls);\nrange(Calls);\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"What are the entry points for this system?")),(0,l.kt)("p",null,"The next step in the analysis is to determine which entry points this application has, i.e., procedures which call\nothers but are not called themselves. Entry points are useful since they define the external interface of a system and\nmay also be used as guidance to split a system in parts. The top of a relation contains those left-hand sides of tuples\nin a relation that do not occur in any right-hand side. When a relation is viewed as a graph, its top corresponds to the\nroot nodes of that graph. Similarly, the bottom of a relation corresponds to the leaf nodes of the graph. See the\nsection called ","[","$Rascal:Libraries/analysis/graphs/Graph","]"," for more details. Using this knowledge, the entry points can\nbe computed by determining the top of the Calls relation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"top(Calls);\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"What are the leaves of this application?")),(0,l.kt)("p",null,"In a similar spirit, we can determine the leaves of this application, i.e., procedures that are being called but do not\nmake any calls themselves:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"bottom(Calls);\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Which procedures call each other indirectly?")),(0,l.kt)("p",null,"We can also determine the indirect calls between procedures, by taking the transitive closure of the Calls relation,\nwritten as ",(0,l.kt)("inlineCode",{parentName:"p"},"Calls+"),". Observe that the transitive closure will contain both the direct and the indirect calls."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"closureCalls = Calls+;\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Which procedures are called directly or indirectly from each entry point?")),(0,l.kt)("p",null,'We now know the entry points for this application ("a" and "f") and the indirect call relations. Combining this\ninformation, we can determine which procedures are called from each entry point. This is done by indexing closureCalls\nwith appropriate procedure name. The index operator yields all right-hand sides of tuples that have a given value as\nleft-hand side. This gives the following:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'calledFromA = closureCalls["a"];\ncalledFromF = closureCalls["f"];\n')),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Which procedures are called from all entry points?")),(0,l.kt)("p",null,"Finally, we can determine which procedures are called from both entry points by taking the intersection of the two sets\n",(0,l.kt)("inlineCode",{parentName:"p"},"calledFromA")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"calledFromF"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"calledFromA & calledFromF;\n")),(0,l.kt)("p",null,"or if your prefer to write all of the above as a one-liner using a ","[","$Rascal:Expressions/Reducer","]"," expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(carrier(Calls) | it & (Calls+)[p] | p <- top(Calls));\n")),(0,l.kt)("p",null,"The reducer is initialized with all procedures (",(0,l.kt)("inlineCode",{parentName:"p"},"carrier(Calls)"),") and iterates over all entry points (",(0,l.kt)("inlineCode",{parentName:"p"},"p \u2190 top(Calls)"),").\nAt each iteration the current value of the reducer (",(0,l.kt)("inlineCode",{parentName:"p"},"it"),") is intersected (",(0,l.kt)("inlineCode",{parentName:"p"},"&"),") with the procedures called directly or\nindirectly from that entry point (",(0,l.kt)("inlineCode",{parentName:"p"},"(Calls+)[p]"),")."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In small examples, the above results can be easily obtained by a visual inspection of the call graph. Such a visual\ninspection does ",(0,l.kt)("em",{parentName:"li"},"not")," scale very well to large graphs and this makes the above form of analysis particularly suited\nfor studying large systems.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We discuss call analysis in a, intentionally, simplistic fashion that does not take into account how the call\nrelation is extracted from actual source code. The above principles are, however, applicable to real cases as well.")),(0,l.kt)("h3",{id:"call-lifting"},"Call Lifting"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Lift procedure calls to component calls."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"A frequently occurring problem is that we know the call relation of a system but that we want to understand it at the\ncomponent level rather than at the procedure level. If it is known to which component each procedure belongs, it is\npossible to lift the call relation to the component level. Actual lifting amounts to translating each call between\nprocedures by a call between components."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Consider the following figure:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Module Parts",src:n(2678).Z,width:"758",height:"309"})),(0,l.kt)("p",null,"(a) Shows the calls between procedures; (b) shows how procedures are part of a system component. (c) shows how the call\nrelation given in (a) can be lifted to the component level."),(0,l.kt)("p",null,"The situation can be characterized by:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A call relation between procedures")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A partOf relation between procedures and components"))),(0,l.kt)("p",null,"The problem is now to lift the call relation using the information in the partOf relation. In other words: a call\nbetween two procedures will be lifted to a call between the components to which each procedure belongs."),(0,l.kt)("p",null,"Here is a solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::common::Lift\n\nalias proc = str;\nalias comp = str;\n\nrel[comp,comp] lift(rel[proc,proc] aCalls, rel[proc,comp] aPartOf){\n    return { <C1, C2> | <proc P1, proc P2> <- aCalls,\n                        <comp C1, comp C2> <- aPartOf[P1] * aPartOf[P2] };\n}\n\n// Test set-up\n\nrel[proc,proc] Calls = {<"main", "a">, <"main", "b">, <"a", "b">, <"a", "c">, <"a", "d">,\n                        <"b", "d">};\n\nrel[proc, comp] PartOf = {<"main", "Appl">, <"a", "Appl">, <"b", "DB">,\n                          <"c", "Lib">, <"d", "Lib">};\n\nrel[comp,comp] ComponentCalls = lift(Calls, PartOf);\n')),(0,l.kt)("p",null,"And we can use it as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::common::Lift;\n")),(0,l.kt)("p",null,"Encode the call relation and partOf relation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'calls = {<"main", "a">, <"main", "b">, <"a", "b">, <"a", "c">, <"a", "d">, <"b", "d">};\npartOf = {<"main", "Appl">, <"a", "Appl">, <"b", "DB">, <"c", "Lib">, <"d", "Lib">};\n')),(0,l.kt)("p",null,"and do the lifting:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"lift(calls, partOf);\n")),(0,l.kt)("p",null,"Please verify that this corresponds exactly to (c) in the figure above."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,l.kt)("h3",{id:"colored-trees"},"Colored Trees"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Computations on binary trees."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"We consider binary trees---trees with exactly two children---that have integers as their leaves. Our trees can have red\nand black nodes and we want to perform the following operations on them:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Count the number of red nodes.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Compute the sum of all the integers that occur in the leaves.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Extend the tree data type with green nodes.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Replace all red nodes by green ones."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The definition of ColoredTrees is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::ColoredTrees\n\n// Define ColoredTrees with red and black nodes and integer leaves\n\ndata ColoredTree = leaf(int N) \n                 | red(ColoredTree left, ColoredTree right)\n                 | black(ColoredTree left, ColoredTree right);\n\npublic ColoredTree  rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\n// Count the number of red nodes\n\nint cntRed(ColoredTree t) {\n   int c = 0;\n   visit(t) {\n     case red(_,_): c = c + 1; \n   };\n   return c;\n}\n\ntest bool tstCntRed() = cntRed(rb) == 2;\n\n// Compute the sum of all integer leaves\n\nint addLeaves(ColoredTree t) {\n   int c = 0;\n   visit(t) {\n     case leaf(int N): c = c + N; \n   };\n   return c;\n}\n\ntest bool tstAddLeaves() = addLeaves(rb) == 13;\n\n// Add green nodes to ColoredTree\n\ndata ColoredTree = green(ColoredTree left, ColoredTree right); \n\n// Transform red nodes into green nodes\n\nColoredTree makeGreen(ColoredTree t) {\n   return visit(t) {\n     case red(l, r) => green(l, r) \n   };\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We define the data type of ",(0,l.kt)("inlineCode",{parentName:"p"},"ColoredTrees")," with constructors ",(0,l.kt)("inlineCode",{parentName:"p"},"leaf"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"red")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"black"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"cntRed")," counts all red nodes by visiting all nodes and incrementing the counter ",(0,l.kt)("inlineCode",{parentName:"p"},"c")," for each red one.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"addLeaves")," visits all nodes and adds the integers in each leaf node.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"coloredTrees")," are extended with a new constructor ",(0,l.kt)("inlineCode",{parentName:"p"},"green"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"makeGreen")," visits all nodes and turns red nodes in green ones."))),(0,l.kt)("p",null,"We can now explore ColoredTrees:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::common::ColoredTrees;\nrb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n")),(0,l.kt)("p",null,"Count the red nodes in ",(0,l.kt)("inlineCode",{parentName:"p"},"rb"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"cntRed(rb);\n")),(0,l.kt)("p",null,"and compute the sum of all leaves:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"addLeaves(rb);\n")),(0,l.kt)("p",null,"Finally, we convert all red nodes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"makeGreen(rb);\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Benefits.")),(0,l.kt)("p",null,"This example illustrates the fully automatic visiting of the elements of a structured data type. Compare this with the\ntraditional programming style in which a switch statement is used to determine the constructor and recursion is used to\nvisit substructures. This style becomes particularly cumbersome for data types with large numbers of constructors such\nas, for instance, abstract syntax trees for real programming languages."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,l.kt)("p",null,"The visit statement is based on a new paradigm one has to learn."),(0,l.kt)("h3",{id:"count-constructors"},"Count Constructors"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Generic function that can count constructors in a value of any algebraic data type."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"In ",(0,l.kt)("a",{parentName:"p",href:"#ColoredTrees"},"???"),", we have seen a function that can count the number of red nodes in a ",(0,l.kt)("inlineCode",{parentName:"p"},"ColoredTree"),". Is it\npossible to define a function that can count constructors in a value of any algerbaic data type?"),(0,l.kt)("p",null,"We exploit the subtype relation (see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#StaticTyping"},"Static Typing"),") between ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#ADT"},"algebraic data\ntypes"),"s and the type ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Node"},"node")," to achieve this."),(0,l.kt)("p",null,"In real applications this becomes relevant when counting, for instance, statement types in programs."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::CountConstructors\n\nimport Node;\nimport Map;\n\n// Define a ColoredTree data type\n\ndata ColoredTree = leaf(int N)\n                 | red(ColoredTree left, ColoredTree right)\n                 | black(ColoredTree left, ColoredTree right);\n\npublic ColoredTree CT = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\n\n// Define a Card data type.\n\ndata Suite = hearts() | diamonds() | clubs() | spades();\n\ndata Card =  two(Suite s) | three(Suite s) | four(Suite s) | five(Suite s) |\n             six(Suite s) | seven(Suite s) | eight(Suite s) | nine(Suite s) | ten(Suite s) |\n             jack(Suite s) | queen(Suite s) | king(Suite s) | ace(Suite s);\n\ndata Hand = hand(list[Card] cards);\n\npublic Hand H = hand([two(hearts()), jack(diamonds()), six(hearts()), ace(spades())]);\n\n// Count frequencies of constructors\n\nmap[str,int] count(node N){ \n  freq = (); \n  visit(N){  \n    case node M: { name = getName(M); \n                   freq[name] ? 0 += 1;\n                 }\n  }\n  return freq; \n}\n\nmap[str,int] countRelevant(node N, set[str] relevant) = domainR(count(N), relevant); \n")),(0,l.kt)("p",null,"Two data types are introduced ",(0,l.kt)("inlineCode",{parentName:"p"},"ColoredTree")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Hand")," together with an example value of each (",(0,l.kt)("inlineCode",{parentName:"p"},"CT"),", respectively, ",(0,l.kt)("inlineCode",{parentName:"p"},"H"),")."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," is defined.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Introduces an empty map to maintain the frequencies.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines a visit of argument ",(0,l.kt)("inlineCode",{parentName:"p"},"N"),"; it traverses the complete value of ",(0,l.kt)("inlineCode",{parentName:"p"},"N"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines the case that we encounter a node and we update its frequency count. First the name of the constructor is\nretrieved (using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#getname"},"getName"),") and then the frequency is updated. The\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#IsDefined"},"isDefined")," operator is used to provide a default value of 0 when the name was not yet\nin the map.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The map ",(0,l.kt)("inlineCode",{parentName:"p"},"freq")," is returned as result.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines a variant ",(0,l.kt)("inlineCode",{parentName:"p"},"countRelevant"),"; it gets is an extra argument of relevant constructors names that is used to\nfilter the map that is returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#domainr"},"domainR"),"."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::CountConstructors;\ncount(CT);\ncount(H);\ncountRelevant(H, {"hearts", "spades"});\n')),(0,l.kt)("h3",{id:"derivative"},"Derivative"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Symbolic differentiation."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Computing the ",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Differentiation_(mathematics)"},"derivative")," of an expression with respect\nto some variable is a classical calculus problem. Loosely speaking, a derivative can be thought of as how much one\nquantity is changing in response to changes in some other quantity; for example, the derivative of the position of a\nmoving object with respect to time is the object\u2019s instantaneous velocity."),(0,l.kt)("p",null,"We present here rules for determining the derivative ",(0,l.kt)("inlineCode",{parentName:"p"},"dE/dX")," of simple expressions ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," for a given variable ",(0,l.kt)("inlineCode",{parentName:"p"},"X"),". Recall\nthat for number ",(0,l.kt)("inlineCode",{parentName:"p"},"N"),", variables ",(0,l.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Y"),", and expressions ",(0,l.kt)("inlineCode",{parentName:"p"},"E1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"E2")," the following rules apply:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"dN / dX = 0"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"dX / dX = 1"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"dX / dY = 0"),", when ",(0,l.kt)("inlineCode",{parentName:"p"},"X != Y"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"d(E1 + E2) /dX = dE1 / dX + d E2 /dX"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"d(E1 * E2) / dX = (d E1 / dX * E2) + (E1 * d E2 /dX)"),"."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is our solution followed by a list of explanations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::common::Derivative\n\ndata Exp = con(int n) \n         | var(str name)\n         | mul(Exp e1, Exp e2)\n         | add(Exp e1, Exp e2)\n         ;\n\npublic Exp E = add(mul(con(3), var("y")), mul(con(5), var("x"))); \n\nExp dd(con(n), var(V))              = con(0); \nExp dd(var(V1), var(V2))            = con((V1 == V2) ? 1 : 0);\nExp dd(add(Exp e1, Exp e2), var(V)) = add(dd(e1, var(V)), dd(e2, var(V)));\nExp dd(mul(Exp e1, Exp e2), var(V)) = add(mul(dd(e1, var(V)), e2), mul(e1, dd(e2, var(V))));\n\nExp simp(add(con(n), con(m))) = con(n + m); \nExp simp(mul(con(n), con(m))) = con(n * m);\n\nExp simp(mul(con(1), Exp e))  = e;\nExp simp(mul(Exp e, con(1)))  = e;\nExp simp(mul(con(0), Exp e))  = con(0);\nExp simp(mul(Exp e, con(0)))  = con(0);\n\nExp simp(add(con(0), Exp e))  = e;\nExp simp(add(Exp e, con(0)))  = e;\n\ndefault Exp simp(Exp e)       = e; \n\nExp simplify(Exp e){ \n  return bottom-up visit(e){\n           case Exp e1 => simp(e1)\n         }\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define a data type ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp")," to represent expressions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Introduce an example expression ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," for later use.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define the actual differentiation function ",(0,l.kt)("inlineCode",{parentName:"p"},"dd"),". Observe that this definition depends on the use of patterns in\nfunction declarations, see ","[","Rascal:Function","]",".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define simplification rules.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A default rule is give for the case that no simplification applies.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define the actual simplication function ",(0,l.kt)("inlineCode",{parentName:"p"},"simplify")," that performs a bottom up traversal of the expression,\napplication simplification rules on the up."))),(0,l.kt)("p",null,"Let\u2019s differentiate the example expression ",(0,l.kt)("inlineCode",{parentName:"p"},"E"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::Derivative;\ndd(E, var("x"));\n')),(0,l.kt)("p",null,"As you can see, we managed to compute a derivative, but the result is far more complex than we would like. This is where\nsimplification comes in. First try a simple case:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'simplify(mul(var("x"), add(con(3), con(5))));\n')),(0,l.kt)("p",null,"Now apply simplification to the result of differentiation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'simplify(dd(E, var("x")));\n')),(0,l.kt)("h3",{id:"string-template"},"String Template"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Using string templates to generate code."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,'Many websites and code generators use template-based code generation. They start from a text template that contains\nembedded variables and code. The template is "executed" by replacing the embedded variables and code by their string\nvalue. Languages like PHP and Ruby are popular for this feature. Let\u2019s see how we can do this in Rascal.'),(0,l.kt)("p",null,"Rascal provides string templates that rival what is provided in\n",(0,l.kt)("a",{parentName:"p",href:"http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/ERB.html"},"Ruby"),", ",(0,l.kt)("a",{parentName:"p",href:"http://www.php.net/"},"PHP")," or\n",(0,l.kt)("a",{parentName:"p",href:"http://www.stringtemplate.org/"},"ANTLR"),". They are fully described in ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#String"},"string values"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The problem we want to solve is as follows: given a number of fields (with a name and a type) how can we generate a Java\nclass with getters and setters for those fields?"),(0,l.kt)("p",null,"Here is a solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::StringTemplate\n\nimport String;\nimport List;\n\n// Capitalize the first character of a string\n\nstr capitalize(str s) { \n  return toUpperCase(substring(s, 0, 1)) + substring(s, 1);\n}\n\n// Helper function to generate a setter\nprivate str genSetter(map[str,str] fields, str x) {\n  return \"public void set<capitalize(x)>(<fields[x]> <x>) {\n         '  this.<x> = <x>;\n         '}\";\n}\n\n// Helper function to generate a getter\nprivate str genGetter(map[str,str] fields, str x) {\n  return \"public <fields[x]> get<capitalize(x)>() {\n         '  return <x>;\n         '}\";\n}\n\n// Generate a class with given name and fields.\n// The field names are processed in sorted order.\nstr genClass(str name, map[str,str] fields) { \n  return\n    \"public class <name> {\n    '  <for (x <- sort([f | f <- fields])) {>\n    '  private <fields[x]> <x>;\n    '  <genSetter(fields, x)>\n    '  <genGetter(fields, x)><}>\n    '}\";\n}\n\nmap[str, str] fields = (\n     \"name\" : \"String\",\n     \"age\" : \"Integer\",\n     \"address\" : \"String\"\n  );\n\nstr cperson =\n  // Do not change a single space in the string below!\n  \"public class Person {\n    '\n    '  private String address;\n    '  public void setAddress(String address) {\n    '    this.address = address;\n    '  }\n    '  public String getAddress() {\n    '    return address;\n    '  }\n    '  private Integer age;\n    '  public void setAge(Integer age) {\n    '    this.age = age;\n    '  }\n    '  public Integer getAge() {\n    '    return age;\n    '  }\n    '  private String name;\n    '  public void setName(String name) {\n    '    this.name = name;\n    '  }\n    '  public String getName() {\n    '    return name;\n    '  }\n    '}\";\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An auxiliary function ",(0,l.kt)("inlineCode",{parentName:"p"},"capitalize")," is defined to capitalize the first character of a string.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Here is the heavy lifting done: ",(0,l.kt)("inlineCode",{parentName:"p"},"genClass")," is defined that takes as arguments:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"the ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," of the class, and")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a map ",(0,l.kt)("inlineCode",{parentName:"p"},"fields")," that associates field names with their type (both string values)."))))),(0,l.kt)("p",null,"Function ",(0,l.kt)("inlineCode",{parentName:"p"},"genClass")," returns a string that contains several ",(0,l.kt)("em",{parentName:"p"},"string interpolations")," delimited by ",(0,l.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,l.kt)("inlineCode",{parentName:"p"},">"),". Let\u2019s\ndiscuss some of them:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In each line, only the text following ",(0,l.kt)("inlineCode",{parentName:"p"},"'")," is contributed to the output. The text before (and including) ",(0,l.kt)("inlineCode",{parentName:"p"},"'")," can be\nused to properly indent the string.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The output of each interpolated call, like to ",(0,l.kt)("inlineCode",{parentName:"p"},"genMethod")," is auto-indented.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"public class <name>"),": insert the desired class name in the result.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"<for x\u2190fields){>")," \u2026\u200b ",(0,l.kt)("inlineCode",{parentName:"p"},"<}>"),": loops over the fields and contributes the text produced by its body to the result.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"private <fields[x]> <x>;"),": finds for the current field ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," its type and produces an appropriate private field\ndeclaration.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"public void set<capitalize(x)>(<fields[x]> <x>)"),": method header for the setter for field ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),"."))),(0,l.kt)("p",null,"Let\u2019s see how this works out on actual data:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::StringTemplate;\nimport IO;\nfields = (\n     "name" : "String",\n     "age" : "Integer",\n     "address" : "String"\n  );\nprintln(genClass("Person", fields));\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"String templates are ideal to generate arbitrary output. In particular, no grammar is needed to describe this\noutput.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Auto-indent helps to be able to compose templates from reusable parts."))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Since no grammar is used to control output, errors in generated code can only be detected by a downstream processor\nsuch as a compiler for the generated code.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In more complex cases, it can be better to introduce an abstract datatype to represent the desired code and to use\nstring templates to produce the actual textual representation of that code."))),(0,l.kt)("h3",{id:"word-count"},"Word Count"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Counting words in strings."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The purpose of WordCount is to count the number of ",(0,l.kt)("em",{parentName:"p"},"words")," in a list of lines (strings). A word is here defined as one\nor more letters (lowercase or uppercase), digits and the underscore character (",(0,l.kt)("inlineCode",{parentName:"p"},"_"),")."),(0,l.kt)("p",null,"We split the problem in two parts:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Count the words in a single line. We explore three ways to do this in an imperative\n(",(0,l.kt)("a",{parentName:"p",href:"#WordCount-CountInLine1"},"CountInLine1"),"]",", ",(0,l.kt)("a",{parentName:"p",href:"#WordCount-CountInLine2"},"CountInLine2"),") and a functional style\n(",(0,l.kt)("a",{parentName:"p",href:"#WordCount-CountInLine3"},"CountInLine3"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Next we apply the single line counter to all the lines."))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"wordCount")," is a function with two arguments: ","*"," A list of lines. ","*"," A function that returns the number of words in a\nline."),(0,l.kt)("p",null,"The main task of ",(0,l.kt)("inlineCode",{parentName:"p"},"wordCount")," is to loop over all lines and to add the word counts per line."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::WordCount::WordCount\n\nimport demo::common::WordCount::CountInLine1;\nimport demo::common::WordCount::CountInLine2;\nimport demo::common::WordCount::CountInLine3;\nimport demo::common::WordCount::Jabberwocky;\n\nimport String;\n\n// wordCount takes a list of strings and a count function\n// that is applied to each line. The total number of words is returned\n\nint wordCount(list[str] input, int (str s) countInLine)\n{\n  count = 0;\n  for(str line <- input){ \n     count += countInLine(line); \n  }\n  return count;\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Enumerator"},"enumerator")," is used to generated all the lines in the list of lines.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The argument function ",(0,l.kt)("inlineCode",{parentName:"p"},"countInLine")," is applied to count the number of words in each line."))),(0,l.kt)("p",null,"Let\u2019s now do some experiments using the ",(0,l.kt)("a",{parentName:"p",href:"#WordCount-Jabberwocky"},"Jabberwocky")," poem by Lewis Carrol as input."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::common::WordCount::WordCount;\nimport demo::common::WordCount::CountInLine1;\nimport demo::common::WordCount::CountInLine2;\nimport demo::common::WordCount::CountInLine3;\nimport demo::common::WordCount::Jabberwocky;\nwordCount(Jabberwocky, countInLine1);\nwordCount(Jabberwocky, countInLine2);\nwordCount(Jabberwocky, countInLine3);\n")),(0,l.kt)("p",null,"It is satisfactory that the three ways of counting words all yield the same result."),(0,l.kt)("p",null,"If you are into one-liners, we can include everything you learned from this example in the following alternative\n",(0,l.kt)("inlineCode",{parentName:"p"},"wordCount2")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int wordCount2(list[str] lines) = (0 | it + (0 | it + 1 | /\\w+/ := line) | str line <- lines);\nwordCount2(Jabberwocky);\n")),(0,l.kt)("p",null,"The function body contains two nested ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Reducer"},"reducers"),". The inner reducer counts the number of\nwords in a line, the outer reducer accumulates all line word counts."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,l.kt)("h3",{id:"countinline1"},"CountInLine1"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Count words in a line."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"We count words using a regular expression match in a for loop. Each time that the pattern ",(0,l.kt)("inlineCode",{parentName:"p"},"/[a-zA-Z0-9_]+/")," matches, the\nbody of the loop is executed and ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," is incremented."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::WordCount::CountInLine1\n\nint countInLine1(str S){\n  int count = 0;\n  for(/docs/[a-zA-Z0-9_]+/ := S){\n       count += 1;\n  }\n  return count;\n}\n")),(0,l.kt)("p",null,"Let\u2019s try it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::WordCount::CountInLine1;\ncountInLine1("Jabberwocky by Lewis Carroll");\n')),(0,l.kt)("h3",{id:"countinline2"},"CountInLine2"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Count words in a line."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"A slighly more involved manner of using regular matching in a loop."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::WordCount::CountInLine2\n\nint countInLine2(str S){\n  int count = 0;\n\n  // \\w matches any word character\n  // \\W matches any non-word character\n  // <...> are groups and should appear at the top level.\n  while (/docs/^\\W*\\w+<rest:.*$>/ := S) {\n    count += 1;\n    S = rest;\n  }\n  return count;\n}\n")),(0,l.kt)("p",null,"The pattern ",(0,l.kt)("inlineCode",{parentName:"p"},"/^\\W*\\w+<rest:.*$>/")," can be understood as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"^")," makes it ",(0,l.kt)("em",{parentName:"p"},"anchored"),", only matches at the begin of the substring ",(0,l.kt)("inlineCode",{parentName:"p"},"S"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"\\W*")," matches zero or more non-word characters.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"\\w+")," matches one or more word characters.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"<rest:.*$>")," matches the remaining part of ",(0,l.kt)("inlineCode",{parentName:"p"},"S")," and assigns the result to the variable ",(0,l.kt)("inlineCode",{parentName:"p"},"rest"),"."))),(0,l.kt)("p",null,"Inside the loop ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," is incremented and the new value of ",(0,l.kt)("inlineCode",{parentName:"p"},"S")," becomes the remainder of the current match. To\nsummarize: each iteration removes the first word from ",(0,l.kt)("inlineCode",{parentName:"p"},"S")," and counts it."),(0,l.kt)("p",null,"Here is ",(0,l.kt)("inlineCode",{parentName:"p"},"countInLine2")," in action:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::WordCount::CountInLine2;\ncountInLine2("Jabberwocky by Lewis Carroll");\n')),(0,l.kt)("h3",{id:"countinline3"},"CountInLine3"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Count words in a line."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is a clever, albeit rather dense, solution that illustrates several Rascal concepts."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::common::WordCount::CountInLine3\n\nint countInLine3(str S){\n  return (0 | it + 1 | /\\w+/ := S);\n}\n")),(0,l.kt)("p",null,"We use a ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Reducer"},"reducer")," that is a recipe to reduce the values produced by one or more generators\nto a single value:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"0")," is the initial value of the reducer")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The pattern match ",(0,l.kt)("inlineCode",{parentName:"p"},"/\\w+/ := S")," matches all words in ",(0,l.kt)("inlineCode",{parentName:"p"},"S"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Reduction is done by ",(0,l.kt)("inlineCode",{parentName:"p"},"it + 1"),". In the latter ",(0,l.kt)("inlineCode",{parentName:"p"},"it")," is a keyword that refers to the value that has been reduced sofar.\nEffectively, the matches are reduced to a match count."))),(0,l.kt)("p",null,"Let\u2019s try it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::WordCount::CountInLine3;\ncountInLine3("Jabberwocky by Lewis Carroll");\n')),(0,l.kt)("h3",{id:"jabberwocky"},"Jabberwocky"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Lewis Carroll\u2019s well-known poem."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::common::WordCount::Jabberwocky\n\npublic list[str] Jabberwocky = [\n    "Jabberwocky by Lewis Carroll",\n    "",\n    "\\\'Twas brillig, and the slithy toves",\n    "Did gyre and gimble in the wabe;",\n    "All mimsy were the borogoves,",\n    "And the mome raths outgrabe.",\n    "",\n    "\\"Beware the Jabberwock, my son!",\n    "The jaws that bite, the claws that catch!",\n    "Beware the Jubjub bird, and shun",\n    "The frumious Bandersnatch!\\"",\n    "",\n    "\\\'Twas brillig, and the slithy toves",\n    "Did gyre and gimble in the wabe;",\n    "All mimsy were the borogoves,",\n    "And the mome raths outgrabe.",\n    "",\n    "\\"Beware the Jabberwock, my son!",\n    "The jaws that bite, the claws that catch!",\n    "Beware the Jubjub bird, and shun",\n    "The frumious Bandersnatch!\\"",\n    "",\n    "He took his vorpal sword in hand:",\n    "Long time the manxome foe he sought.",\n    "So rested he by the Tumtum tree,",\n    "And stood awhile in thought.",\n    "",\n    "And as in uffish thought he stood,",\n    "The Jabberwock, with eyes of flame,",\n    "Came whiffling through the tulgey wood",\n    "And burbled as it came!",\n    "",\n    "One, two! One, two! and through and through",\n    "The vorpal blade went snicker-snack!",\n    "He left it dead, and with its head",\n    "He went galumphing back.",\n    "",\n    "\\"And hast thou slain the Jabberwock?",\n    "Come to my arms, my beamish boy!",\n    "O frabjous day! Callooh! Callay!",\n    "He chortled in his joy.",\n    "",\n    "\\\'Twas brillig, and the slithy toves",\n    "Did gyre and gimble in the wabe;",\n    "All mimsy were the borogoves,",\n    "And the mome raths outgrabe."\n];\n')),(0,l.kt)("h3",{id:"word-replacement"},"Word Replacement"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Replace words in a string."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Suppose you are a book editor and want to ensure that all chapter and section titles are properly capitalized. Here is\nhow to do this."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::common::WordReplacement\n\nimport String;\n\n// capitalize: convert first letter of a word to uppercase\n\nstr capitalize(str word) \n{\n   if(/docs/^<letter:[a-z]><rest:.*$>/ := word){\n     return toUpperCase(letter) + rest;\n   } else {\n     return word;\n   }\n}\n\ntest bool capitalize1() = capitalize("1") == "1";\ntest bool capitalize2() = capitalize("rascal") == "Rascal";\n\n// Capitalize all words in a string\n\n// Version 1: capAll1: using a while loop\n\nstr capAll1(str S) \n{\n result = "";\n while (/docs/^<before:\\W*><word:\\w+><after:.*$>/ := S) {\n    result = result + before + capitalize(word);\n    S = after;\n  }\n  return result;\n}\n\ntest bool tstCapAll1() =  capAll1("turn this into a title") == "Turn This Into A Title";\n\n// Version 2: capAll2: using visit\n\nstr capAll2(str S) \n{\n   return visit(S){\n    case /^<word:\\w+>/i => capitalize(word)\n   };\n}\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We start by introducing a helper function ",(0,l.kt)("inlineCode",{parentName:"p"},"capitalize")," that does the actual capitalization of a single word. See\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Regular"},"Regular Pattern")," for details about regular expression patterns. Next we give two versions\nof a capitalization functions for a sentence:")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"capAll1")," uses a while loop to find subsequent words and to replace them by a capitalized version.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"capAll2")," uses a ","[","Rascal:Visit","]"," to visit all words in the sentence and replace them by a capitalized version."))),(0,l.kt)("p",null,"Here are some examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::common::WordReplacement;\ncapitalize("rascal");\ncapAll1("turn this into a capitalized title")\ncapAll2("turn this into a capitalized title")\n')),(0,l.kt)("h2",{id:"languages"},"Languages"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Definitions of several languages and their tools."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Examples of several languages and the implementation of tools like interpreters and compilers:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Languages-Exp"},"Exp"),": The ",(0,l.kt)("em",{parentName:"p"},"hello world")," of syntax definition and language definition."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Exp-Abstract"},"Abstract"),": A version of Exp based on abstract syntax.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Exp-Combined"},"Combined"),": Combine concrete syntax with abstract syntax.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Exp-Concrete"},"Concrete"),": Various versions of Exp based on concrete syntax.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Languages-Func"},"Func"),": Func is a tiny functional language; we present several interpreters for it."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-AbstractSyntax"},"Abstract Syntax"),": The abstract syntax for Func.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-ConcreteSyntax"},"Concrete Syntax"),": The concrete syntax of Func.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-Eval0"},"Eval0"),": A Func interpreter that does not support let-expressions and pointers.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-Eval1"},"Eval1"),": Like Eval0 but with support for let-expressions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-Eval2"},"Eval2"),": Like Eval1 but with support for sequences and assignments.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-Eval3"},"Eval3"),": A complete Func interpreter including support for the address and dereference operators.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-LoadAST"},"Load AST"),": Parse Func program from string or file and convert to an abstract syntax tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Func-Parse"},"Parse"),": Parse a Func program from a string or a file.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Languages-Lisra"},"Lisra"),": A lisp interpreter in Rascal."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Eval"},"Eval"),": A Lisp interpreter.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Parse"},"Parse"),": Parsing a Lisp expression.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Pretty"},"Pretty"),": A Lisp pretty printer.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Runtime"},"Runtime"),": The runtime representation of Lisp programs and data.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Syntax"},"Syntax"),": The textual syntax of Lisp.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Test"},"Test"),": Tests for the Lisp interpreter.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Languages-Pico"},"Pico"),": The classical toy language, including a specialized IDE."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Abstract"},"Abstract"),": Abstract syntax for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Assembly"},"Assembly"),": Assembly language for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Compile"},"Compile"),": Compile a Pico program to assembly language.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-ControlFlow"},"ControlFlow"),": Compute the control flow graph for a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Evaluate"},"Evaluate"),": Evaluate a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-IDE"},"IDE"),": An Integrated Development Environment for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Load"},"Load"),": Convert a Pico parse tree into a Pico abstract syntax tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Syntax"},"Syntax"),": Concrete syntax for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Typecheck"},"Typecheck"),": Typechecker for Pico programs.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Uninit"},"Uninit"),": Find unitialized variables in a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-UseDef"},"UseDef"),": Compute use-def information for the variables in a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Visualize"},"Visualize"),": Visualize Pico Control Flow Graphs."))))),(0,l.kt)("p",null,"Other languages that we are considering (but are not yet described):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Oberon0: a scaled down version of the Oberon language.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"MissGrant: a state machine language."))),(0,l.kt)("h3",{id:"exp"},"Exp"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"hello world")," of syntax definition and language definition. It illustrates how to define concrete and abstract\nsyntax and how to use concrete and abstract patterns to evaluate expressions."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Our sample language Exp contains the following elements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Integer constants, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"123"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A multiplication operator, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"3*4"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An addition operator, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"3+4"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Multiplication is left-associative and has precedence over addition.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Addition is left-associative.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Parentheses can be used to override the precedence of the operators."))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"123"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"2+3+4"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"2+3*4"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"(2+3)*4")))),(0,l.kt)("h3",{id:"abstract"},"Abstract"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A version of Exp based on abstract syntax."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Abstract_syntax"},"abstract syntax")," for a language is a data type that is used to\nrepresent programs in the language in an ",(0,l.kt)("em",{parentName:"p"},"abstract")," form. Abstract syntax has the following properties:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'It is "abstract" in the sense that it does not contain textual details such as parentheses, layout, and the like.')),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"While a language has one grammar (also known as, ",(0,l.kt)("em",{parentName:"p"},"concrete syntax"),") it may have several abstract syntaxes for\ndifferent purposes: type analysis, code generation, etc."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The abstract syntax for Exp looks like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Abstract::Syntax\n\ndata Exp = con(int n)          \n         | mul(Exp e1, Exp e2) \n         | add(Exp e1, Exp e2) \n         ;\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines integer constants, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"con(123)"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines multiplication, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"mul(con(2),con(3))"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines addition, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"add(con(2),con(3))"),"."))),(0,l.kt)("p",null,"Given the abstract syntax for Exp, we can define an interpreter that evaluates expressions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Abstract::Eval\nimport demo::lang::Exp::Abstract::Syntax;\n\nint eval(con(int n)) = n;                            \nint eval(mul(Exp e1, Exp e2)) = eval(e1) * eval(e2); \nint eval(add(Exp e1, Exp e2)) = eval(e1) + eval(e2); \n")),(0,l.kt)("p",null,"Here we see Rascal\u2019s ",(0,l.kt)("em",{parentName:"p"},"pattern-directed invocation")," in action (see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#Function"},"Function\nDeclaration"),"). The essence is this: in other languages the formal parameters in a\nfunction declaration are just that: formal parameters, i.e., single names that can be used inside the function and that\nare bound when the function is called. In Rascal, however, the formal parameters are actually a ",(0,l.kt)("em",{parentName:"p"},"pattern")," and functions\ncan have arbitrarily complex patterns as (single) formal parameter. These patterns may bind variables and thus introduce\nvariables that can be used in tthe function body."),(0,l.kt)("p",null,"The big advantage of pattern-directed invocation is modularity and extensibility:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The treatment of the cases in the abstract syntax is decoupled.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If the abstract is extended later on with new cases, the functions for the old cases can be reused."))),(0,l.kt)("p",null,"In this example we use this mechanism to define separate functions for each case in the abstract syntax."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines the case for evaluating integer constants: they evaluate to themselves.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines the case for evaluating multiplication: first evaluate the arguments ",(0,l.kt)("inlineCode",{parentName:"p"},"e1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"e2")," and return the\nmultiplication of their values.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines the case for evaluating addition: first evaluate the arguments ",(0,l.kt)("inlineCode",{parentName:"p"},"e1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"e2")," and return the addition of\ntheir values."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::lang::Exp::Abstract::Syntax;\nimport demo::lang::Exp::Abstract::Eval;\neval(mul(con(7), con(3)));\neval(add(con(3), mul(con(4), con(5))));\n")),(0,l.kt)("p",null,"Entering expressions in abstract syntax form is no fun, and this is where concrete syntax comes to the rescue."),(0,l.kt)("h3",{id:"combined"},"Combined"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Combine concrete syntax with abstract syntax."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Concrete syntax gives full control over the textual appearance of a language and leads to parse trees in a standard\nformat (i.e., values of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Tree"),")."),(0,l.kt)("p",null,"Abstract syntax can be designed by the Rascal programmer according to his/her needs regarding the type checking, code\ngeneration, transformation, or optimization to be done on the abstract syntax trees."),(0,l.kt)("p",null,"How can we bridge this gap? We discuss two approaches:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Combined-Manual"},"Manual"),": a transformation is written manually to convert parse trees to abstract syntax trees.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Combined-Automatic"},"Automatic"),": the library function ","[","Rascal:implode","]"," is used to automate this transformation."))),(0,l.kt)("h5",{id:"automatic"},"Automatic"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Use implode to translate an Exp parse tree to an abstract syntax tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#implode"},"implode")," is a function that automates the mapping between parse trees and abstract syntax\ntrees. It takes two arguments:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("em",{parentName:"p"},"reified")," type of the desired abstract syntax. (In Rascal, types can not be used freely as values. A reified\ntype, is a type that is wrapped in such a way that it can be passed as an argument to a function.)")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The parse tree to be converted."))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"implode")," is smart in trying to find a mapping, but it needs some guidance. A necessary step is therefore to label the\nrules in the grammar with the name of the constructor to which it has to be mapped."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Let\u2019s first label the syntax rules of the Exp grammar with constructor names:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Combined::Automatic::Syntax\n\nlexical LAYOUT = [\\t-\\n\\r\\ ];\n\nlayout LAYOUTLIST = LAYOUT*  !>> [\\t-\\n\\r\\ ] ;\n\nlexical IntegerLiteral = [0-9]+;\n\nstart syntax Exp =\n                   con: IntegerLiteral   \n                 | bracket "(" Exp ")"\n                 > left mul: Exp "*" Exp \n                 > left add: Exp "+" Exp \n                 ;\n')),(0,l.kt)("p",null,"Observe that at ",(0,l.kt)("img",{alt:"1",src:n(3875).Z,width:"12",height:"12"})," these labels have been added."),(0,l.kt)("p",null,"It is good practice to introduce separate modules for parsing and for the conversion itself:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Parse")," module defines a parse function and returns a parse tree. It imports only the concrete syntax.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Load")," module defines a load function that first calls the above ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," function and then applies ",(0,l.kt)("inlineCode",{parentName:"p"},"implode")," to\nit. This is the only module that imports both concrete and abstract syntax at the same time and is therefore the\nonly place to be concerned about name clashes. (If I mention ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp"),", do you know which one I mean?)."))),(0,l.kt)("p",null,"Here is the ",(0,l.kt)("inlineCode",{parentName:"p"},"Parse")," module for Exp \u2026\u200b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Combined::Automatic::Parse\n\nimport demo::lang::Exp::Combined::Automatic::Syntax;\nimport ParseTree;\n\nTree parseExp(str txt) = parse(#Exp, txt);\n")),(0,l.kt)("p",null,"and this is how it works:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Combined::Automatic::Parse;\nparseExp("2+3*4");\n')),(0,l.kt)("p",null,"We can use ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," to define ",(0,l.kt)("inlineCode",{parentName:"p"},"load"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Combined::Automatic::Load\n\nimport demo::lang::Exp::Combined::Automatic::Parse; \nimport demo::lang::Exp::Abstract::Syntax; \nimport ParseTree; \n\nExp load(str txt) = implode(#Exp, parseExp(txt));\n")),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We also need the ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," function, as defined above.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We also need the abstract syntax as already defined earlier in ","[","Exp/Abstract","]",".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We need ","[","Rascal:ParseTree","]"," since it provides the ","[","Rascal:implode","]"," function."))),(0,l.kt)("p",null,"Let\u2019s try it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Combined::Automatic::Load;\nload("2+3*4");\n')),(0,l.kt)("p",null,"Remains the definition of the ",(0,l.kt)("inlineCode",{parentName:"p"},"eval")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Combined::Automatic::Eval\n\nimport demo::lang::Exp::Abstract::Eval;\nimport demo::lang::Exp::Combined::Automatic::Load;\n\nint eval(str txt) = eval(load(txt));\n")),(0,l.kt)("p",null,"Here is the end result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Combined::Automatic::Eval;\neval("2+3*4");\n')),(0,l.kt)("h5",{id:"manual"},"Manual"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"An Exp evaluator that uses a manually written conversion from parse tree to abstract syntax tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"First we define a ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," function for Exp:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Combined::Manual::Parse\nimport demo::lang::Exp::Concrete::WithLayout::Syntax;\nimport ParseTree;\n\ndemo::lang::Exp::Concrete::WithLayout::Syntax::Exp\n parseExp(str txt) = parse(#Exp, txt);\n")),(0,l.kt)("p",null,"and test it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Combined::Manual::Parse;\nparseExp("2+3");\n')),(0,l.kt)("p",null,"Next, we define a ",(0,l.kt)("inlineCode",{parentName:"p"},"load")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Combined::Manual::Load\n\nimport demo::lang::Exp::Concrete::WithLayout::Syntax; \nimport demo::lang::Exp::Abstract::Syntax; \nimport demo::lang::Exp::Combined::Manual::Parse; \nimport String;\n\ndemo::lang::Exp::Abstract::Syntax::Exp loadExp(str txt) = load(parseExp(txt)); \n\ndemo::lang::Exp::Abstract::Syntax::Exp load((Exp)`<IntegerLiteral l>`) \n       = con(toInt("<l>"));\ndemo::lang::Exp::Abstract::Syntax::Exp load((Exp)`<Exp e1> * <Exp e2>`)\n       = mul(load(e1), load(e2));\ndemo::lang::Exp::Abstract::Syntax::Exp load((Exp)`<Exp e1> + <Exp e2>`)\n       = add(load(e1), load(e2));\ndemo::lang::Exp::Abstract::Syntax::Exp load((Exp)`( <Exp e> )`)\n       = load(e);\n')),(0,l.kt)("p",null,"Some comments:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We reuse the previously defined concrete syntax with layout.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We also reuse the previously defined abstract syntax.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Import the ",(0,l.kt)("inlineCode",{parentName:"p"},"Parse")," module defined above.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The top level ",(0,l.kt)("inlineCode",{parentName:"p"},"load")," function that converts a string to an abstract syntax tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The conversion from parse tree to abstract syntax tree start here. Note that we explicitly use\n",(0,l.kt)("inlineCode",{parentName:"p"},"demo::lang::Exp::Abstract::Syntax::Exp")," in these rules to distinguish from\n",(0,l.kt)("inlineCode",{parentName:"p"},"demo::lang::Exp::Concrete::WithLayout::Syntax::Exp"),"."))),(0,l.kt)("p",null,"Let\u2019s try it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Combined::Manual::Load;\nloadExp("2+3");\n')),(0,l.kt)("p",null,"What remains is to write the interpreter using the above components:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Exp::Combined::Manual::Eval\n\nimport demo::lang::Exp::Abstract::Eval;\nimport demo::lang::Exp::Combined::Manual::Load;\n\npublic int eval(str txt) = eval(loadExp(txt));\n")),(0,l.kt)("p",null,"Here is how it works:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Combined::Manual::Eval;\neval("2+3");\n')),(0,l.kt)("h3",{id:"concrete"},"Concrete"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Various versions of Exp based on concrete syntax."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"We discuss several versions of Exp based on concrete syntax:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Concrete-NoLayout"},"No Layout"),": is the simplest version that does not consider layout symbols in expressions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Concrete-WithLayout"},"With Layout"),": adds layout information to Exp\u2019s synax definition."))),(0,l.kt)("h5",{id:"no-layout"},"No Layout"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A version of Exp based on concrete syntax."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"We describe howto write a grammar for Exp and how to use it to implement an evaluator."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is the grammar for Exp:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Concrete::NoLayout::Syntax\n\nlexical IntegerLiteral = [0-9]+; \n\nstart syntax Exp        \n  = IntegerLiteral      \n  | bracket "(" Exp ")" \n  > left Exp "*" Exp    \n  > left Exp "+" Exp    \n  ;\n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines a lexical syntax rule for IntegerLiterals; they consist of one or more digits.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines the alternatives for Exp. The keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"start")," means that this is a start symbol of the grammar.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines alternative ","#","1: an ",(0,l.kt)("inlineCode",{parentName:"p"},"IntegerLiteral"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines alternative ","#","2: parentheses. The ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," says that this alternative has the same priority as the previous one.\nThe keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"bracket")," marks this as an alternative that defines parentheses.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines alternative ","#","3: multiplication. The ",(0,l.kt)("inlineCode",{parentName:"p"},">")," says that the previous rule has a higher priority than the current\none. The keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"left")," marks this as a left-associative rule.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Defines alternative ","#","4: addition. The ",(0,l.kt)("inlineCode",{parentName:"p"},">")," says again that the previous rule has a higher priority than the current\none. The keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"left")," marks this as a left-associative rule."))),(0,l.kt)("p",null,"Now that the grammar is in place we want to use it to build an evaluator. Here is how:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Concrete::NoLayout::Eval\nimport demo::lang::Exp::Concrete::NoLayout::Syntax;\n\nimport String;\nimport ParseTree; \n\nint eval(str txt) = eval(parse(#Exp, txt)); \n\nint eval((Exp)`<IntegerLiteral l>`) = toInt("<l>");       \nint eval((Exp)`<Exp e1>*<Exp e2>`) = eval(e1) * eval(e2); \nint eval((Exp)`<Exp e1>+<Exp e2>`) = eval(e1) + eval(e2); \nint eval((Exp)`(<Exp e>)`) = eval(e);                     \n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We import ","[","Rascal:ParseTree","]"," because we will need the ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," function below.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The main function ",(0,l.kt)("inlineCode",{parentName:"p"},"eval")," that evaluates an expression as string to an integer. It proceeds in two steps:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"parse(#Exp, txt)")," parses the given ",(0,l.kt)("inlineCode",{parentName:"p"},"txt")," according to non-terminal ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp")," as defined by the grammar. The result\nis a parse tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"This parse tree is given to another eval function that will reduce the tree to an integer.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Converts an IntegerLiteral to an integer. Let\u2019s dissect this further:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp")," preceding the concrete pattern, unambiguously defines the type of the pattern. This is good practice\nto avoid ambiguities.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"<IntegerLiteral l>")," matches an IntegerLiteral and binds it (a parse tree fragment) to variable ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In the function body, ",(0,l.kt)("inlineCode",{parentName:"p"},'toInt("<l>")'),", the parse tree fragment is inserted in a string\u2009\u2014\u2009effectively unparsing\nit\u2009\u2014\u2009and that string is converted to an integer.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Handle the multiplication case.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Handle the addition case.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Handles the case of parentheses."))),(0,l.kt)("p",null,"What remains, is to check that ",(0,l.kt)("inlineCode",{parentName:"p"},"eval")," works as expected."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::lang::Exp::Concrete::NoLayout::Syntax;\nimport ParseTree;\n")),(0,l.kt)("p",null,"Just checking that ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," returns a sort of parse tree:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'parse(#Exp, "2+3");\n')),(0,l.kt)("p",null,"You will see such parse trees only once, unless you are a researcher in parsing ;-) Here is a demonstration of ",(0,l.kt)("inlineCode",{parentName:"p"},"eval"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Concrete::NoLayout::Eval;\neval("2+3");\neval("2+3*4");\neval("(2+3)*4");\n')),(0,l.kt)("h5",{id:"with-layout"},"With Layout"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Defines a concrete syntax for Exp with layout."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"In Rascal, the major difference between lexical syntax and non-lexical syntax is that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Strings that are parsed according to the lexical syntax ",(0,l.kt)("em",{parentName:"p"},"do not")," contain additional layout characters such as\nspaces, new lines, and source code comments.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Strings that are parsed according to the normal (non-lexical) syntax ",(0,l.kt)("em",{parentName:"p"},"can")," contain layout characters between each\nelement.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Which 'layout' (whitespace and/or source code comments) will be accepted has to be defined explicitly by the grammar\nwriter."))),(0,l.kt)("p",null,"The following example extends the grammar for ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp")," in ",(0,l.kt)("a",{parentName:"p",href:"#Concrete-NoLayout"},"No Layout")," with a layout definition:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Concrete::WithLayout::Syntax\n\nlayout Whitespace = [\\t-\\n\\r\\ ]*; \n\nlexical IntegerLiteral = [0-9]+;\n\nstart syntax Exp\n  = IntegerLiteral\n  | bracket "(" Exp ")"\n  > left Exp "*" Exp\n  > left Exp "+" Exp\n  ;\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Using the ",(0,l.kt)("inlineCode",{parentName:"li"},"layout")," definition, we define that the ",(0,l.kt)("inlineCode",{parentName:"li"},"Whitespace")," non-terminal is used ",(0,l.kt)("em",{parentName:"li"},"in between every symbol")," of the\n",(0,l.kt)("inlineCode",{parentName:"li"},"syntax")," productions in the current module.")),(0,l.kt)("p",null,"And now we can use spaces in our definition of the eval function as well:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Concrete::WithLayout::Eval\nimport demo::lang::Exp::Concrete::WithLayout::Syntax;\n\nimport String;\nimport ParseTree;\n\nint eval(str txt) = eval(parse(#start[Exp], txt).top);\n\nint eval((Exp)`<IntegerLiteral l>`) = toInt("<l>");\nint eval((Exp)`<Exp e1> * <Exp e2>`) = eval(e1) * eval(e2);\nint eval((Exp)`<Exp e1> + <Exp e2>`) = eval(e1) + eval(e2);\nint eval((Exp)`( <Exp e> )`) = eval(e);\n')),(0,l.kt)("p",null,"Note that ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#PatternMatching"},"Pattern Matching")," will ",(0,l.kt)("em",{parentName:"p"},"ignore"),' all trees in layout positions, such that\nthe parse tree of "1 + ',"\\","\\",'n1" will match against ',(0,l.kt)("inlineCode",{parentName:"p"},"<Exp e1> + <Exp e2>"),". The same goes for equality on parse trees."),(0,l.kt)("p",null,"For the above example Rascal will insert the ",(0,l.kt)("inlineCode",{parentName:"p"},"Whitespace")," non-terminal between every element of the syntax rules for\n",(0,l.kt)("inlineCode",{parentName:"p"},"Exp"),". Moreover, for the start production (See ",(0,l.kt)("a",{parentName:"p",href:"#Concrete-NoLayout"},"No Layout"),") ",(0,l.kt)("inlineCode",{parentName:"p"},"Whitespace")," will be added before and\nafter the ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp"),"."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The effect of the layout definition is that before parser generation the following grammar is derived for ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Exp\n  = IntegerLiteral\n  | bracket "(" Whitespace Exp Whitespace ")"\n  > left Exp Whitespace "*" Whitespace Exp\n  > left Exp Whitespace "+" Whitespace Exp\n  ;\n\nsyntax start[Exp] = Whitespace Exp top Whitespace;\n')),(0,l.kt)("p",null,"To put this all to the test:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Concrete::WithLayout::Syntax;\nimport demo::lang::Exp::Concrete::WithLayout::Eval;\neval("2 +  3");\neval("2   +  3*4");\neval("( 2+3 )* 4");\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the grammar for ",(0,l.kt)("inlineCode",{parentName:"li"},"Exp")," would contain an optional symbol, as in ",(0,l.kt)("inlineCode",{parentName:"li"},'syntax Exp = Exp "+"? Exp'),', then it would be\nambiguous. Does a space in "1 1", belong to the ',(0,l.kt)("inlineCode",{parentName:"li"},"Whitespace")," before or after the missing ",(0,l.kt)("inlineCode",{parentName:"li"},"+"),"? To disambiguate the\n",(0,l.kt)("inlineCode",{parentName:"li"},"layout")," definition should be changed to ",(0,l.kt)("inlineCode",{parentName:"li"},"layout Whitespace = [\\ \\t\\n\\r]* !>> [\\ \\t\\n\\r]"),". That will make sure the\nspace goes with the first Whitespace, because even an empty Whitespace list must never be followed immediately by a\nspace.")),(0,l.kt)("h3",{id:"func"},"Func"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Func is a tiny functional language; we present several interpreters for it."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Func is a functional language with the following features:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A program consists of a number of function declarations.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A function declaration consists of a name, zero or more formal parameter names and an expression.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An expression can be one of:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"an integer constant.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a variable.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"arithmetic operators ",(0,l.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"*")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"/"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"comparison operators ",(0,l.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,l.kt)("inlineCode",{parentName:"p"},">")," and ",(0,l.kt)("inlineCode",{parentName:"p"},">="),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a call of a function.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"an ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," expression.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a sequence of expressions (",(0,l.kt)("inlineCode",{parentName:"p"},";"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"an assignment (",(0,l.kt)("inlineCode",{parentName:"p"},":="),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," expression to introduce new bindings for local variables.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"an address of a variables (denoted by ",(0,l.kt)("inlineCode",{parentName:"p"},"&"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"derefence of a variable (denoted by ",(0,l.kt)("inlineCode",{parentName:"p"},"*"),")."))))),(0,l.kt)("p",null,"Some features add more complexity to an interpreter, therefore we present four interpreters ",(0,l.kt)("a",{parentName:"p",href:"#Func-Eval0"},"Eval0"),",\n",(0,l.kt)("a",{parentName:"p",href:"#Func-Eval1"},"Eval1"),", ",(0,l.kt)("a",{parentName:"p",href:"#Func-Eval2"},"Eval2")," and ",(0,l.kt)("a",{parentName:"p",href:"#Func-Eval2"},"Eval2")," that implement increasingly complex features:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval0"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval1"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval2"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval3"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"function declaration"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"integer constant"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"comparison operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"call"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"let"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sequence"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"assignment"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"address operator"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dereference operator"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"y")))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here are several versions of the factorial function that use more and more features of the Func language:"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"F0.func"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             1\n          else\n             n * fact(n-1)\n          end\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"F1.func"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = let\n            x = n\n          in\n            if x <= 1 then\n               x\n            else\n               x * fact(x-1)\n            end\n          end\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"F2.func"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             n := 1\n          else\n             n := n * fact(n-1)\n          end;\n          n\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"F3.func"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"swap(a, b) =\n          let\n            temp = *a\n          in\n            *a := *b;\n            *b := temp\n          end\n\nfact(n) = let\n            x = 1,\n            y = 0\n          in\n            if n <= 1 then\n               x := 1\n            else\n               x := n * fact(n-1)\n            end;\n            swap(&x, &y);\n            y\n          end\n")),(0,l.kt)("p",null,"For convenience, we use two versions of these examples for each ",(0,l.kt)("em",{parentName:"p"},"F"),(0,l.kt)("sub",null,"i"),":"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A file ",(0,l.kt)("em",{parentName:"p"},"F",(0,l.kt)("sub",null,"i")),"`",".func","`"," that contains the code as shown above.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A file ",(0,l.kt)("em",{parentName:"p"},"F",(0,l.kt)("sub",null,"i")),"`",".rsc","`"," a Rascal file that declares a string variable ",(0,l.kt)("em",{parentName:"p"},"F",(0,l.kt)("sub",null,"i"))," with the same content."))),(0,l.kt)("p",null,"For instance, ",(0,l.kt)("inlineCode",{parentName:"p"},"F0.rsc")," looks like this"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Func::programs::F0\n\npublic str F0 =\n"fact(n) = if n \\<= 1 then\n             1\n          else\n             n * fact(n-1)\n          end";\n')),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},"Note")),(0,l.kt)("p",{parentName:"blockquote"},"Note the escaped ",(0,l.kt)("inlineCode",{parentName:"p"},"<")," character in ",(0,l.kt)("inlineCode",{parentName:"p"},"\\<="),". This is necessary since ",(0,l.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,l.kt)("inlineCode",{parentName:"p"},">")," are used in strings to enclose\ninterpolations (insertion of the value of a Rascal expression). Both symbols need to be escaped when used as literal\nsymbol and not as interpolation.")),(0,l.kt)("h3",{id:"abstract-syntax"},"Abstract Syntax"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"The abstract syntax for Func."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is the abstract syntax for Func:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::AST\n\ndata Prog = prog(list[Func] funcs);\ndata Func = func(str name, list[str] formals, Exp body);\n\ndata Exp = let(list[Binding] bindings, Exp exp)\n         | cond(Exp cond, Exp then, Exp otherwise)\n         | var(str name)\n         | nat(int nat)\n         | call(str name, list[Exp] args)\n\n         | address(str var)\n         | deref(Exp exp)\n\n         | mul(Exp lhs, Exp rhs)\n         | div(Exp lhs, Exp rhs)\n         | add(Exp lhs, Exp rhs)\n         | sub(Exp lhs, Exp rhs)\n         | gt(Exp lhs, Exp rhs)\n         | lt(Exp lhs, Exp rhs)\n         | geq(Exp lhs, Exp rhs)\n         | leq(Exp lhs, Exp rhs)\n\n         | seq(Exp lhs, Exp rhs)\n         | assign(Exp lhs, Exp rhs);\n\ndata Binding = binding(str var, Exp exp);\n")),(0,l.kt)("p",null,"Observe that the abstract syntax follows the structure of the ",(0,l.kt)("a",{parentName:"p",href:"#Func-ConcreteSyntax"},"Concrete Syntax")," but omits details\nsuch as operator priorities, parentheses, and the like."),(0,l.kt)("h3",{id:"concrete-syntax"},"Concrete Syntax"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"The concrete syntax of Func."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Func::Func\n\nlexical Ident =  [a-zA-Z][a-zA-Z0-9]* !>> [a-zA-Z0-9];\n\nlexical Natural = [0-9]+ !>> [0-9];\n\nlexical LAYOUT = [\\t-\\n\\r\\ ];\n\nlayout LAYOUTLIST = LAYOUT*  !>> [\\t-\\n\\r\\ ] ;\n\nstart syntax Prog = prog: Func* ;\n\nsyntax Func = func: Ident name "(" {Ident ","}* ")" "=" Exp;\n\nsyntax Exp = let: "let" {Binding ","}* "in" Exp "end"\n           | cond: "if" Exp "then" Exp "else" Exp "end"\n           | bracket "(" Exp ")"\n           | var: Ident\n           | nat: Natural\n           | call: Ident "(" {Exp ","}* ")"\n           | address: "&" Ident\n           > deref: "*" Exp\n           > non-assoc (\n               left mul: Exp "*" Exp\n             | non-assoc div: Exp "/" Exp\n           )\n           > left (\n               left add: Exp "+" Exp\n             | left sub: Exp "-" Exp\n           )\n           >\n           non-assoc (\n               non-assoc gt: Exp "\\>" Exp\n             | non-assoc lt:  Exp "\\<" Exp\n             | non-assoc geq:  Exp "\\>=" Exp\n             | non-assoc leq:  Exp "\\<=" Exp\n           )\n           >\n           right assign: Exp ":=" Exp\n           >\n           right seq: Exp ";" Exp;\n\nsyntax Binding = binding: Ident "=" Exp;\n')),(0,l.kt)("p",null,"The concrete syntax of Func uses many features of Rascal\u2019s syntax definitions. Some notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The definition of lexical syntax follows the pattern:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define lexical symbols (",(0,l.kt)("inlineCode",{parentName:"p"},"Ident"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Natural"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define rules for layout.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Use follow restrictions (",(0,l.kt)("inlineCode",{parentName:"p"},"!>>"),") to enforce the longest match of lexical symbols.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The definition of lexical also follows a common pattern:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"List of non-terminal is defined with their alternatives.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"One non-terminal is designated as start symbol (",(0,l.kt)("inlineCode",{parentName:"p"},"Prog"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Each alternative has a label, this is for the benefit of converting parse trees to abstract syntaxt trees.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Each alternative spells out its priority and associativity."))))),(0,l.kt)("h3",{id:"eval0"},"Eval0"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A Func interpreter that does not support let-expressions and pointers."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Interpreter Eval0 supports the following features of Func:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval0"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"function declaration"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"integer constant"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"comparison operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"call"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"let"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sequence"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"assignment"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"address operator"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dereference operator"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is the code for Eval0:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Eval0\n\n// No let\n\nimport demo::lang::Func::AST;\nimport List;\n\nalias PEnv = map[str, Func]; \n\nvalue eval0(str main, list[int] args, Prog prog) { \n  penv = ( f.name: f | f <- prog.funcs );\n  f = penv[main];\n  return eval0(subst(f.body, f.formals, args), penv);\n}\n\n\nExp subst(Exp exp, list[str] vars, list[int] values) { \n  env = ( vars[i]: values[i] | i <- index(vars) );\n  return visit (exp) {\n    case var(str name) => nat(env[name])\n  };\n}\n\nint eval0(nat(int nat), PEnv penv)  = nat; \n\nint eval0(mul(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) * eval0(rhs, penv);\n\nint eval0(div(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) / eval0(rhs, penv);\n\nint eval0(add(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) + eval0(rhs, penv);\n\nint eval0(sub(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) - eval0(rhs, penv);\n\nint eval0(gt(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) > eval0(rhs, penv) ? 1 : 0;\n\nint eval0(lt(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) < eval0(rhs, penv) ? 1 : 0;\n\nint eval0(geq(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) >= eval0(rhs, penv) ? 1 : 0;\n\nint eval0(leq(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) <= eval0(rhs, penv) ? 1 : 0;\n\nint eval0(cond(Exp cond, Exp then, Exp otherwise), PEnv penv) =  \n    (eval0(cond, penv) != 0) ? eval0(then, penv) : eval0(otherwise, penv);\n\nint eval0(call(str name, list[Exp] args), PEnv penv) =  \n    eval0(subst(penv[name].body, penv[name].formals, [ eval0(a, penv) | a <- args]), penv);\n")),(0,l.kt)("p",null,"Some points to note:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"PEnv")," is used as an alias for a map from names to functions. Such maps are used to represent the function\ndefinitions in the program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Here the top level interpreter ",(0,l.kt)("inlineCode",{parentName:"p"},"eval0")," is defined. It takes the name of the main function, a list of actual\nparameters, and the complete Func program. Binding of variables is done by substitution.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The substitution function is defined. It takes an expression, a list of variables, and a list of integer values to\nbe substituted for them. Note how a ","[","Rascal:Visit","]"," is used to find all the variables in the expression and to\nreplace them.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The versions of ",(0,l.kt)("inlineCode",{parentName:"p"},"eval0")," for each implemented construct. They all have a ",(0,l.kt)("inlineCode",{parentName:"p"},"PEnv")," argument that is needed to resolve\ncalls.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The if expression is defined: the then-branch is taken when the test evaluates to a non-zero integer.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The call expression is interpreted. It contains the following steps:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The actual parameters are evaluated.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A substitution is made in the body of the called function, replacing formal parameters by actual values.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The result of this substitution is evaluated."))))),(0,l.kt)("p",null,"Let\u2019s try this on example ",(0,l.kt)("inlineCode",{parentName:"p"},"F0"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             1\n          else\n             n * fact(n-1)\n          end\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Func::Load;\nimport demo::lang::Func::Eval0;\nimport demo::lang::Func::programs::F0;\neval0("fact", [10], load(F0));\n')),(0,l.kt)("h3",{id:"eval1"},"Eval1"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Like Eval0 but with support for let-expressions."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Interpreter Eval1 supports the following features of Func:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval1"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"function declaration"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"integer constant"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"comparison operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"call"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"let")),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sequence"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"assignment"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"address operator"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dereference operator"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("p",null,"In particular, the let construct is supported and this requires the addition of an extra environment for \\<name, value",">","\nbindings."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Eval1\n\n// using env, allowing let\n\nimport demo::lang::Func::AST;\n\nimport List;\n\nalias Env = map[str, int];  \nalias PEnv = map[str, Func];\n\nint eval1(str main, list[int] args, Prog prog) {\n  penv = ( f.name: f | f <- prog.funcs );\n  f = penv[main];\n  env = ( f.formals[i] : args[i] | i <- index(f.formals) );\n  return eval1(f.body, env, penv);\n}\n\n\nint eval1(nat(int nat), Env env, PEnv penv)  = nat;\n\nint eval1(var(str n), Env env, PEnv penv)  = env[n]; \n\nint eval1(mul(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) * eval1(rhs, env, penv);\n\nint eval1(div(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) / eval1(rhs, env, penv);\n\nint eval1(add(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) + eval1(rhs, env, penv);\n\nint eval1(sub(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) - eval1(rhs, env, penv);\n\nint eval1(gt(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) > eval1(rhs, env, penv) ? 1 : 0;\n\nint eval1(lt(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) < eval1(rhs, env, penv) ? 1 : 0;\n\nint eval1(geq(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) >= eval1(rhs, env, penv) ? 1 : 0;\n\nint eval1(leq(Exp lhs, Exp rhs), Env env, PEnv penv) =\n    eval1(lhs, env, penv) <= eval1(rhs, env, penv) ? 1 : 0;\n\nint eval1(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv) =\n    (eval1(cond, env, penv) != 0) ? eval1(then, env, penv) : eval1(otherwise, env, penv);\n\nint eval1(call(str name, list[Exp] args), Env env, PEnv penv) {\n   f = penv[name];\n   env =  ( f.formals[i]: eval1(args[i], env, penv) | i <- index(f.formals) );\n   return eval1(f.body, env, penv);\n}\n\nint eval1(let(list[Binding] bindings, Exp exp), Env env, PEnv penv) { \n   env += ( b.var : eval1(b.exp, env, penv) | b <- bindings );\n   return eval1(exp, env, penv);\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The alias ",(0,l.kt)("inlineCode",{parentName:"p"},"Env")," is introduced that maps strings to integers. All evaluation functions get an extra Env argument.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The environment is used to retrieve a variable\u2019s value.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The environment is extended with new bindings."))),(0,l.kt)("p",null,"Let\u2019s try this with F1:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = let\n            x = n\n          in\n            if x <= 1 then\n               x\n            else\n               x * fact(x-1)\n            end\n          end\n")),(0,l.kt)("p",null,"The result:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Func::Load;\nimport demo::lang::Func::Eval1;\nimport demo::lang::Func::programs::F1;\neval1("fact", [10], load(F1));\n')),(0,l.kt)("h3",{id:"eval2"},"Eval2"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Like Eval1 but with support for sequences and assignments."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Interpreter Eval2 supports the following features of Func:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval2"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"function declaration"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"integer constant"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"comparison operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"call"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"let"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"sequence")),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"assignment")),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"address operator"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"dereference operator"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("p",null,"The main additions are local side effects and the sequence operator."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Eval2\n\n// local side effects, returning env\n\nimport demo::lang::Func::AST;\n\nimport List;\n\nalias Env = map[str, int];\nalias PEnv = map[str, Func];\n\nalias Result2 = tuple[Env, int];  \n\nResult2 eval2(str main, list[int] args, Prog prog) {\n  penv = ( f.name: f | f <- prog.funcs );\n  f = penv[main];\n  env = ( f.formals[i] : args[i] | i <- index(f.formals) );\n  return eval2(f.body, env, penv);\n}\n\nResult2 eval2(nat(int nat), Env env, PEnv penv) = <env, nat>;\n\nResult2 eval2(var(str name), Env env, PEnv penv) = <env, env[name]>;\n\nResult2 eval2(mul(Exp lhs, Exp rhs), Env env, PEnv penv) {  \n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, x * y>;\n}\n\nResult2 eval2(div(Exp lhs, Exp rhs), Env env, PEnv penv) {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, x / y>;\n}\n\nResult2 eval2(add(Exp lhs, Exp rhs), Env env, PEnv penv)  {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, x + y>;\n}\n\nResult2 eval2(sub(Exp lhs, Exp rhs), Env env, PEnv penv)  {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, x - y>;\n}\n\nResult2 eval2(gt(Exp lhs, Exp rhs), Env env, PEnv penv)  {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, (x > y) ? 1 : 0>;\n}\n\nResult2 eval2(lt(Exp lhs, Exp rhs), Env env, PEnv penv)  {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, (x < y) ? 1 : 0>;\n}\n\nResult2 eval2(geq(Exp lhs, Exp rhs), Env env, PEnv penv)  {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, (x >= y) ? 1 : 0>;\n}\n\nResult2 eval2(leq(Exp lhs, Exp rhs), Env env, PEnv penv)  {\n  <env, x> = eval2(lhs, env, penv);\n  <env, y> = eval2(rhs, env, penv);\n  return <env, (x <= y) ? 1 : 0>;\n}\n\nResult2 eval2(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv)  {\n  <env, c> = eval2(cond, env, penv);\n  return (c != 0) ? eval2(then, env, penv) : eval2(otherwise, env, penv);\n}\n\nResult2 eval2(call(str name, list[Exp] args), Env env, PEnv penv)  {\n   f = penv[name];\n   for (i <- index(f.formals)) {\n     <env, v> = eval2(args[i], env, penv);\n     env[f.formals[i]] = v;\n   }\n   return eval2(f.body, env, penv);\n}\n\nResult2 eval2(let(list[Binding] bindings, Exp exp), Env env, PEnv penv)  {\n   for (b <- bindings) {\n     <env, x> = eval2(b.exp, env, penv);\n     env[b.var] = x;\n   }\n   return eval2(exp, env, penv);\n}\n\nResult2 eval2(assign(var(str name), Exp exp), Env env, PEnv penv)  { \n  <env, v> = eval2(exp, env, penv);\n  env[name] = v;\n  return <env, v>;\n}\n\nResult2 eval2(seq(Exp lhs, Exp rhs), Env env, PEnv penv)  {  \n  <env, _> = eval2(lhs, env, penv);\n  return eval2(rhs, env, penv);\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The alias ",(0,l.kt)("inlineCode",{parentName:"p"},"Result")," is introduced: a pair of an environment and an integer value. All evaluator functions are changed\nfrom returning an integer (the result of evaluation) to ",(0,l.kt)("inlineCode",{parentName:"p"},"Result")," (the result of evaluation ",(0,l.kt)("em",{parentName:"p"},"and")," the local side\neffects).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The effect of this change can be seen in all functions. For instance, when evaluating multiplication, the\nenvironment produced by the left operand ahs to be passed as argument to the right operand of the multiplication.\nThis is needed, to propagate any side effects caused by the left operand to propagate to the right one.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Assignment is implemented.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Sequencing is implemented. Observe that that the value of the left operand is ignored and that the value of the\nright operand is returned."))),(0,l.kt)("p",null,"We apply ",(0,l.kt)("inlineCode",{parentName:"p"},"eval2")," to example ",(0,l.kt)("inlineCode",{parentName:"p"},"F2"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             n := 1\n          else\n             n := n * fact(n-1)\n          end;\n          n\n")),(0,l.kt)("p",null,"Let\u2019s try this."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Func::Load;\nimport demo::lang::Func::Eval2;\nimport demo::lang::Func::programs::F2;\neval2("fact", [10], load(F2));\n')),(0,l.kt)("h3",{id:"eval3"},"Eval3"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A complete Func interpreter including support for the address and dereference operators."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Interpreter Eval3 supports the following features of Func:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Eval3"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"function declaration"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"integer constant"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"variable"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"arithmetic operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"comparison operators"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"call"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"if"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"let"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"sequence"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"assignment"),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"address operator")),(0,l.kt)("td",{parentName:"tr",align:null},"y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"dereference operator")),(0,l.kt)("td",{parentName:"tr",align:null},"y")))),(0,l.kt)("p",null,"The main additions are the address and dereference operators."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Eval3\n\n// pointers into the stack\n\nimport demo::lang::Func::AST;\n\nimport List;\n\nalias Env = map[str, Address];\nalias PEnv = map[str, Func];\n\nalias Result3 = tuple[Mem, int];\n\nalias Address = int;\nalias Mem = list[int];\n\nAddress push(Mem mem) {\n  return size(mem);\n}\n\ntuple[Mem, Address] alloc(Mem mem, int v) {\n  mem += [v];\n  return <mem, size(mem) - 1>;\n}\n\nMem pop(Mem mem, Address scope) {\n  return slice(mem, 0, scope);\n}\n\nResult3 eval3(str main, list[int] args, Prog prog) {\n  penv = ( f.name: f | f <- prog.funcs );\n  f = penv[main];\n  mem = [];\n  <mem, env> = bind(f.formals, args, mem);\n  return eval3(f.body, env, penv, mem);\n}\n\ntuple[Mem, Env] bind(list[str] fs, list[int] args, Mem mem) {\n  env = ();\n  for (i <- index(fs)) {\n    <mem, a> = alloc(mem, args[i]);\n    env[fs[i]] = a;\n  }\n  return <mem, env>;\n}\n\nResult3 eval3(nat(int nat), Env env, PEnv penv, Mem mem) = <mem, nat>;\n\nResult3 eval3(var(str name), Env env, PEnv penv, Mem mem) = <mem, mem[env[name]]>;\n\n\nResult3 eval3(mul(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x * y>;\n}\n\nResult3 eval3(div(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x / y>;\n}\n\nResult3 eval3(add(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x + y>;\n}\n\nResult3 eval3(sub(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x - y>;\n}\n\nResult3 eval3(gt(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x > y) ? 1 : 0>;\n}\n\nResult3 eval3(lt(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x < y) ? 1 : 0>;\n}\n\nResult3 eval3(geq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x >= y) ? 1 : 0>;\n}\n\nResult3 eval3(leq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x <= y) ? 1 : 0>;\n}\n\nResult3 eval3(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv, Mem mem) {\n  <mem, c> = eval3(cond, env, penv, mem);\n  return (c != 0) ? eval3(then, env, penv, mem) : eval3(otherwise, env, penv, mem);\n}\n\nResult3 eval3(call(str name, list[Exp] args), Env env, PEnv penv, Mem mem) {\n   f = penv[name];\n   scope = push(mem);\n   vs = for (a <- args) {\n     <mem, v> = eval3(a, env, penv, mem);\n     append v;\n   }\n   <mem, env> = bind(f.formals, vs, mem);\n   <mem, v> = eval3(f.body, env, penv, mem);\n   return <pop(mem, scope), v>;\n}\n\nResult3 eval3(address(str var), Env env, PEnv penv, Mem mem) = <mem, env[var]>;\n\nResult3 eval3(deref(Exp exp), Env env, PEnv penv, Mem mem) {\n  <mem, v> = eval3(exp, env, penv, mem);\n  return <mem, mem[v]>;\n}\n\nResult3 eval3(let(list[Binding] bindings, Exp exp), Env env, PEnv penv, Mem mem) {\n   scope = push(mem);\n   for (b <- bindings) {\n     <mem, v> = eval3(b.exp, env, penv, mem);\n     <mem, a> = alloc(mem, v);\n     env[b.var] = a;\n   }\n   <mem, v> = eval3(exp, env, penv, mem);\n   return <pop(mem, scope), v>;\n}\n\nResult3 eval3(seq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, _> = eval3(lhs, env, penv, mem);\n  return eval3(rhs, env, penv, mem);\n}\n\nResult3 eval3(assign(var(str name), Exp e), Env env, PEnv penv, Mem mem) {\n  <mem, v> = eval3(e, env, penv, mem);\n  mem[env[name]] = v;\n  return <mem, v>;\n}\n\nResult3 eval3(assign(deref(Exp lvalue), Exp e), Env env, PEnv penv, Mem mem) {\n  <mem, addr> = eval3(lvalue, env, penv, mem);\n  <mem, v> = eval3(e, env, penv, mem);\n  mem[addr] = v;\n  return <mem, v>;\n}\n")),(0,l.kt)("p",null,"We apply ",(0,l.kt)("inlineCode",{parentName:"p"},"eval3")," to example ",(0,l.kt)("inlineCode",{parentName:"p"},"F3"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"swap(a, b) =\n          let\n            temp = *a\n          in\n            *a := *b;\n            *b := temp\n          end\n\nfact(n) = let\n            x = 1,\n            y = 0\n          in\n            if n <= 1 then\n               x := 1\n            else\n               x := n * fact(n-1)\n            end;\n            swap(&x, &y);\n            y\n          end\n")),(0,l.kt)("p",null,"Let\u2019s try this."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Func::Load;\nimport demo::lang::Func::Eval3;\nimport demo::lang::Func::programs::F3;\neval3("fact", [10], load(F3));\n')),(0,l.kt)("h3",{id:"load-ast"},"Load AST"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Parse Func program from string or file and convert to an abstract syntax tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"To simplify later processing, Func programs are converted to an abstract syntax tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The concrete syntax for Func is described in ",(0,l.kt)("a",{parentName:"p",href:"#Func-ConcreteSyntax"},"Concrete Syntax")," and its abstract syntax in\n",(0,l.kt)("a",{parentName:"p",href:"#Func-AbstractSyntax"},"Abstract Syntax"),". Rather than manually writing conversion rules from Func parse trees to Func\nabstract syntax trees we use our secret weapon: ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#implode"},"implode")," that performs the mapping for us.\nAs you see when you compare the concrete and abstract syntax, the ground work has already been done by appropriately\nlabelling concrete rules with constructor names of the abstract syntax."),(0,l.kt)("p",null,"Here is the code for the ",(0,l.kt)("inlineCode",{parentName:"p"},"load")," funcion:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Load\n\nimport demo::lang::Func::Func;\nimport demo::lang::Func::AST;\nimport demo::lang::Func::Parse;\n\nimport ParseTree;\n\ndemo::lang::Func::AST::Prog implode(demo::lang::Func::Func::Prog p) =\n    implode(#demo::lang::Func::AST::Prog, p);\n\ndemo::lang::Func::AST::Prog load(loc l) = implode(parse(l));\ndemo::lang::Func::AST::Prog load(str s) = implode(parse(s));\n")),(0,l.kt)("p",null,"This looks simple but also slightly intimidating due to the many qualified names. The issue is that the names in the\nconcrete and abstract syntax are (on purpose) overloaded. A name like ",(0,l.kt)("inlineCode",{parentName:"p"},"Prog")," can be the one from the concrete\nsyntax(i.e., ",(0,l.kt)("inlineCode",{parentName:"p"},"demo::lang::Func::Func::Prog"),") or the one from the abstract syntax (i.e., ",(0,l.kt)("inlineCode",{parentName:"p"},"demo::lang::Func::AST::Prog"),")."),(0,l.kt)("p",null,"For instance, the local version of ",(0,l.kt)("inlineCode",{parentName:"p"},"implode")," defined here get a concrete ",(0,l.kt)("inlineCode",{parentName:"p"},"Prog")," as argument and returns an abstract one.\nBoth ",(0,l.kt)("inlineCode",{parentName:"p"},"load")," function return an abstract ",(0,l.kt)("inlineCode",{parentName:"p"},"Prog"),"."),(0,l.kt)("p",null,"Let\u2019s try this on example ",(0,l.kt)("inlineCode",{parentName:"p"},"F0"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             1\n          else\n             n * fact(n-1)\n          end\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::lang::Func::Load;\nimport demo::lang::Func::programs::F0;\nload(F0);\n")),(0,l.kt)("p",null,"We get the original program and its ",(0,l.kt)("em",{parentName:"p"},"abstract syntax tree")," of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Prog")," back. In case of doubt, compare this with the\nresult in ",(0,l.kt)("a",{parentName:"p",href:"#Func-Parse"},"Parse")," where we did obtain a parse tree. Next, we try the same from a file:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"load(|std:///demo/lang/Func/programs/F0.func|);\n")),(0,l.kt)("h3",{id:"parse"},"Parse"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Parse a Func program from a string or a file."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Parsing uses the syntax rules for a given start non-terminnal to parse a string and turn it into a parse tree. The work\nhorse is the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#parse"},"parse")," function that is available in the\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#parsetree"},"PareTree")," library."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is how to parse Func programs from a string or file:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Parse\n\nimport demo::lang::Func::Func;\nimport ParseTree;\n\nProg parse(loc l) = parse(#Prog, l);\nProg parse(str s) = parse(#Prog, s);\n")),(0,l.kt)("p",null,"Let\u2019s try this on example ",(0,l.kt)("inlineCode",{parentName:"p"},"F0.func"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             1\n          else\n             n * fact(n-1)\n          end\n")),(0,l.kt)("p",null,"First, we try the version with a string argument:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::lang::Func::Parse;\nimport demo::lang::Func::programs::F0;\nparse(F0);\n")),(0,l.kt)("p",null,"This must be defined as success: we get the original program and its parse tree back. Next, we try the same from a file.\nWe use the scheme ",(0,l.kt)("inlineCode",{parentName:"p"},"std")," that refers to files that reside in the Rascal library. See\n","[","$Rascal:Expressions/Values/Location","]"," for further details on other schemes."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"parse(|std:///demo/lang/Func/programs/F0.func|);\n")),(0,l.kt)("h3",{id:"lisra"},"Lisra"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A lisp interpreter in Rascal."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Writing a Lisp interpreter is a classical challenge. Popular word has that all large applications evolve until they\ninclude a Lisp interpreter. (A variant says the same about including an email client in every large application)."),(0,l.kt)("p",null,"We will closely follow and ",(0,l.kt)("strong",{parentName:"p"},"reuse parts of")," Peter Norvig\u2019s excellent page on ",(0,l.kt)("a",{parentName:"p",href:"http://norvig.com/lispy.html"},"Lispy"),", a\nLisp interpreter written in Python. The Lisp variant to be implemented is the following subset of the\n",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Scheme_(programming_language)"},"Scheme")," language:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Form"),(0,l.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,l.kt)("th",{parentName:"tr",align:null},"Semantics and Example"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.1"},"variable reference")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"var")),(0,l.kt)("td",{parentName:"tr",align:null},"A symbol is interpreted as a variable name; its value is the variable\u2019s value. Example: ",(0,l.kt)("inlineCode",{parentName:"td"},"x"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.2"},"constant literal")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},"A number evaluates to itself. Example: ",(0,l.kt)("inlineCode",{parentName:"td"},"12"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.2"},"quotation")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(quote exp)")),(0,l.kt)("td",{parentName:"tr",align:null},"Return the ",(0,l.kt)("em",{parentName:"td"},"exp")," literally; do not evaluate it. Example: ",(0,l.kt)("inlineCode",{parentName:"td"},"(quote (a b c)) \u21d2; (a b c)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.5"},"conditional")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(if test conseq alt)")),(0,l.kt)("td",{parentName:"tr",align:null},"Evaluate ",(0,l.kt)("em",{parentName:"td"},"test"),"; if true, evaluate and return ",(0,l.kt)("em",{parentName:"td"},"conseq"),"; otherwise evaluate and return ",(0,l.kt)("em",{parentName:"td"},"alt"),". \\<br",">","Example: ",(0,l.kt)("inlineCode",{parentName:"td"},"(if (< 10 20) (+ 1 1) (+ 3 3)) \u21d2 2"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.6"},"assignment")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(set! var exp)")),(0,l.kt)("td",{parentName:"tr",align:null},"Evaluate ",(0,l.kt)("em",{parentName:"td"},"exp")," and assign that value to ",(0,l.kt)("em",{parentName:"td"},"var"),", which must have been previously defined (with a ",(0,l.kt)("inlineCode",{parentName:"td"},"define")," or as a parameter to an enclosing procedure). Example: ",(0,l.kt)("inlineCode",{parentName:"td"},"(set! x2 (* x x))"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%25_sec_5.2"},"definition")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(define var exp)")),(0,l.kt)("td",{parentName:"tr",align:null},"Define a new variable in the innermost environment and give it the value of evaluating the expression ",(0,l.kt)("em",{parentName:"td"},"exp"),". Examples: ",(0,l.kt)("inlineCode",{parentName:"td"},"(define r 3)")," ",(0,l.kt)("em",{parentName:"td"},"or")," ",(0,l.kt)("inlineCode",{parentName:"td"},"(define square (lambda (x) (* x x)))"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.4"},"procedure")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(lambda (var\u2026\u200b) exp)")),(0,l.kt)("td",{parentName:"tr",align:null},"Create a procedure with parameter(s) named ",(0,l.kt)("em",{parentName:"td"},"var\u2026\u200b")," and the expression as the body. Example: ",(0,l.kt)("inlineCode",{parentName:"td"},"(lambda (r) (* r r))"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.2.3"},"sequencing")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(begin exp\u2026\u200b)")),(0,l.kt)("td",{parentName:"tr",align:null},"Evaluate each of the expressions in left-to-right order, and return the final value. Example: ","`","(begin (set","!"," x 1) (set","!"," x (+ x 1)) (","*"," x 2)) \u21d2 4")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_sec_4.1.3"},"procedure call")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(proc exp\u2026\u200b)")),(0,l.kt)("td",{parentName:"tr",align:null},"If ",(0,l.kt)("em",{parentName:"td"},"proc")," is anything other than one of the symbols ",(0,l.kt)("inlineCode",{parentName:"td"},"if"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"set!"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"define"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"lambda"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"begin"),", or ",(0,l.kt)("inlineCode",{parentName:"td"},"quote")," then it is treated as a procedure. It is evaluated using the same rules defined here. All the expressions are evaluated as well, and then the procedure is called with the list of expressions as arguments. Example: \\<","`","(square 12) \u21d2 144")))),(0,l.kt)("p",null,"In this table, ",(0,l.kt)("em",{parentName:"p"},"var")," must be a symbol\u2014\u200ban identifier such as x or square\u2014\u200band number must be an integer number, while\nthe other italicized words can be any expression. The notation ",(0,l.kt)("em",{parentName:"p"},"exp"),"\u2026\u200b means zero or more repetitions of ",(0,l.kt)("em",{parentName:"p"},"exp"),"."),(0,l.kt)("p",null,"A Lisp interpreter consists of the following parts:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("em",{parentName:"p"},"parser")," that reads a Lisp program in text form and converts it to a runtime representation that is suitable for\nthe interpreter.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The ",(0,l.kt)("em",{parentName:"p"},"interpreter")," itself that executes the program in runtime representation and computes its outcome.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("em",{parentName:"p"},"pretty printer")," that converts the outcome in internal representation back to text.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Finally, an interactive ",(0,l.kt)("em",{parentName:"p"},"console")," is needed that interact with the user."))),(0,l.kt)("p",null,"We discuss all these aspects:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Syntax"},"Syntax"),": The textual syntax of Lisp.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Runtime"},"Runtime"),": The runtime representation of Lisp programs and data.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Parse"},"Parse"),": Parsing a Lisp expression.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Pretty"},"Pretty"),": A Lisp pretty printer.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Eval"},"Eval"),": A Lisp interpreter.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Lisra-Test"},"Test"),": Tests for the Lisp interpreter."))),(0,l.kt)("h3",{id:"syntax"},"Syntax"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"The textual syntax of Lisp."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"The first step in defining Lisp\u2019s textual format, we define a grammar for it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Syntax\n\nlayout Whitespace      = [\\t-\\n\\r\\ ]*;\nlexical IntegerLiteral = [0-9]+ !>> [0-9];\nlexical AtomExp        = (![0-9()\\t-\\n\\r\\ ])+ !>>  ![0-9()\\t-\\n\\r\\ ];\n\nstart syntax LispExp            // TODO: remove constructor names (needed for compiler)\n      = int_lit: IntegerLiteral\n      | atom_exp: AtomExp\n      | par_exp: "(" LispExp* ")"\n      ;\n')),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Whitespace")," defines the characters that can be ignored between tokens."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"IntegerLiteral")," defines integer constants. In a first approximation ",(0,l.kt)("inlineCode",{parentName:"p"},"[0-9]")," is enough. However, to ensure that the\nlongest possible sequence of digits is used, the ",(0,l.kt)("inlineCode",{parentName:"p"},"!>> [0-9]")," part ensures that an integer cannot be followed by another\ndigit."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"AtomExp")," defines a Lisp symbol that may contain a wide range of characters (except layout and digits)."),(0,l.kt)("p",null,"The main syntactic concept is a ",(0,l.kt)("inlineCode",{parentName:"p"},"LispExp")," that may be an ",(0,l.kt)("inlineCode",{parentName:"p"},"IntegerLiteral"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"AtomExp")," or a list of ","`","LispExp","`","s surrouned\nby parentheses."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"This grammar is demonstrated in ",(0,l.kt)("a",{parentName:"p",href:"#Lisra-Parse"},"Parse"),"."),(0,l.kt)("h3",{id:"runtime"},"Runtime"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"The runtime representation of Lisp programs and data."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"There are several aspects of the runtime representation of Lisp programs and Lisp data that have to be described:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The representation of values (see ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval")," below).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The handling of the ",(0,l.kt)("em",{parentName:"p"},"scope")," of variables (see ",(0,l.kt)("inlineCode",{parentName:"p"},"Scope"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Env"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"makeEnv")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"find")," below).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The way the interpreter returns its results (see ",(0,l.kt)("inlineCode",{parentName:"p"},"Result")," below)."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Runtime\n\nimport Prelude;\n\ndata Lval \n     = Integer(int n)\n     | Atom(str name)\n     | List(list[Lval] elms)\n     | Closure(Result(list[Lval] args, Env env))\n     ;\n\nalias Scope  = map[Lval,Lval]; \nalias Env    = list[Scope];\n\npublic Env emptyEnv = [()];\n\nEnv makeEnv(list[Lval] vars, list[Lval] values, Env outer) = \n   [(vars[i] : values[i] | i <- index(vars))] + outer;\n\nint find(Lval sym, Env e){ \n   for(n <- index(e))\n       if(e[n][sym]?)\n          return n;\n   return -1;\n}\n\npublic Lval TRUE  = Atom("#t"); \npublic Lval FALSE = Atom("#f");\n\nalias Result = tuple[Lval val, Env env]; \n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The data type ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval")," takes care of the representation of Lisp values. It covers integers, atoms, lists and closures\n(the representation of a functions and the context in which it will be executed).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"Scope")," describes the binding of several related variables to their value. Since scopes may be nested, an\nenvironment (",(0,l.kt)("inlineCode",{parentName:"p"},"Env"),") consisted of a list of scope. The most inner scope is at the start of the list and the most\nglobal one at the end.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Creating a new scope is done by ",(0,l.kt)("inlineCode",{parentName:"p"},"makeEnv")," which takes a list of variables (represented by ",(0,l.kt)("inlineCode",{parentName:"p"},'Lval`s, in most cases\nthis will be an atom like `Atom("X")'),"), a list of values and creates a new scope in front of the current\nenvironment.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"find")," tries to locate the scope in which a name was previously defined. It searches the nested scopes\ninside-out and returns the ",(0,l.kt)("em",{parentName:"p"},"index")," in the given environment of the scope in which the name is defined, or ",(0,l.kt)("inlineCode",{parentName:"p"},"-1")," if it\nis not found.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We define useful constants for true and false (the atoms ",(0,l.kt)("inlineCode",{parentName:"p"},"#t")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),", respectively).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Finally, we define ",(0,l.kt)("inlineCode",{parentName:"p"},"Result")," as a tuple of an ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval")," and an ",(0,l.kt)("inlineCode",{parentName:"p"},"Env"),". Each step during interpretation will thus return\nthe value it computed and a possibly modified environment."))),(0,l.kt)("h3",{id:"parse-1"},"Parse"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Parsing a Lisp expression."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Given the Lisp ",(0,l.kt)("a",{parentName:"p",href:"#Lisra-Syntax"},"Syntax"),", we can now apply it to parse textual Lisp expressions and convert them to the\nruntime representation ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Parse\n\nimport Prelude;\nimport demo::lang::Lisra::Syntax;\nimport demo::lang::Lisra::Runtime;\n\nLval parse(str txt) = build(parse(#LispExp, txt)); \n\n// Build Abstract Synax Tree: Transform a LispExp to an Lval\n\nLval build((LispExp)`<IntegerLiteral il>`) = Integer(toInt("<il>"));      \nLval build((LispExp)`<AtomExp at>`)        = Atom("<at>");                \nLval build((LispExp)`( <LispExp* lst> )`)  = List([build(l) | l <- lst]); \n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First we define the actual ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," function: it takes a string as argument and returns an ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval"),". It proceeds in two\nsteps:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First the text is parsed using ",(0,l.kt)("inlineCode",{parentName:"p"},"parse(#LispExp, txt)"),". The result is parse tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Next, the auxiliary function ",(0,l.kt)("inlineCode",{parentName:"p"},"build")," is used to transform the parse tree to an ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval"),".")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Function ",(0,l.kt)("inlineCode",{parentName:"p"},"build")," is defined in cases, to handle the various parse tree forms. Fortunately, we do not have to spell\nout the details of the parse tree, but we can use concrete patterns instead (see ",(0,l.kt)("a",{parentName:"p",href:"#Concrete%20Patterns"},"???"),",\nbelow)."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},'The right-hand sides deserve some attention. Here the argument `il` is a _parse tree_ (!!) that represents an integer literal.\nWe first convert it to a string using string interpolation (`"<il>"`) and then convert it to an integer.\n'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The text of the atom is reconstructed in a similar fashion.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The concrete list elements in ",(0,l.kt)("inlineCode",{parentName:"p"},"lst")," are converted one-by-one using build and are then used to create a new ",(0,l.kt)("inlineCode",{parentName:"p"},"List"),"\nvalue."))),(0,l.kt)("p",null,"We use concrete patterns in these definitions. For instance, the argument pattern"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"(LispExp)`<IntegerLiteral il>`\n")),(0,l.kt)("p",null,"says:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Match something of type ",(0,l.kt)("inlineCode",{parentName:"p"},"LispExp"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"It should be an ",(0,l.kt)("inlineCode",{parentName:"p"},"IntegerLiteral")," and bind it to a variable ",(0,l.kt)("inlineCode",{parentName:"p"},"il"),"."))),(0,l.kt)("p",null,"More precisely, the text between backquotes should be a string that can be parsed according to the non-terminal that\nprecedes it (",(0,l.kt)("inlineCode",{parentName:"p"},"LispExp")," in this example). This is illustrated by the list case where the parentheses appear in the\nconcrete pattern:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"(LispExp)`( <LispExp* lst> )`\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Lisra::Parse;\nimport demo::lang::Lisra::Runtime;\nparse("1");\nparse("x");\nparse("(+ 5 7)");\n')),(0,l.kt)("h3",{id:"pretty"},"Pretty"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A Lisp pretty printer."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"The purpose of a pretty printer is to convert an internal structure to text. We define here the simplest possible\nsolution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Pretty\n\nimport demo::lang::Lisra::Runtime;\n\n// Pretty print: transform an Lval to a string\nstr pretty(Integer(n))  = "<n>";\nstr pretty(Atom(name))  = name;\nstr pretty(List(list[Lval] elms)) = "( <for(Lval e <- elms){><pretty(e)> <}>)";\nstr pretty(Closure(fn)) = "Closure(<fn>)";\n')),(0,l.kt)("p",null,"Compare the definition of ",(0,l.kt)("inlineCode",{parentName:"p"},"pretty")," with that of ",(0,l.kt)("inlineCode",{parentName:"p"},"parse"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"Lval parse(str txt);\nstr pretty(Lval x);\n")),(0,l.kt)("p",null,"For a well-designed pair of ",(0,l.kt)("inlineCode",{parentName:"p"},"parse"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"pretty")," functions, the latter is the inverse of the former. In other words, for\nevery ",(0,l.kt)("inlineCode",{parentName:"p"},"L")," the following should hold:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"parse(pretty(L)) == L\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Lisra::Runtime;\nimport demo::lang::Lisra::Pretty;\npretty(Integer(42));\npretty(Atom("x"));\nL = List([Atom("+"), Integer(5), Integer(7)]);\npretty(L);\n')),(0,l.kt)("p",null,"Now let\u2019s explore whether ",(0,l.kt)("inlineCode",{parentName:"p"},"pretty")," is indeed the inverse of ",(0,l.kt)("inlineCode",{parentName:"p"},"parse"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import demo::lang::Lisra::Parse;\nparse(pretty(L)) == L;\n")),(0,l.kt)("h3",{id:"eval"},"Eval"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A Lisp interpreter."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Here is the core of our Lisp interpreter. Its basic functionality is to take"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval")," and an Environment (both defined in ",(0,l.kt)("a",{parentName:"p",href:"#Lisra-Runtime"},"Runtime"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Distinguish the various forms an ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval")," can have and compute the effect of evaluating it.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Return a ",(0,l.kt)("inlineCode",{parentName:"p"},"Result")," that captures the value just computed and possibleside-effects on the environment."))),(0,l.kt)("p",null,"Rascal provides pattern-directed dispatch: a function with the same name can have complete patterns as arguments. When\ncalled, a pattern match determines which variant of the function will be called. This is used extensively in the\ndefinitions below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Eval\n\nimport Prelude;\nimport demo::lang::Lisra::Parse;\nimport demo::lang::Lisra::Runtime;\n\nLval eval(Lval x) = eval(x, [()]).val;\n\n// Evaluate an Lval in a given environment and return a Result.\n\nResult eval(str exp) = eval(parse(exp),  [()]);\n\nResult eval(Integer(int x), Env e) = <Integer(x), e>; \n\nResult eval(var:Atom(str name), Env e) { \n  n = find(var, e);\n  return <(n < 0) ? var : e[n][var], e>;\n}\n\nResult eval(List([Atom("quote"), *Lval exps]), Env e) = \n  <size(exps) == 1 ? exps[0] : List(exps), e>;\n\nResult eval(List([Atom("set!"), var, exp]), Env e) { \n  val = eval(exp, e).val;\n  n = find(var, e);\n  if(n < 0) e[0][var] = val; else e[n][var] = val;\n  return <val, e>;\n}\n\nResult eval(List([Atom("if"), Lval tst, Lval conseq, Lval alt]), Env e) = \n  eval(tst, e).val != FALSE ? eval(conseq, e) : eval(alt, e);\n\n\nResult eval(List([Atom("begin"), *Lval exps]) , Env e) { \n  val = FALSE;\n  for(Lval exp <- exps){\n      <val, e> = eval(exp, e);\n  }\n  return <val, e>;\n}\n\nResult eval(List([Atom("define"), var, exp]), Env e){ \n   e[0][var] = eval(exp, e).val;\n   return <FALSE, e>;\n}\n\nResult eval(List([Atom("lambda"), List(list[Lval] vars), exp]), Env defEnv) = \n  <Closure(Result(list[Lval] args, Env callEnv) {\n                 return eval(exp, makeEnv(vars, args, tail(callEnv, size(defEnv))));\n           }),\n   defEnv>;\n\ndefault Result eval(List([ *Lval exps ]), Env e) { \n  if(isEmpty(exps))\n     return <List([]), e>;\n  vals = [ eval(exp, e).val | exp <- exps ];\n  return apply(head(vals), tail(vals), e);\n}\n\n//default Result eval(Lval exp, Env e) = <exp, e>;\n\n\n// Apply an Lval to a list of arguments and return a Result\nResult apply(Closure(Result(list[Lval] args, Env env) fn), list[Lval] args, Env e) { \n  return <fn(args, e).val, e>;\n}\n\n\n\nResult apply(Atom("+"),      [Integer(x), Integer(y)],      Env e) = <Integer(x + y), e>;\nResult apply(Atom("-"),      [Integer(x), Integer(y)],      Env e) = <Integer(x - y), e>;\nResult apply(Atom("*"),      [Integer(x), Integer(y)],      Env e) = <Integer(x * y), e>;\nResult apply(Atom("\\<"),     [Lval x, Lval y],              Env e) = <x < y ? TRUE : FALSE, e>;\nResult apply(Atom("\\>"),     [Lval x, Lval y],              Env e) = <x >= y ? TRUE : FALSE, e>;\nResult apply(Atom("equal?"), [Lval x, Lval y],              Env e) = <x == y ? TRUE : FALSE, e>;\nResult apply(Atom("null?"),  [List(list[Lval] x)],          Env e) = <isEmpty(x) ? TRUE : FALSE, e>;\nResult apply(Atom("cons"),   [Lval x, List(list[Lval] y)],  Env e) = <List([x, *y]), e>;\nResult apply(Atom("append"), [List(list[Lval] x), Lval y],  Env e) = <List([*x, y]), e>;\nResult apply(Atom("car"),    [List(list[Lval] x)],          Env e) = <head(x), e>;\nResult apply(Atom("cdr"),    [List(list[Lval] x)],          Env e) = <List(tail(x)), e>;\nResult apply(Atom("list"),   list[Lval] x,                  Env e) = <List(x), e>;\n\ndefault Result apply(Lval a,     list[Lval] b, Env e) { \n  println("Cannot apply <a> to <b> using <e>");\n  return <FALSE, e>;\n}\n')),(0,l.kt)("p",null,"We now explain the different cases in more detail:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An integer constant evaluates to itself. Note how ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer(int x)")," is used as first argument of this ",(0,l.kt)("inlineCode",{parentName:"p"},"eval"),"\nfunction. It is a pattern that describes that the constructor ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer")," with an ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," argument ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is to be matched.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An atom evaluates to the value to which it is bound or to itself. ",(0,l.kt)("inlineCode",{parentName:"p"},"find")," (see ","[","Runtime","]",") is used to search for the\natom in question. The first argument is ",(0,l.kt)("inlineCode",{parentName:"p"},"var:Atom(str name)"),", a pattern that matches an ",(0,l.kt)("inlineCode",{parentName:"p"},"Atom"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"var:")," prefix\nbinds the complete atom to a variable ",(0,l.kt)("inlineCode",{parentName:"p"},"var")," to be used in the body of the function.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A quoted list evaluates to itself. The pattern ",(0,l.kt)("inlineCode",{parentName:"p"},'List([Atom("quote"), exp*])')," matches a ",(0,l.kt)("inlineCode",{parentName:"p"},"List")," constructor whose\nfirst element is ",(0,l.kt)("inlineCode",{parentName:"p"},'Atom("quote")'),". ",(0,l.kt)("inlineCode",{parentName:"p"},"exp*")," means that the remaining list elements are assignment to ",(0,l.kt)("inlineCode",{parentName:"p"},"exp"),". There are\ntwo cases: if the argument list has size 1, its first element is used, otherwise a list with all elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"exp"),"\nvare returned. This ensures that ",(0,l.kt)("inlineCode",{parentName:"p"},'List([Atom("quote"), Integer(17)])')," evaluates to ",(0,l.kt)("inlineCode",{parentName:"p"},"Integer(17)")," and not to ",(0,l.kt)("inlineCode",{parentName:"p"},"List([\nInteger(17)]"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Evaluates a ",(0,l.kt)("inlineCode",{parentName:"p"},"set!")," expression that assigns the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"exp")," to variable ",(0,l.kt)("inlineCode",{parentName:"p"},"var"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Evaluates the ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," expression. The test ",(0,l.kt)("inlineCode",{parentName:"p"},"tst")," is evaluated and is not false, the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"conseq")," is returned and\notherwise that of ",(0,l.kt)("inlineCode",{parentName:"p"},"alt"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Evaluates a ",(0,l.kt)("inlineCode",{parentName:"p"},"block")," expression. The list of expressions ",(0,l.kt)("inlineCode",{parentName:"p"},"exps")," is evaluated one by one. Observe that in the for loop\n",(0,l.kt)("inlineCode",{parentName:"p"},"<val, e> = eval(exp, e);")," captures both the value and the environment that results from executing one expression.\nThat new environment is is used to evaluate the next expression(s) in the list. The value of the last expression and\na possible modied environment are returned.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Evaluate a ",(0,l.kt)("inlineCode",{parentName:"p"},"define")," expression that binds the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"exp")," to variable ",(0,l.kt)("inlineCode",{parentName:"p"},"var"),". The value of the expression is bound\n",(0,l.kt)("inlineCode",{parentName:"p"},"var")," in the local scope.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Evaluate a lambda expression. Essentially we return a ",(0,l.kt)("inlineCode",{parentName:"p"},"Closure")," value that contains the expression in the lambda\nexpression properly wrapped to do variable binding and environment management. A Closure contains a function that\nreturn type ",(0,l.kt)("inlineCode",{parentName:"p"},"Results")," and has two arguments: ",(0,l.kt)("inlineCode",{parentName:"p"},"list[lval] args")," the actual parameter values when the closure is\napplied, and ",(0,l.kt)("inlineCode",{parentName:"p"},"Env e")," the environment at the site of the call. In the body of the closure we construct a new\nenvironment ",(0,l.kt)("inlineCode",{parentName:"p"},"makeEnv(vars, args, tail(callEnv, size(defEnv)))")," that binds the variables in the lambda expression to\nthe actual parameter values. What is special here is that we shorten the calling environment to the same length as\nthe defining environment. This implements ",(0,l.kt)("em",{parentName:"p"},"lexical scoping")," and avoids that names are visible in the called function\nthat were not visible when the function was defined. Remember that Rascal values are immutable, meaning that after a\nvalue was created it cannot be changed. Using the above trick, we ensure that the called function has access to the\nmost recent version of its environment.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Evaluates an arbitrary list. As a special case, the empty list is returned as false. Otherwise, all elements are\nevaluated and the auxiliary function ","`"," apply","`"," is used to apply the value of the first element to the values of the\nremaining elements.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Apply an ",(0,l.kt)("inlineCode",{parentName:"p"},"Lval")," to a list of arguments and return a ",(0,l.kt)("inlineCode",{parentName:"p"},"Result"),". The first case handles a ",(0,l.kt)("inlineCode",{parentName:"p"},"Closure"),"; it amounts to\ncalling the function in the closure (environment handling and parameter binding are done in the closure as discussed\nabove.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Definition of all built-in functions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A default function that prints an error message when an undefined function is called."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Lisra::Runtime;\nimport demo::lang::Lisra::Eval;\neval(Integer(5));\neval(Atom("x"));\neval(List([Atom("+"), Integer(5), Integer(7)]));\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A very modular, rule-based, type safe Lisp interpreter.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It is no pleasure to type in ","`","Lval","`","s directly, that is why a parser is needed, see ",(0,l.kt)("a",{parentName:"li",href:"#Lisra-Parse"},"Parse"),".")),(0,l.kt)("h3",{id:"test"},"Test"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Tests for the Lisp interpreter."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"It is good practice to write tests for your software."),(0,l.kt)("p",null,"Here are our tests for Lisra:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Test\n\nimport demo::lang::Lisra::Runtime;\nimport demo::lang::Lisra::Eval;\n\ntest bool eval01() = eval("42").val == Integer(42);\ntest bool eval02() = eval("x").val == Atom("x");\n\ntest bool eval03() = eval("(quote 1)").val == Integer(1);\ntest bool eval04() = eval("(quote 1 2)").val == List([Integer(1), Integer(2)]);\n\ntest bool eval05() = eval("(+ 1 2)").val == Integer(3);\ntest bool eval06() = eval("(- 5 3)").val == Integer(2);\ntest bool eval07() = eval("(* 5 3)").val == Integer(15);\ntest bool eval08() = eval("(\\< 3 4)").val != FALSE;\ntest bool eval09() = eval("(\\< 3 2)").val == FALSE;\ntest bool eval10() = eval("(\\> 3 2)").val != FALSE;\ntest bool eval11() = eval("(\\>3 4)").val == FALSE;\ntest bool eval12() = eval("(equal? 3 3)").val != FALSE;\ntest bool eval13() = eval("(equal? 3 2)").val == FALSE;\n\ntest bool eval14() = eval("(null? ())").val != FALSE;\ntest bool eval15() = eval("(null? (quote 1 2))").val == FALSE;\n\ntest bool eval16() = eval("(begin (define swap (lambda (a b) (list b a))) (swap 1 2))").val ==\n                     List([Integer(2), Integer(1)]);\ntest bool eval17() = eval("(begin (define * (lambda (a b) (+ a b))) (* 1 2))"). val == Integer(3);\n\ntest bool eval18() = eval("(begin (set! x 1) x)").val == Integer(1);\ntest bool eval19() = eval("(if (\\> 5 2) 10 20)").val == Integer(10);\ntest bool eval20() = eval("(if (\\> 2 5) 10 20)").val == Integer(20);\n\ntest bool eval21() = eval("(begin (define fac (lambda (n) (if (\\> n 1) (* n (fac (- n 1))) 1))) (fac 3))").val == Integer(6);\ntest bool eval22() = eval("(begin (define length (lambda (x) (if(null? x) 0 (+ 1 (length (cdr x)))))) (length (quote (1 2 3))))").val == Integer(3);\ntest bool eval23() = eval("(begin (define rev (lambda (x) (if (null? x) () (append (rev (cdr x)) (car x))))) (rev (quote 1 2 3)))").val == List([Integer(3), Integer(2), Integer(1)]);\ntest bool eval24() = eval("(begin (define F (lambda (x) y)) (set! y 10) (F 1))").val == Integer(10);\n')),(0,l.kt)("h3",{id:"pico"},"Pico"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"The classical toy language, including a specialized IDE."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Pico is a toy language that has been used as example over the years in many projects and disguishes, Pico has a single\npurpose in life: being so simple that specifications of every possible language aspect are so simple that they fit on a\nfew pages. It can be summarized as follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There are two types: natural numbers and strings.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Variables have to be declared.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Statements are assignment, if-then-else and while-do.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Expressions may contain naturals, strings, variables, addition (",(0,l.kt)("inlineCode",{parentName:"p"},"+"),"), subtraction (",(0,l.kt)("inlineCode",{parentName:"p"},"-"),") and concatenation (",(0,l.kt)("inlineCode",{parentName:"p"},"||"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The operators ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"-")," have operands of type natural and their result is natural.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The operator ",(0,l.kt)("inlineCode",{parentName:"p"},"||")," has operands of type string and its results is also of type string.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Tests in if-then-else statement and while-statement should be of type natural."))),(0,l.kt)("p",null,"The following aspects of the Pico language will be discussed:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Abstract"},"Abstract"),": Abstract syntax for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Assembly"},"Assembly"),": Assembly language for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Compile"},"Compile"),": Compile a Pico program to assembly language.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-ControlFlow"},"ControlFlow"),": Compute the control flow graph for a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Evaluate"},"Evaluate"),": Evaluate a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-IDE"},"IDE"),": An Integrated Development Environment for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Load"},"Load"),": Convert a Pico parse tree into a Pico abstract syntax tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Syntax"},"Syntax"),": Concrete syntax for Pico.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Typecheck"},"Typecheck"),": Typechecker for Pico programs.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Uninit"},"Uninit"),": Find unitialized variables in a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-UseDef"},"UseDef"),": Compute use-def information for the variables in a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Pico-Visualize"},"Visualize"),": Visualize Pico Control Flow Graphs."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is a\u2009\u2014\u2009not so simple\u2009\u2014\u2009Pico program that computes the factorial function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"begin declare input : natural, \n              output : natural,\n              repnr : natural,\n              rep : natural;\n      input := 14;\n      output := 1;\n      while input - 1 do \n          rep := output;\n          repnr := input;\n          while repnr - 1 do\n             output := output + rep;\n             repnr := repnr - 1\n          od;\n          input := input - 1\n      od\nend\n")),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Pico programs do not have input/output statements, so we use variables for that purpose.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Pico has no multiplication operator so we have to simulate it with repeated addition (yes, simplicity comes at a\nprice","!",")."))),(0,l.kt)("h3",{id:"abstract-1"},"Abstract"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Abstract syntax for Pico."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is the complete abstract syntax for Pico:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Pico::Abstract\n\npublic data TYPE = natural() | string(); \n\npublic alias PicoId = str; \n\npublic data PROGRAM = \n  program(list[DECL] decls, list[STATEMENT] stats);\n\npublic data DECL =\n  decl(PicoId name, TYPE tp);\n\npublic data EXP =\n       id(PicoId name)\n     | natCon(int iVal)\n     | strCon(str sVal)\n     | add(EXP left, EXP right)\n     | sub(EXP left, EXP right)\n     | conc(EXP left, EXP right)\n     ;\n\npublic data STATEMENT =\n       asgStat(PicoId name, EXP exp)\n     | ifElseStat(EXP exp, list[STATEMENT] thenpart, list[STATEMENT] elsepart)\n     | whileStat(EXP exp, list[STATEMENT] body)\n     ;\n\nanno loc TYPE@location; \nanno loc PROGRAM@location;\nanno loc DECL@location;\nanno loc EXP@location;\nanno loc STATEMENT@location;\n\npublic alias Occurrence = tuple[loc location, PicoId name, STATEMENT stat]; \n")),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The types that may occur in a Pico program are either natural or string.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Introduce ",(0,l.kt)("inlineCode",{parentName:"p"},"PicoId")," as an alias for Rascal\u2019s ",(0,l.kt)("inlineCode",{parentName:"p"},"str")," datatype.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define the various data types that constitute an AST for Pico. Observe that the constructor names match the names\nused in the concrete syntax, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"strCon"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"add"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ifElseStat"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define an annotation with name ",(0,l.kt)("inlineCode",{parentName:"p"},"location")," and of type ",(0,l.kt)("inlineCode",{parentName:"p"},"loc")," (source code location) for all AST types. This will be\nused when imploding a parse tree into an abstract syntax tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Introduce ",(0,l.kt)("inlineCode",{parentName:"p"},"Occurrence")," as a genereic way of describing the location of various items in the AST."))),(0,l.kt)("h3",{id:"assembly"},"Assembly"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Assembly language for Pico."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"#Pico-Compile"},"Compile"),"r will translate Pico programs into the following assembly language."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Pico::Assembly\n\nimport demo::lang::Pico::Abstract;\n\npublic data Instr =\n       dclNat(PicoId Id)    // Reserve a memory location for a natural variable\n     | dclStr(PicoId Id)    // Reserve a memory location for a string variable\n     | pushNat(int intCon)  // Push integer constant on the stack\n     | pushStr(str strCon)  // Push string constant on the stack\n     | rvalue(PicoId Id)    // Push the value of a variable on the stack\n     | lvalue(PicoId Id)    // Push the address of a variable on the stack\n     | assign()             // Assign value on top, to variable at address top-1\n     | add2()               // Replace top two stack values by their sum\n     | sub2()               // Replace top two stack values by their difference\n     | conc2()              // Replace top two stack values by their concatenation\n     | label(str label)     // Associate a label with the next instruction\n     | go(str  label)       // Go to instruction with given label\n     | gotrue(str label)    // Go to instruction with given label, if top equals 0\n     | gofalse(str label)   // Go to instruction with given label, if top not equal to 0\n     ;\n")),(0,l.kt)("h3",{id:"compile"},"Compile"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Compile a Pico program to assembly language."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The Pico compiler translates Pico programs to ",(0,l.kt)("a",{parentName:"p",href:"#Pico-Assembly"},"Assembly")," language programs."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Pico::Compile\n\nimport Prelude;\nimport demo::lang::Pico::Abstract;\nimport demo::lang::Pico::Assembly;\nimport demo::lang::Pico::Load;\n\nalias Instrs = list[Instr]; \n\n// compile Expressions.\n\nInstrs compileExp(natCon(int N)) = [pushNat(N)]; \n\nInstrs compileExp(strCon(str S)) = [pushStr(substring(S,1,size(S)-1))];\n\nInstrs compileExp(id(PicoId Id)) = [rvalue(Id)];\n\npublic Instrs compileExp(add(EXP E1, EXP E2)) = \n  [*compileExp(E1), *compileExp(E2), add2()];\n\nInstrs compileExp(sub(EXP E1, EXP E2)) =\n  [*compileExp(E1), *compileExp(E2), sub2()];\n\nInstrs compileExp(conc(EXP E1, EXP E2)) =\n  [*compileExp(E1), *compileExp(E2), conc2()];\n\n// Unique label generation\n\nprivate int nLabel = 0; \n\nprivate str nextLabel() {\n  nLabel += 1;\n  return "L<nLabel>";\n}\n\n// Compile a statement\n\nInstrs compileStat(asgStat(PicoId Id, EXP Exp)) =\n    [lvalue(Id), *compileExp(Exp), assign()];\n\nInstrs compileStat(ifElseStat(EXP Exp, \n                              list[STATEMENT] Stats1,\n                              list[STATEMENT] Stats2)){\n\n  elseLab = nextLabel();\n  endLab = nextLabel();\n  return [*compileExp(Exp),\n          gofalse(elseLab),\n          *compileStats(Stats1),\n          go(endLab),\n          label(elseLab),\n          *compileStats(Stats2),\n          label(endLab)];\n}\n\nInstrs compileStat(whileStat(EXP Exp,\n                             list[STATEMENT] Stats1)) {\n  entryLab = nextLabel();\n  endLab = nextLabel();\n  return [label(entryLab),\n          *compileExp(Exp),\n          gofalse(endLab),\n          *compileStats(Stats1),\n          go(entryLab),\n          label(endLab)];\n}\n\n// Compile a list of statements\nInstrs compileStats(list[STATEMENT] Stats1) = \n  [ *compileStat(S) | S <- Stats1 ];\n\n// Compile declarations\n\nInstrs compileDecls(list[DECL] Decls) =\n  [ ((tp == natural()) ? dclNat(Id) : dclStr(Id)) | \n    decl(PicoId Id, TYPE tp) <- Decls\n  ];\n\n// Compile a Pico program\n\npublic Instrs compileProgram(PROGRAM P){ \n  nLabel = 0;\n  if(program(list[DECL] Decls, list[STATEMENT] Series) := P){\n     return [*compileDecls(Decls), *compileStats(Series)];\n  } else\n    throw "Cannot happen";\n}\n\npublic Instrs compileProgram(str txt) = compileProgram(load(txt));\n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We introduce ",(0,l.kt)("inlineCode",{parentName:"p"},"Instrs")," as an alias for a list of assembly language instructions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The compiler consists of the functions ",(0,l.kt)("inlineCode",{parentName:"p"},"compileExp"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"compileStat"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"compileStats"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"compileDecls")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"compileProgram"),". They all have a program fragment as argument and return the corresponding list of instructions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"When compiling expressions, note how ",(0,l.kt)("em",{parentName:"p"},"list splicing")," (see ","[","Rascal:Values/List","]",") is used to insert the instructions\nthat are generated for the operands of an operator into the list of instructions for the whole expression.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In order to conveniently write code generators for statements, we introduce a unique label generator. The global\nvariable ",(0,l.kt)("inlineCode",{parentName:"p"},"nLabel")," contains the index of the last generated label and ",(0,l.kt)("inlineCode",{parentName:"p"},"nextLabel")," uses this to generate a new, unique\nlabel.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Consider code generation for an if-the-else statement:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Two fresh labels mark the start of the code for the else part (",(0,l.kt)("inlineCode",{parentName:"p"},"elseLab"),") and the end of the whole statement\n(",(0,l.kt)("inlineCode",{parentName:"p"},"endLab"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The code that is generated consists of the following:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Code for the test.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A gofalse to the code for the else-part.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Code for the then-part and a jump to the end of the statement.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Code for the else-part that starts with the label ",(0,l.kt)("inlineCode",{parentName:"p"},"elsePart"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The label ",(0,l.kt)("inlineCode",{parentName:"p"},"endLab")," that marks the end of the code for the if-then-else statement.")))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Compiling a list of statements conveniently uses a list comprehension and list splicing.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Compiling declarations allocates memory locations of the appropriate type for each declared variable.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"compileProgram")," compiles a gives Pico program to assembly language."))),(0,l.kt)("p",null,"Here is an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Pico::Compile;\ncompileProgram("begin declare x : natural; x := 47 end");\n')),(0,l.kt)("p",null,"Here is the compilation of the factorial program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"compileProgram(\"begin declare input : natural,\n               '              output : natural,\n               '             repnr : natural,\n               '              rep : natural;\n               '      input := 14;\n               '      output := 1;\n               '      while input - 1 do\n               '          rep := output;\n               '          repnr := input;\n               '          while repnr - 1 do\n               '             output := output + rep;\n               '             repnr := repnr - 1\n               '          od;\n               '          input := input - 1\n               '      od\n               'end\");\n")),(0,l.kt)("h3",{id:"controlflow"},"ControlFlow"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Compute the control flow graph for a Pico program."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"A control flow graph shows how the entry and exit points of a program are connected with each other via all decision\npoints and statements in the program. Typically, an assignment statement is a single node in the graph and an\nif-then-else statement creates a decision point (its test) that connects the then branch and the else branch. The exits\nof each branch are connected to the exit of the if-then-else statement as a whole."),(0,l.kt)("p",null,"A control flow graph for Pico programs can be created as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Pico::ControlFlow\n\nimport analysis::graphs::Graph;\nimport demo::lang::Pico::Abstract;\nimport demo::lang::Pico::Load;\nimport List;\n\npublic data CFNode \n    = entry(loc location)\n    | exit()\n    | choice(loc location, EXP exp)\n    | statement(loc location, STATEMENT stat);\n\nalias CFGraph = tuple[set[CFNode] entry, Graph[CFNode] graph, set[CFNode] exit]; \n\nCFGraph cflowStat(s:asgStat(PicoId Id, EXP Exp)) { \n   S = statement(s@location, s);\n   return <{S}, {}, {S}>;\n}\n\nCFGraph cflowStat(ifElseStat(EXP Exp,                  \n                              list[STATEMENT] Stats1,\n                              list[STATEMENT] Stats2)){\n   CF1 = cflowStats(Stats1);\n   CF2 = cflowStats(Stats2);\n   E = {choice(Exp@location, Exp)};\n   return < E, (E * CF1.entry) + (E * CF2.entry) + CF1.graph + CF2.graph, CF1.exit + CF2.exit >;\n}\n\nCFGraph cflowStat(whileStat(EXP Exp, list[STATEMENT] Stats)) { \n   CF = cflowStats(Stats);\n   E = {choice(Exp@location, Exp)};\n   return < E, (E * CF.entry) + CF.graph + (CF.exit * E), E >;\n}\n\nCFGraph cflowStats(list[STATEMENT] Stats){ \n  if(size(Stats) == 1) {\n     return cflowStat(Stats[0]);\n  }\n\n  CF1 = cflowStat(Stats[0]);\n  CF2 = cflowStats(tail(Stats));\n\n  return < CF1.entry, CF1.graph + CF2.graph + (CF1.exit * CF2.entry), CF2.exit >;\n}\n\nCFGraph cflowProgram(PROGRAM P:program(list[DECL] _, list[STATEMENT] Series)){ \n   CF = cflowStats(Series);\n   Entry = entry(P@location);\n   Exit  = exit();\n\n   return <{Entry}, ({Entry} * CF.entry) + CF.graph + (CF.exit * {Exit}), {Exit}>;\n}\n\npublic CFGraph cflowProgram(str txt) = cflowProgram(load(txt)); \n")),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First we define a data type ",(0,l.kt)("inlineCode",{parentName:"p"},"CFNODE")," that represents the various elements of a control flow graph:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"entry"),": the entry point of the program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"exit")," the exit point of the program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"choice"),": a decision point in the control flow.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"statement"),": a statement in the control flow.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Next we define ",(0,l.kt)("inlineCode",{parentName:"p"},"CFGRAPH")," , an alias for a tuple consisting of the following three elements:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"entry"),": the set of entry nodes of the graph.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"graph"),": the actual graph of ","`","CFNODE","`","s.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"exit"),": the set of exit nodes."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"}," The computation of the control flow graph is defined by the functions\n`cflowStat`, `cflowStats`, `cflowDecls` and `cflowProgram`.\n"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The control flow of an assignment statement is computed by wrapping the assignment statement as a ",(0,l.kt)("inlineCode",{parentName:"p"},"CFNODE")," and\nreturn a ",(0,l.kt)("inlineCode",{parentName:"p"},"CFGRAPH")," with the assignment statement as entry and exit node, and no internal connections.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The control flow of an if-then-else statement is computed as follows:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First the control flows of the then part and the else part are computed, yielding ",(0,l.kt)("inlineCode",{parentName:"p"},"CF1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"CF2"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Next a set ",(0,l.kt)("inlineCode",{parentName:"p"},"E")," is created that consist of a the test of the if-then-else statement wrapped as choice node.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Finally, a ",(0,l.kt)("inlineCode",{parentName:"p"},"CFGRAPH")," is returned consisting of the followng three elements:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The entry point set ",(0,l.kt)("inlineCode",{parentName:"p"},"E"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A graph consisting of the connections between the entry point and both branches (",(0,l.kt)("inlineCode",{parentName:"p"},"E * CF1.entry + E *\nCF2.entry"),") and the internal graphs of both branches (",(0,l.kt)("inlineCode",{parentName:"p"},"CF1.graph + CF2.graph"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The union of exit nodes of both branches (",(0,l.kt)("inlineCode",{parentName:"p"},"CF1.exit + CF2.exit"),").")))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The control flow of while-statement is computed in a similar fashion, except that the exit of the loop body has to\nbe connected with the entry of the while loop.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The control flow graph for a series of statements is obtained by connecting the exits and entries of consecutive\nstatements.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The control flow graph of a complete program is obtained by creating an entry and an exit node and connecting them\nto the graph of the statements of the program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Shows the steps from text to control flow graph."))),(0,l.kt)("p",null,"We can now create a CFG for a small Pico program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Pico::ControlFlow;\ncflowProgram("begin declare n : natural, s : string; n := 10; s := \\"a\\"; while n do s := s + \\"a\\"; n := n - 1 od end");\n')),(0,l.kt)("p",null,"Is the above not very motivating to move on to ",(0,l.kt)("a",{parentName:"p",href:"#Pico-Visualize"},"Visualize"),"?"),(0,l.kt)("h3",{id:"evaluate"},"Evaluate"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Evaluate a Pico program."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"A complete evaluator (interpreter) for Pico is defined below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Pico::Eval\n\nimport demo::lang::Pico::Abstract;\nimport demo::lang::Pico::Load;\n\ndata PicoValue = natval(int n) | strval(str s) | errorval(loc l, str msg); \n\nalias VENV = map[PicoId, PicoValue]; \n\n// Evaluate Expressions.\n\nPicoValue evalExp(exp:natCon(int N), VENV env) = natval(N);\n\nPicoValue evalExp(exp:strCon(str S), VENV env) = strval(S);\n\nPicoValue evalExp(exp:id(PicoId Id), VENV env)  =\n    env[Id]?  ? env[Id] : errorval(exp@location, "Uninitialized variable <Id>");\n\nPicoValue evalExp(exp:add(EXP E1, EXP E2), VENV env) =\n   (natval(n1) := evalExp(E1, env) &&\n    natval(n2) := evalExp(E2, env)) ? natval(n1 + n2)\n                                    : errorval(exp@location, "+ requires natural arguments");\n\nPicoValue evalExp(exp:sub(EXP E1, EXP E2), VENV env) =\n   (natval(n1) := evalExp(E1, env) &&\n    natval(n2) := evalExp(E2, env)) ? natval(n1 - n2)\n                                    : errorval(exp@location, "- requires natural arguments");\n\nPicoValue evalExp(exp:conc(EXP E1, EXP E2), VENV env) =\n   (strval(s1) := evalExp(E1, env) &&\n    strval(s2) := evalExp(E2, env)) ? strval(s1 + s2)\n                                    : errorval(exp@location, "|| requires string arguments");\n\n// Evaluate a statement\n\nVENV evalStat(stat:asgStat(PicoId Id, EXP Exp), VENV env) {\n  env[Id] = evalExp(Exp, env);\n  return env;\n}\n\nVENV evalStat(stat:ifElseStat(EXP Exp,\n                              list[STATEMENT] Stats1,\n                              list[STATEMENT] Stats2),\n              VENV env) =\n  evalStats(evalExp(Exp, env) != natval(0) ? Stats1 : Stats2, env);\n\nVENV evalStat(stat:whileStat(EXP Exp,\n                             list[STATEMENT] Stats1),\n              VENV env) {\n    while(evalExp(Exp, env) != natval(0)){\n       env = evalStats(Stats1, env);\n    }\n    return env;\n}\n\n// Evaluate a list of statements\nVENV evalStats(list[STATEMENT] Stats1, VENV env) {\n  for(S <- Stats1){\n      env = evalStat(S, env);\n  }\n  return env;\n}\n\n// Eval declarations\n\nVENV evalDecls(list[DECL] Decls) =\n    ( Id : (tp == demo::lang::Pico::Abstract::natural() ? natval(0) : strval(""))\n    | decl(PicoId Id, TYPE tp) <- Decls\n    );\n\n// Evaluate a Pico program\n\npublic VENV evalProgram(PROGRAM P){\n  if(program(list[DECL] Decls, list[STATEMENT] Series) := P){\n     VENV env = evalDecls(Decls);\n     return evalStats(Series, env);\n  } else\n    throw "Cannot happen";\n}\n\npublic VENV evalProgram(str txt) = evalProgram(load(txt));\n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First we introduce a data type ",(0,l.kt)("inlineCode",{parentName:"p"},"PicoValue")," that wraps all possible values that can occur at run-time.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Compared to ","[","Pico/Typecheck","]",", we use ",(0,l.kt)("inlineCode",{parentName:"p"},"VENV"),", a value environment (a map from Pico identifiers to Pico values)."),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The actual evaluator consists of the functions ",(0,l.kt)("inlineCode",{parentName:"p"},"evalExp"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"evalStat"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"evalStats"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"evalDecls")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"evalProgram"),". They are written in a similar style as the typechecker.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"evalProgram")," evaluates a given Pico program."))))),(0,l.kt)("p",null,"Here is how to evaluate a Pico program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Pico::Eval;\nevalProgram("begin declare x : natural, y : natural; x := 1; y := x + 5 end");\n')),(0,l.kt)("h3",{id:"ide"},"IDE"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"An Integrated Development Environment for Pico."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"Unresolved directive in Languages/Pico/IDE/IDE.adoc - include::/mnt/c/dev/projects/usethesource/rascal/src/org/rascalmpl/library/demo/lang/Pico/Plugin.rsc[tags=module]\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First the name of the language and its file name extension are defined (/images/1.png).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Next the connection with the parser (/images/3.png), evaluator\n(/images/6.png) are defined.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"(/images/7.png) combines the above into a set of contributions to the Pico IDE.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The actual creation of the Pico IDE is done by ",(0,l.kt)("inlineCode",{parentName:"p"},"registerPico")," (/images/8.png) that:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Registers the Pico language with name, file name extension and Parser. Whenever a user clicks on a ",(0,l.kt)("inlineCode",{parentName:"p"},".pico")," file\nan editor will opened and the parsed file will be displayed in it.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Registers ",(0,l.kt)("em",{parentName:"p"},"annotators")," for Pico programs. Annotators run whenever a change is made to a Pico program in an open\neditor.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Registers contributions to the context menu in the editor. When the user right-clicks, the context menu pops up\nand it will show a Pico entry with actions defined in the contributions."))))),(0,l.kt)("p",null,'Let\u2019s write a Pico program that produces a string of "a"s:'),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"screen 1",src:n(7143).Z,width:"732",height:"420"})),(0,l.kt)("p",null,"As can be seen in the editor above, we get an error since we made a typo (missing comma) in the declarations. We correct\nit:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"screen 2",src:n(1824).Z,width:"729",height:"421"})),(0,l.kt)("p",null,"Now it turns out that we had erroneously used the ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," operator on strings (it should be ",(0,l.kt)("inlineCode",{parentName:"p"},"||"),"). We correct it:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"screen 3",src:n(1830).Z,width:"733",height:"420"})),(0,l.kt)("p",null,"Now we get a warning that variable ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," is not initialized. We correct it and get an error-free and warning-free program:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"screen 4",src:n(8620).Z,width:"434",height:"193"})),(0,l.kt)("h3",{id:"load"},"Load"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Convert a Pico parse tree into a Pico abstract syntax tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The mapping between parse tree and abstract sybtax tree is achieved as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"}," module demo::lang::Pico::Load\n\nimport Prelude;\nimport demo::lang::Pico::Syntax;\nimport demo::lang::Pico::Abstract;\n\npublic PROGRAM  load(str txt) = implode(#PROGRAM, parse(#Program, txt));\n")),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"load")," takes a string as argument (supposedly the source code of a Pico program) and returns a value of\ntype ",(0,l.kt)("inlineCode",{parentName:"p"},"PROGRAM"),", the abstract syntax tree of the input program. In case the input program is syntactically incorrect,\na ",(0,l.kt)("inlineCode",{parentName:"p"},"ParseError")," exception will be thrown, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#runtimeexception"},"RuntimeException"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"parse(#Program, txt)"),": parse ",(0,l.kt)("inlineCode",{parentName:"p"},"txt")," according to the non-terminal ",(0,l.kt)("inlineCode",{parentName:"p"},"Program"),". Note that ",(0,l.kt)("inlineCode",{parentName:"p"},"#Program")," is a ",(0,l.kt)("em",{parentName:"p"},"reified\ntype"),", i.e., the type ",(0,l.kt)("inlineCode",{parentName:"p"},"Program")," is represented as an ordinary Rascal value and passed as argument to the ",(0,l.kt)("inlineCode",{parentName:"p"},"parse"),"\nfunction, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#ReifiedTypes"},"reified types"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," function returns a parse tree of the input\nprogram.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"implode(#PROGRAM, parse(#Program, txt))"),": transform the parse returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"parse")," into an abstract syntax tree of\ntype ",(0,l.kt)("inlineCode",{parentName:"p"},"PROGRAM"),". The ","[","$Rascal:implode","]"," function performs the automatic mapping between elements in the parse tree\nand their counterpart in the abstract syntax."))),(0,l.kt)("p",null,"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"load")," can be used as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Pico::Load;\nload("begin declare x : natural; x := 3 end");\n')),(0,l.kt)("p",null,"Observe how the various parts of the abstract syntax tree are annotated with location attributes."),(0,l.kt)("h3",{id:"syntax-1"},"Syntax"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Concrete syntax for Pico."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Pico::Syntax\n\nimport ParseTree;\n\nlexical Id  = [a-z][a-z0-9]* !>> [a-z0-9];\nlexical Natural = [0-9]+ ;\nlexical String = "\\"" ![\\"]*  "\\"";\n\nlayout Layout = WhitespaceAndComment* !>> [\\ \\t\\n\\r%];\n\nlexical WhitespaceAndComment\n   = [\\ \\t\\n\\r]\n   | @category="Comment" ws2: "%" ![%]+ "%"\n   | @category="Comment" ws3: "%%" ![\\n]* $\n   ;\n\nstart syntax Program\n   = program: "begin" Declarations decls {Statement  ";"}* body "end" ;\n\nsyntax Declarations\n   = "declare" {Declaration ","}* decls ";" ;\n\nsyntax Declaration = decl: Id id ":" Type tp;\n\nsyntax Type\n   = natural:"natural"\n   | string :"string"\n   ;\n\nsyntax Statement\n   = asgStat: Id var ":="  Expression val\n   | ifElseStat: "if" Expression cond "then" {Statement ";"}*  thenPart "else" {Statement ";"}* elsePart "fi"\n   | whileStat: "while" Expression cond "do" {Statement ";"}* body "od"\n  ;\n\nsyntax Expression\n   = id: Id name\n   | strCon: String string\n   | natCon: Natural natcon\n   | bracket "(" Expression e ")"\n   > left conc: Expression lhs "||" Expression rhs\n   > left ( add: Expression lhs "+" Expression rhs\n          | sub: Expression lhs "-" Expression rhs\n          )\n  ;\n\npublic start[Program] program(str s) {\n  return parse(#start[Program], s);\n}\n\npublic start[Program] program(str s, loc l) {\n  return parse(#start[Program], s, l);\n}\n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"Id"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"Natural")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"String")," are the basic lexical tokens of the Pico language.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"Layout")," defines the white space and comments that may occur in a Pico program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Some lexical rules are labeled with ",(0,l.kt)("inlineCode",{parentName:"p"},'@category="Comment"'),". This is for the benefit of syntax highlighting.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The start symbol of the Pico grammar is called ",(0,l.kt)("inlineCode",{parentName:"p"},"Program"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The rules for ",(0,l.kt)("inlineCode",{parentName:"p"},"Expression")," describe the priority and associativity of the operators: all operators are\nleft-associative and ",(0,l.kt)("inlineCode",{parentName:"p"},"||")," has a higher priority then ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"-"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Two auxiliary functions ",(0,l.kt)("inlineCode",{parentName:"p"},"program")," are defined that parse a given string or a given location as Pico program."))),(0,l.kt)("h3",{id:"typecheck"},"Typecheck"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Typechecker for Pico programs."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Recall the following properties of Pico that are relevant for type checking:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There are two types: natural numbers and strings.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Variables have to be declared.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Expressions may contain naturals, strings, variables, addition (",(0,l.kt)("inlineCode",{parentName:"p"},"+"),"), subtraction (",(0,l.kt)("inlineCode",{parentName:"p"},"-"),") and concatenation (",(0,l.kt)("inlineCode",{parentName:"p"},"||"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The operators ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"-")," have operands of type natural and their result is natural.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The operator ",(0,l.kt)("inlineCode",{parentName:"p"},"||")," has operands of type string and its results is also of type string.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Tests in if-then-else statement and while-statement should be of type natural."))),(0,l.kt)("p",null,"The type checker is going to check these rules and will produce an error message when they are violated."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Pico::Typecheck\n\nimport Prelude;\nimport demo::lang::Pico::Abstract;\nimport demo::lang::Pico::Load;\n\nalias TENV = tuple[ map[PicoId, TYPE] symbols, list[tuple[loc l, str msg]] errors]; \n\nTENV addError(TENV env, loc l, str msg) = env[errors = env.errors + <l, msg>]; \n\nstr required(TYPE t, str got) = "Required <getName(t)>, got <got>"; \nstr required(TYPE t1, TYPE t2) = required(t1, getName(t2));\n\n// compile Expressions.\n\nTENV checkExp(exp:natCon(int N), TYPE req, TENV env) = \n  req == natural() ? env : addError(env, exp@location, required(req, "natural"));\n\nTENV checkExp(exp:strCon(str S), TYPE req, TENV env) =\n req == string() ? env : addError(env, exp@location, required(req, "string"));\n\nTENV checkExp(exp:id(PicoId Id), TYPE req, TENV env) { \n  if(!env.symbols[Id]?)\n     return addError(env, exp@location, "Undeclared variable <Id>");\n  tpid = env.symbols[Id];\n  return req == tpid ? env : addError(env, exp@location, required(req, tpid));\n}\n\nTENV checkExp(exp:add(EXP E1, EXP E2), TYPE req, TENV env) = \n  natural() := req ? checkExp(E1, natural(), checkExp(E2, natural(), env))\n                   : addError(env, exp@location, required(req, "natural"));\n\nTENV checkExp(exp:sub(EXP E1, EXP E2), TYPE req, TENV env) = \n  natural() := req ? checkExp(E1, natural(), checkExp(E2, natural(), env))\n                   : addError(env, exp@location, required(req, "natural"));\n\nTENV checkExp(exp:conc(EXP E1, EXP E2), TYPE req, TENV env) = \n  string() := req ? checkExp(E1, string(), checkExp(E2, string(), env))\n                   : addError(env, exp@location, required(req, "string"));\n\n\n// check a statement\n\nTENV checkStat(stat:asgStat(PicoId Id, EXP Exp), TENV env) { \n  if(!env.symbols[Id]?)\n     return addError(env, stat@location, "Undeclared variable <Id>");\n  tpid = env.symbols[Id];\n  return checkExp(Exp, tpid, env);\n}\n\nTENV checkStat(stat:ifElseStat(EXP Exp, \n                              list[STATEMENT] Stats1,\n                              list[STATEMENT] Stats2),\n               TENV env){\n    env0 = checkExp(Exp, natural(), env);\n    env1 = checkStats(Stats1, env0);\n    env2 = checkStats(Stats2, env1);\n    return env2;\n}\n\nTENV checkStat(stat:whileStat(EXP Exp,\n                             list[STATEMENT] Stats1),\n                 TENV env) {\n    env0 = checkExp(Exp, natural(), env);\n    env1 = checkStats(Stats1, env0);\n    return env1;\n}\n\n// check a list of statements\nTENV checkStats(list[STATEMENT] Stats1, TENV env) { \n  for(S <- Stats1){\n      env = checkStat(S, env);\n  }\n  return env;\n}\n\n// check declarations\n\nTENV checkDecls(list[DECL] Decls) = \n    <( Id : tp | decl(PicoId Id, TYPE tp) <- Decls), []>;\n\n// check a Pico program\n\npublic TENV checkProgram(program(list[DECL] Decls, list[STATEMENT] Series)) { \n    return checkStats(Series, checkDecls(Decls));\n}\n                                                         \npublic list[tuple[loc l, str msg]] checkProgram(str txt) = checkProgram(load(txt)).errors;\n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We will use ",(0,l.kt)("inlineCode",{parentName:"p"},"TENV")," (short for type environment, as an alias for a tuple that contains all relevant type information:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"symbols"),": a map from Pico identifiers to their declared type.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"errors"),": a list of error messages. An error message is represented by its location (where the error occurred)\nand a textual message.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"addError")," is an auxiliary function to add in a given type environment an error message to the list of errors. It\nreturns a new type environment.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},'required`is an auxiliarty function to produce readable messages, e.g., `"Required natural, got string"'),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The actual type checking is done by the functions ",(0,l.kt)("inlineCode",{parentName:"p"},"checkExp"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"checkStat"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"checkStats"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"checkDecls")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"checkProgram"),". They all have three arguments:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"the program fragment (an abstract syntax tree) to be checked.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"the required type of that fragment.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"the type environment."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"`checkExp` checks expressions. For instance, checking a natural constant (`natCon`) is ok when type `natural` is expected but will give an error message when a `string` is expected. Observe how all the arguments of the check functions have a labeled pattern as first argument, here `exp:natCon(int N)`. The benefit is that the whole argument is available inside the function (as value of variable `exp`) and this can be used to retrieve the location information from it (`exp@location`) when an error has to be created.\n"))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An important case is to check whether an identifier has been defined and, if so, whether it is defined with the\nexpected type.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Check ",(0,l.kt)("inlineCode",{parentName:"p"},"add"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Check ",(0,l.kt)("inlineCode",{parentName:"p"},"sub"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Check ",(0,l.kt)("inlineCode",{parentName:"p"},"conc"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An assignment statement is checked: the identifier on the left-hand side should have been declared and should be\ntype compatible with the expression on the right-hand side.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Checking if- and while-statements amounts to checking the embedded statements and ensuring that the type of the test\nis natural.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Checking a list of statements amounts to checking each statement in the list.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Checking declarations amounts to extracting each (id, type) pair form the declarations and using a map comprehension\nto build a type environment.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Checking a complete Pico program is achieved by first checking the declarations of the program and using the\nresulting type environment to check its body.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"checkProgram")," defines how to check the source code of a given Pico program."))),(0,l.kt)("p",null,"Checking an erroneous program goes like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Pico::Typecheck;\ncheckProgram("begin declare  x : natural; x := \\"abc\\" end");\n')),(0,l.kt)("p",null,"The error location will be use later to give specific messages in the IDE."),(0,l.kt)("h3",{id:"uninit"},"Uninit"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Find unitialized variables in a Pico program."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Uninitialized variables are variables that are used without being initialized. This means that there is a path in the\ncontrol flow graph from the entry point of the program to a specific use of a variable, where that path does not contain\na definition of that variable."),(0,l.kt)("p",null,"This can be computed as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Pico::Uninit\n\nimport demo::lang::Pico::Abstract;\nimport demo::lang::Pico::Load;\n\nimport demo::lang::Pico::UseDef;\nimport demo::lang::Pico::ControlFlow;\n\nimport analysis::graphs::Graph;\n\npublic set[CFNode] defNodes(PicoId Id, set[Occurrence] Defs) =\n   {statement(occ.stat@location, occ.stat) | Occurrence occ <- Defs, occ.name == Id};\n\npublic set[Occurrence] uninitProgram(PROGRAM P) {\n   D = defs(P); \n   CFG = cflowProgram(P); \n   return { occ | occ <- uses(P), \n                  any(CFNode N <- reachX(CFG.graph, CFG.entry, defNodes(occ.name, D)),\n                      N has location && occ.location <= N.location)\n          }; \n}\n\npublic set[Occurrence] uninitProgram(str txt) = uninitProgram(load(txt)); \n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"First, we determine the variable definitions of the program,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"and its control flow graph.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Next we ask for every use of a variable the question: can it be reached from the entries of the program without\nencountering a definition? This determined as follows:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"rangeR(D, {occ.item})")," is the set of definition for the variable were are looking at. See\n","[","Rascal:Relation/rangeR","]",".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"reachX")," determines the reachability in a graph while excluding certain nodes, see ","[","Rascal:Graph/reachX","]",". Here\n",(0,l.kt)("inlineCode",{parentName:"p"},"reachX(CFG.graph, CFG.entry, rangeR(D, {occ.item}))")," determines the nodes in the graph that can be reached from\nthe entry point of the program without passing a definition of the current variable.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"any(CFNode N \u2190 reachX( \u2026\u200b ), N has location && occ.location <= N.location)")," yields true if there is such a\nreachable node that covers the location of the current variable.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The complete comprehension returns the set of occurrences of uninitialized variables."))),(0,l.kt)("p",null,"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"uninitProgram")," performs this analysis on the source text of a Pico program."),(0,l.kt)("p",null,"Here is a simple example, where variable ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is used without intialization:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Pico::Uninit;\nuninitProgram("begin declare n : natural, m : natural, p : natural; n := 10; m := n + p end");\n')),(0,l.kt)("h3",{id:"usedef"},"UseDef"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Compute use-def information for the variables in a Pico program."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"definitions")," of a variable are the source code locations where a variable gets a value. The ",(0,l.kt)("em",{parentName:"p"},"uses")," of a variable\nare the location where the value of that variable is used. Both concepts are relevant for program analysis and are\ndefined here."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Pico::UseDef\n\nimport demo::lang::Pico::Abstract;\n\nset[Occurrence] usesExp(EXP e, STATEMENT s) =  \n  u:id(PicoId Id1) := e ? {< u@location, Id1, s>}\n                        : {< u@location, Id2, s> | /u:id(PicoId Id2) <- e };\n\nset[Occurrence] usesStat(s:asgStat(PicoId Id, EXP e)) = usesExp(e, s); \n\nset[Occurrence] usesStat(s: ifElseStat(EXP e,\n                              list[STATEMENT] s1,\n                              list[STATEMENT] s2)) =\n   usesExp(e, s) + usesStats(s1) + usesStats(s2);\n\nset[Occurrence] usesStat(s: whileStat(EXP e,\n                              list[STATEMENT] s1)) =\n   usesExp(e, s) + usesStats(s1);\n\nset[Occurrence] usesStats(list[STATEMENT] stats) =\n   {*usesStat(s) | s <- stats};\n\npublic set[Occurrence] uses(PROGRAM p) = usesStats(p.stats);  \n\npublic set[Occurrence] defs(PROGRAM p) =  \n   { < stat@location, v, stat > | /stat:asgStat(PicoId v, EXP _) <- p.stats};\n")),(0,l.kt)("p",null,"Recall that ",(0,l.kt)("inlineCode",{parentName:"p"},"Occurrence")," was introduced in ",(0,l.kt)("a",{parentName:"p",href:"#Pico-Abstract"},"Abstract"),"; it is a parameterized container to associate\nprogram entities with their location."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"usesExp")," computes a set of occurrences (uses) of Pico identifiers in a given statement:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If the expression is itself an identifier, then a singleton set containing that identifier and the statement is\nreturned.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If the expression is composite, all its containing identifiers are collected using a descendant (deep) match\n(",(0,l.kt)("inlineCode",{parentName:"p"},"/"),", see ","[","Rascal:Descendant","]",")) in ",(0,l.kt)("inlineCode",{parentName:"p"},"/u:id(PicoId Id) <- e"),". Note that we use a labeled pattern ",(0,l.kt)("inlineCode",{parentName:"p"},"u:id(PicoId\nId)"),", so that we can access the whole expression that was matched and retrieve its location information\n(",(0,l.kt)("inlineCode",{parentName:"p"},"u@location"),") when we are adding a \\<location, identifier",">"," pair to the set of occurrences.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"useStat")," extracts uses from all statement variants.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"uses")," simply applies ",(0,l.kt)("inlineCode",{parentName:"p"},"usesStats")," to the statement part of its program argument.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The function ",(0,l.kt)("inlineCode",{parentName:"p"},"defs")," has a Pico program as argument and returns a set of occurrences (definitions) of Pico\nidentifiers. The definition consists of a single set comprehension that consists of the following parts:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"`"," \u2026\u200b \\<- P. stats","`"," enumerates all statements in the program.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"/asgStat(PicoId Id, EXP Exp) <- P.stats")," uses again a descendant match to find all assignment statements.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"For each assignment statement a (location, identifier) pair is added to the result."))))),(0,l.kt)("h3",{id:"visualize"},"Visualize"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Visualize Pico Control Flow Graphs."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},"Warning")),(0,l.kt)("p",{parentName:"blockquote"},"The visualization library is being reimplemented and reorganized; the information provided here maybe inaccurate or\neven incorrect.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"Unresolved directive in Languages/Pico/Visualize/Visualize.adoc - include::/mnt/c/dev/projects/usethesource/rascal/src/org/rascalmpl/library/demo/lang/Pico/Visualize.rsc[tags=module]\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We want to include the text of expressions in the relevant Figure nodes, this is achieved by ",(0,l.kt)("inlineCode",{parentName:"p"},"make"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An editor property is attached to each Figure node: clicking on the node opens an editor for the corresponding file.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"visNode")," implements the visualization per CFG node.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Since Figure nodes in a visual graph need an ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property, we define here a scheme to associate unique identifiers\nto each Figure node.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The complete visualization of a CFG is implemented by ",(0,l.kt)("inlineCode",{parentName:"p"},"visCFG"),": it gets the CFG graph as arguments and then"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"creates all Figure edges,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"creates all Figure nodes,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"returns a Figure graph."))))),(0,l.kt)("p",null,"Let\u2019s now apply this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'                import demo::lang::Pico::ControlFlow;\nimport demo::lang::Pico::Visualize;\nCFG = cflowProgram("begin declare n : natural, s : string; n := 10; s := \\"a\\"; while n do s := s + \\"a\\"; n := n - 1 od end");\nrender(visCFG(CFG.graph));\n')),(0,l.kt)("p",null,"The resulting visualization looks like this:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Control flow graph",src:n(8393).Z,width:"209",height:"258"})),(0,l.kt)("h2",{id:"metrics"},"Metrics"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Computing"),(0,l.kt)("h3",{id:"measuring-java"},"Measuring Java"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"A few steps using the M3 model to compute basic metrics for a Java project in Eclipse"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"This is a recipe for computing basic or more advanced metrics from a Java project in Eclipse. We assume:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"You have Rascal installed in an Eclipse instance.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"You have a Java project in your Eclipse workspace that compiles without errors. Let\u2019s call it ",(0,l.kt)("inlineCode",{parentName:"p"},"HelloWorld"),"."))),(0,l.kt)("p",null,"Now we will follow the ",(0,l.kt)("a",{parentName:"p",href:"/docs/WhyRascal#easy"},"EASY")," paradigm:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a library will be used to ",(0,l.kt)("em",{parentName:"p"},"parse")," the Java code generating ","[","Rascalopedia:AbstractSyntaxTree","]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"the same library will generate a ","[","Rascal:Values/Relation","]","al model to represent interesting facts between Java\nsource code artifacts")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"then we can write queries over the generated trees and relations using ","[","Rascal:Expressions","]","."))),(0,l.kt)("p",null,"These are a number of recipes for measuring different things about Java:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"[","MeasuringClasses","]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"[","MeasuringMethods","]"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,l.kt)("p",null,"First we import the basic data types for representing Java. The model is called ",(0,l.kt)("em",{parentName:"p"},"M3"),", and its definition is split acros\na generic language independent module called ","[","Rascal:analysis/m3/Core","]"," and a Java specific part called\n","[","Rascal:lang/java/m3/Core","]",". Have a look at the documentation of these modules later. For now we will go through using\nthem in a few examples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import lang::java::m3::Core;\n")),(0,l.kt)("p",null,"Then we import the API for extracting an M3 model from an Eclipse project."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import lang::java::jdt::m3::Core;\n")),(0,l.kt)("p",null,"Calling the following function generates an enormous value representing everything the Eclipse Java compiler knows about\nthis project:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"myModel = createM3FromEclipseProject(|project://example-project|);\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Notice that ",(0,l.kt)("em",{parentName:"li"},"all")," these ","[","$Rascal:Values/Location","]"," literals are hyperlinks and you can click on them to go the\nsource code that they point to. Try it","!")),(0,l.kt)("h3",{id:"measuring-classes"},"Measuring Classes"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,l.kt)("p",null,"First we import the basic data types for representing Java. The model is called ",(0,l.kt)("em",{parentName:"p"},"M3"),", and its definition is split acros\na generic language independent module called ","[","Rascal:analysis/m3/Core","]"," and a Java specific part called\n","[","Rascal:lang/java/m3/Core","]",". Have a look at the documentation of these modules later. For now we will go through using\nthem in a few examples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import lang::java::m3::Core;\n")),(0,l.kt)("p",null,"Then we import the API for extracting an M3 model from an Eclipse project."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import lang::java::jdt::m3::Core;\n")),(0,l.kt)("p",null,"Calling the following function generates an enormous value representing everything the Eclipse Java compiler knows about\nthis project:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"myModel = createM3FromEclipseProject(|project://example-project|);\n")),(0,l.kt)("p",null,"Next, let\u2019s focus on the ",(0,l.kt)("em",{parentName:"p"},"containment")," relation. This defines what parts of the source code are parts of which other\nparts:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"myModel.containment\n")),(0,l.kt)("p",null,"As you can read, classes contain methods, methods contain variables, etc. Classes could also contain other classes\n(nested classes), and methods can even contain classes (anonymous classes). Let\u2019s focus on a specific class, and project\nwhat it contains from the relation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"myModel.containment[|java+class:///HelloWorld|]\n")),(0,l.kt)("p",null,"Let\u2019s filter the methods:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'helloWorldMethods = [ e | e <- myModel.containment[|java+class:///HelloWorld|], e.scheme == "java+method"];\n')),(0,l.kt)("p",null,"And we are ready to compute our first metric. How many methods does this class contain?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import List;\nsize(helloWorldMethods)\n")),(0,l.kt)("p",null,"No magic applied","!"," It is just a little query on a model that knows everything about the code. Let\u2019s generalize and\ncompute the number of methods for all classes in one big expression. First a function to compute the number for a given\nclass:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int numberOfMethods(loc cl, M3 model) = size([ m | m <- model.containment[cl], isMethod(m)]);\n")),(0,l.kt)("p",null,"then we apply this new function to give us a map from classes to integers:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"map[loc class, int methodCount] numberOfMethodsPerClass = (cl:numberOfMethods(cl, myModel) | <cl,_> <- myModel.containment, isClass(cl));\n")),(0,l.kt)("p",null,"how about the number of fields?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int numberOfFields(loc cl, M3 model) = size([ m | m <- model.containment[cl], isField(m)]);\nmap[loc class, int fieldCount] numberOfFieldsPerClass = (cl:numberOfFields(cl, myModel) | <cl,_> <- myModel.containment, isClass(cl));\n")),(0,l.kt)("p",null,"what is the ratio between fields and methods for each class?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(cl : (numberOfFieldsPerClass[cl] * 1.0) / (numberOfMethodsPerClass[cl] * 1.0) | cl <- classes(myModel))\n")),(0,l.kt)("h3",{id:"measuring-methods"},"Measuring Methods"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import lang::java::m3::Core;\nimport lang::java::jdt::m3::Core;\nimport lang::java::jdt::m3::AST;\n")),(0,l.kt)("p",null,"First extract our overview model"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"myModel = createM3FromEclipseProject(|project://example-project|);\n")),(0,l.kt)("p",null,"Now let\u2019s focus on the methods"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"myMethods = methods(myModel);\n")),(0,l.kt)("p",null,"What is the source code for a method?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\nmethodSrc = readFile(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|);\n")),(0,l.kt)("p",null,"let\u2019s print it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"println(methodSrc)\n")),(0,l.kt)("p",null,"how many words in this method?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(0 | it + 1 | /\\W+/ := methodSrc)\n")),(0,l.kt)("p",null,"let\u2019s get its AST"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"methodAST = getMethodASTEclipse(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|, model=myModel);\n")),(0,l.kt)("p",null,"Now we count the number of expressions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(0 | it + 1 | /Expression _ := methodAST)\n")),(0,l.kt)("p",null,"or give us the locations of all expressions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[m@src | /Expression m := methodAST]\n")),(0,l.kt)("p",null,"the size should be the same, right?"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import List;\nsize([m@src | /Expression m := methodAST]) == (0 | it + 1 | /Expression _ := methodAST)\n")),(0,l.kt)("h2",{id:"visualization"},"Visualization"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Recipes for creating visualizations."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},"Warning")),(0,l.kt)("p",{parentName:"blockquote"},"The visualization library is being reimplemented and reorganized; the information provided here maybe inaccurate or\neven incorrect")),(0,l.kt)("p",null,"We cover the following topics:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Visualization-ADT"},"ADT"),": Visualize an Algebraic Datatype as a tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Visualization-DrawLogo"},"Draw a Logo"),": Draw the Rascal logo.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Visualization-InteractiveBoxHeight"},"Interactive Box Height"),": Control the height of a box with user input.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Visualization-MyFirstBox"},"My First Box"),": Drawing a box in many variations.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Visualization-ParseTree"},"ParseTree"),": Visualize a parse tree.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#Visualization-PlayingWithProperties"},"Playing With Properties"),": Illustrate the effect of various figure properties."))),(0,l.kt)("h3",{id:"adt"},"ADT"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Visualize an Algebraic Datatype as a tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"In ",(0,l.kt)("a",{parentName:"p",href:"#ColoredTrees"},"???")," we have discussed the Algebraic Data Type ",(0,l.kt)("inlineCode",{parentName:"p"},"ColoredTree"),". Here we show how to create a\nvisualization for them. The global approach is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define a function ",(0,l.kt)("inlineCode",{parentName:"p"},"visColoredTree")," that has a ColoredTree as argument and creates a ",(0,l.kt)("inlineCode",{parentName:"p"},"Figure")," for it.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Display the resulting figure using ","[","$Rascal:Render/render","]","."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is our solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::vis::VisADT\n\n//import vis::Figure;\n//import vis::Render;\n//\n//data ColoredTree = leaf(int N)\n//                 | red(ColoredTree left, ColoredTree right)\n//                 | black(ColoredTree left, ColoredTree right)\n//                 | green(ColoredTree left, ColoredTree right)\n//                 ;\n//\n//Figure visColoredTree(leaf(int N)) =\n//  box(text("<N>"), gap(2), fillColor("lightyellow")); \n//\n//Figure visColoredTree(red(ColoredTree left, ColoredTree right)) =\n//  visNode("red", left, right); \n//\n//Figure visColoredTree(black(ColoredTree left, ColoredTree right)) =\n//  visNode("black", left, right);\n//\n//Figure visColoredTree(green(ColoredTree left, ColoredTree right)) =\n//  visNode("green", left, right);\n//\n//Figure visNode(str color, ColoredTree left, ColoredTree right) = \n//  tree(ellipse(fillColor(color)), [visColoredTree(left), visColoredTree(right)]);\n//\n//ColoredTree  rb = red(black(leaf(1), red(leaf(2),leaf(3))), green(leaf(3), leaf(4)));\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A ",(0,l.kt)("inlineCode",{parentName:"p"},"leaf")," is represented as its number converted to text, surrounded by a lightyellow box.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The figure for non-leaf nodes of a ColoredTree is generated by the auxiliary function ",(0,l.kt)("inlineCode",{parentName:"p"},"visNode"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"visNode")," represents the node itself as a ","[","$Rascal:Figures/tree","]"," that has a colored ellipse as root and the\nvisualization of two ColoredTrees as children."))),(0,l.kt)("p",null,"For the example ",(0,l.kt)("inlineCode",{parentName:"p"},"ColoredTree")," ",(0,l.kt)("inlineCode",{parentName:"p"},"rb")," we can set a standard (see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#std"},"/Libraries","#","std"),")\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#size"},"size")," and standard ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#gap"},"gap"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                import demo::vis::VisADT;\nrender(space(visColoredTree(rb), std(size(30)), std(gap(30))));\n")),(0,l.kt)("p",null,"and the result is:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"a1",src:n(3628).Z,width:"374",height:"298"})),(0,l.kt)("p",null,"Note that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We place the Figure that is produced by ",(0,l.kt)("inlineCode",{parentName:"p"},"viscoloredTree")," in a ",(0,l.kt)("inlineCode",{parentName:"p"},"space")," for the sole purpose that add extra properties\nto it.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"We use ",(0,l.kt)("inlineCode",{parentName:"p"},"std(size(30))")," and ","`"," std(gap(30))","`"," to achieve that these properties are set for all subfigures."))),(0,l.kt)("p",null,"Some further custumizations are possible. By default, the tree visualization uses\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#manhattan"},"manhattan")," style. If we turn it off"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                import demo::vis::VisADT;\nrender(space(visColoredTree(rb), std(size(30)), std(gap(30)), std(manhattan(false))));\n")),(0,l.kt)("p",null,"the result is:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"a2",src:n(9855).Z,width:"374",height:"298"})),(0,l.kt)("p",null,"It is also possible to change the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#orientation"},"orientation")," of the tree and draw it, for example,\nfrom left to right:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                import demo::vis::VisADT;\nrender(space(visColoredTree(rb), std(size(30)), std(gap(30)), std(orientation(leftRight()))));\n")),(0,l.kt)("p",null,"the result is:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"a3",src:n(8430).Z,width:"298",height:"374"})),(0,l.kt)("h3",{id:"draw-a-logo"},"Draw a Logo"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Draw the Rascal logo."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Given a 50x50 matrix containing the colors of the Rascal logo, we can reproduce it as visualization."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is the solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::vis::Logo\n\n//import vis::Figure;\n//import vis::Render;\n//\n//public list[int] LogoData = [\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xfff9f9f9, 0xff9d9c9e, 0xff616063, 0xffa3a2a4, 0xfffcfcfc, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xfff7f7f7, 0xff595759, 0xff121014, 0xff616063, 0xfffcfcfc, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xfffbfbfb, 0xff7f7e80, 0xff646163, 0xffc2c1c3, 0xfff7f7f7,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffdddddd, 0xff747375, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc1c0c1, 0xff8e8782, 0xffc6bdb2, 0xff908984, 0xff5b595a,\n//0xffcccccd, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xff565357, 0xffd7d7d7, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xfff3f3f3, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff504e4f, 0xffd3c9be, 0xffe2d7cb, 0xffe1d7cb, 0xffdfd4c9,\n//0xff4c4848, 0xffb5b5b7, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffdcdbdc, 0xff242226, 0xffdfdfdf, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff7f7e80, 0xff131115, 0xff636264, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc8c8c9, 0xff696360, 0xffeadfd2, 0xffbcb3aa, 0xffbbb2a9, 0xffdfd5c8,\n//0xffe5d9cd, 0xff645e5c, 0xffa09ea1, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xff7c7b7d, 0xff161418, 0xff9d9c9e, 0xfff9f9f9, 0xffffffff, 0xfffefefe, 0xffffffff,\n//0xfffefefe, 0xffffffff, 0xffe4e4e4, 0xffe5e5e5, 0xffffffff, 0xffffffff, 0xfff7f7f7, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff747274, 0xff0e0c10, 0xff09070c, 0xfffafafa, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff58575a, 0xffd5cbc0, 0xffe0d5c9, 0xffdfd4c8, 0xffb5ada4, 0xff948d87,\n//0xffede1d5, 0xffded4c8, 0xff7c7672, 0xff8c8b8d, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xfffefefe, 0xffffffff, 0xffffffff, 0xfff7f7f8, 0xff4a484b, 0xff151217, 0xff454447, 0xffe6e7e6, 0xffffffff, 0xffffffff,\n//0xffd8d7d8, 0xffd7d7d7, 0xffffffff, 0xffa3a2a4, 0xfff4f4f4, 0xffffffff, 0xffd5d4d5, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xfff7f7f7, 0xff939193, 0xff717072, 0xfffefefe, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xfff5f5f6, 0xff504d4f, 0xffede2d4, 0xffdfd5c9, 0xffe1d6ca, 0xffe8ddd1, 0xffa8a099,\n//0xff817b76, 0xffdfd5ca, 0xffe4dace, 0xff6a6562, 0xffc2c2c2, 0xffffffff, 0xfffefefe, 0xffffffff, 0xfffdfdfd, 0xffffffff,\n//0xffffffff, 0xffe3e3e4, 0xfff2f2f3, 0xffffffff, 0xffffffff, 0xff403d41, 0xff141217, 0xff131116, 0xff9a999b, 0xffd3d3d4,\n//0xffdfdfdf, 0xff59575a, 0xffc6c6c7, 0xff3a373b, 0xffecebec, 0xffdfdfdf, 0xffbcbcbd, 0xffeaeaea, 0xffdddcdd, 0xffeeedee,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffe2e1e2, 0xffa3a2a4, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffd0d0d1, 0xff8a8480, 0xffe8ded1, 0xffcbc1b7, 0xffaca49c, 0xffebe1d3, 0xffe7ddd0,\n//0xffbab1a8, 0xff827b76, 0xffe9ded1, 0xffdacfc4, 0xff4f4b4b, 0xffcccccd, 0xffffffff, 0xffffffff, 0xfffcfcfc, 0xffc1c0c1,\n//0xffffffff, 0xfffefefe, 0xffb4b3b5, 0xffcccccc, 0xfff9f8f8, 0xff211f24, 0xff2c2924, 0xff373323, 0xff0a0a13, 0xff0f0c11,\n//0xff18161a, 0xff1d1b1f, 0xff18161a, 0xff323034, 0xff666568, 0xff4b494c, 0xff838183, 0xff878688, 0xfff6f6f6, 0xffffffff,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffabaaac, 0xffbcbbbc, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffb5b5b6, 0xffaba39d, 0xffe2d8cc, 0xffdfd4c8, 0xffcec4ba, 0xff6b6563, 0xffc1b9af,\n//0xffe3d8cc, 0xffb1a8a0, 0xff6d6764, 0xffe8dcd0, 0xffd9cfc3, 0xff3f3c3e, 0xffebebeb, 0xffffffff, 0xffffffff, 0xffedeced,\n//0xff5d5c5f, 0xfff0f0f0, 0xffffffff, 0xff5d5b5e, 0xff312f32, 0xff2e2b24, 0xffe3d54c, 0xffe7d42d, 0xff625122, 0xff211e24,\n//0xff403e42, 0xff1a181c, 0xff1a181c, 0xff1a181c, 0xff1a181c, 0xff19161b, 0xff151317, 0xffa6a4a6, 0xff838284, 0xffa3a2a4,\n//0xffcfced0, 0xffffffff, 0xffffffff, 0xffffffff, 0xffefeeef, 0xff312f33, 0xfff1f1f1, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffa3a2a4, 0xffc3b9b0, 0xffe4d9cd, 0xffe2d7cb, 0xffe4dacd, 0xffe4d9ce, 0xff89827e,\n//0xff817a75, 0xffa9a199, 0xffa39a93, 0xff938b86, 0xffe1d6ca, 0xffb9b0a7, 0xff777577, 0xffffffff, 0xfffefefe, 0xffffffff,\n//0xffcfcecf, 0xff323134, 0xff858385, 0xff8e8d8f, 0xff1a181c, 0xffcdc262, 0xfff4df32, 0xff786320, 0xff8b898e, 0xffffffff,\n//0xffffffff, 0xffb0b0b1, 0xff171519, 0xff383417, 0xffcdc45f, 0xffa9a8a8, 0xff6a653a, 0xff161413, 0xff6c6a6f, 0xffcfcfcf,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xffe8e8e8, 0xff302e32, 0xff919092, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xff9b9a9b, 0xffc4bbb1, 0xffe3d8cb, 0xffbab1a8, 0xff918a84, 0xffb3aba2, 0xffe9ded1,\n//0xffdbcfc4, 0xffbab1a8, 0xff736e6b, 0xff403b3c, 0xffa29992, 0xffe6dbcf, 0xff77706c, 0xffa9a8aa, 0xffffffff, 0xfff9f9f9,\n//0xfff2f2f2, 0xffdddcdd, 0xff262327, 0xff13111a, 0xff989260, 0xfffcea49, 0xff8f7b1f, 0xff747374, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xff454346, 0xff131116, 0xffb2a947, 0xfffffb8f, 0xfffdee50, 0xffd7c826, 0xff26221a, 0xff211f24,\n//0xff5d5b5e, 0xfff6f6f7, 0xffdfdfe0, 0xff2e2c30, 0xff525154, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xff959394, 0xffc7bdb4, 0xffe0d6ca, 0xffe1d6ca, 0xffe1d6ca, 0xffa8a199, 0xff66615e,\n//0xffbab0a7, 0xffddd3c7, 0xffe4d9cd, 0xffc8bfb5, 0xff494545, 0xffbdb4ab, 0xffe6dbcf, 0xff363234, 0xffe1e0e1, 0xffffffff,\n//0xffa7a6a8, 0xff5f5d61, 0xff5e5d5f, 0xff2e2b20, 0xffe7dc7a, 0xffdfcb27, 0xff3b321c, 0xfff8f8f8, 0xffffffff, 0xffefefef,\n//0xfff9f9f9, 0xffffffff, 0xff9e9d9e, 0xff100e12, 0xff12111a, 0xffada123, 0xffcbbc25, 0xffaca125, 0xff474221, 0xff18161b,\n//0xff161419, 0xff2a282c, 0xff120f14, 0xff484649, 0xfff4f4f5, 0xfffefefe, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xff959495, 0xffc8beb4, 0xffe4d9cd, 0xffe1d7cb, 0xffdfd4c8, 0xffe7dccf, 0xffe1d6ca,\n//0xffa69e97, 0xff76706c, 0xffdfd5c8, 0xffe6dbcf, 0xffe4dace, 0xff7c7572, 0xffcac1b7, 0xffcbc1b7, 0xff636264, 0xfff9f9f9,\n//0xffffffff, 0xffc6c6c7, 0xff838284, 0xff635e38, 0xfffbee60, 0xffae9925, 0xff5a585a, 0xffffffff, 0xffffffff, 0xff545356,\n//0xff69686a, 0xfffcfcfc, 0xff939194, 0xff3f3418, 0xff19171b, 0xff14121b, 0xff161314, 0xff1c191d, 0xff151319, 0xff17151a,\n//0xff13111c, 0xff1c1819, 0xff2f2d30, 0xffc7c6c7, 0xffaeacae, 0xffe3e3e4, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xff9b9a9b, 0xffc4bab0, 0xffe3d8cc, 0xffded3c7, 0xffe3d9cc, 0xffe0d5ca, 0xffddd3c7,\n//0xffe2d7cb, 0xffccc3b9, 0xff3b3839, 0xffd5cbc0, 0xffdfd5c9, 0xffcfc4ba, 0xff847d79, 0xffe4d9cc, 0xff817a76, 0xffc3c2c3,\n//0xffffffff, 0xffffffff, 0xffabaaab, 0xff999351, 0xfffcec4a, 0xff7f6b23, 0xff85848b, 0xffffffff, 0xffffffff, 0xff383639,\n//0xff1b191d, 0xffc1c1c1, 0xff575558, 0xff947d21, 0xff23201c, 0xff1a181c, 0xff817f82, 0xffffffff, 0xffdfdee0, 0xff3d3a30,\n//0xffa59120, 0xff4c3a20, 0xff29262b, 0xff8b898b, 0xffededee, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffa5a5a7, 0xffc0b7ad, 0xffe3d8cb, 0xffe0d5c9, 0xffdacfc4, 0xffbfb5ad, 0xffb5ada4,\n//0xffd3c8bd, 0xffebdfd2, 0xffd0c6bb, 0xff55504f, 0xffc3bab0, 0xffe7dccf, 0xff97908a, 0xff918a84, 0xffdad0c4, 0xff484446,\n//0xfffafafa, 0xffffffff, 0xff676468, 0xffcbc375, 0xfff8e645, 0xff625122, 0xffa5a5aa, 0xffdad9d9, 0xfff5f5f5, 0xff323034,\n//0xff161418, 0xff939295, 0xff2f2920, 0xffd4bc2d, 0xff29261a, 0xff6c6a6d, 0xffffffff, 0xffffffff, 0xffffffff, 0xff575444,\n//0xffe9d223, 0xff33271c, 0xff413f43, 0xff89888a, 0xffa1a0a2, 0xffbfbfbf, 0xfff3f3f4, 0xffffffff, 0xfffefefe, 0xfffefefe,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffbcbcbe, 0xffa29b94, 0xffe4dacd, 0xffdfd5c9, 0xffe3d8cb, 0xffdcd2c6, 0xffd5cbc0,\n//0xff968f8a, 0xff645f5d, 0xff827b76, 0xff958e87, 0xff403d3d, 0xffc5bbb2, 0xffeadfd2, 0xff726b69, 0xffb2aaa1, 0xffa8a098,\n//0xff636266, 0xffffffff, 0xff2b292d, 0xffe4dd96, 0xfff9e744, 0xff655423, 0xffb3b3b8, 0xff727174, 0xff525054, 0xff1e1c20,\n//0xff18161a, 0xff4a4a52, 0xff665722, 0xffefdc30, 0xff2e2b1d, 0xfffdfdfd, 0xffeaeaea, 0xff515052, 0xfff0f0f2, 0xff535146,\n//0xffd5be24, 0xff140f13, 0xff858486, 0xffc7c7c8, 0xffdddcdd, 0xfff4f4f4, 0xffd7d7d8, 0xff838184, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffe0e0e0, 0xff6c6866, 0xffebe0d3, 0xffe1d6ca, 0xffd9d0c4, 0xffdad0c4, 0xffd9cfc4,\n//0xffeadfd2, 0xffeee2d6, 0xffc6beb5, 0xff96908a, 0xff87817d, 0xff605a58, 0xffc1b8ae, 0xffe5d9ce, 0xff5f5a58, 0xffdfd4c9,\n//0xff64605e, 0xffd2d1d3, 0xff19171b, 0xffece7ac, 0xfffded54, 0xff856f23, 0xffa0a0a6, 0xff9d9c9e, 0xff0d0b0f, 0xff19171b,\n//0xff1b191e, 0xff1d1a1f, 0xffd3bb1f, 0xffecdd40, 0xff656256, 0xffffffff, 0xffd7d6d7, 0xff18161a, 0xff6a696e, 0xff6c683c,\n//0xff9b8822, 0xff3b3b44, 0xff464347, 0xffa5a5a6, 0xfffbfbfb, 0xffe9e9e9, 0xff656262, 0xff1b191d, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff4d4b4f, 0xffd8cec2, 0xffe0d5ca, 0xffd2c8bd, 0xffc8bfb5, 0xffa8a199,\n//0xffa29a94, 0xff9d958e, 0xff928985, 0xffded3c8, 0xffe3d8cb, 0xffded3c8, 0xff6d6764, 0xffcbc1b6, 0xff9e968f, 0xff847d78,\n//0xffcdc3b8, 0xff6a686a, 0xff19171c, 0xffe4dfaf, 0xfffef587, 0xffc0a920, 0xff504d4e, 0xffe8e7e8, 0xff4d4c4f, 0xff16151b,\n//0xff16131a, 0xffa49311, 0xfffbe923, 0xffe4d764, 0xff444241, 0xff5a585b, 0xff7d7b7e, 0xff1a181c, 0xff23212b, 0xff9d9129,\n//0xff3a321f, 0xffababad, 0xffffffff, 0xffffffff, 0xffffffff, 0xff666466, 0xffa79f97, 0xff403e42, 0xffffffff, 0xfffefefe,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc1c2c3, 0xff655e5c, 0xffe6dccf, 0xffe4d9cd, 0xffe2d7cb, 0xffe8ded2,\n//0xff726c67, 0xff524f49, 0xff97936f, 0xff3a3632, 0xffc5bcb2, 0xffdfd4c8, 0xffe3d8cd, 0xff3d3a3a, 0xffdacfc3, 0xff3c383a,\n//0xffbdb4aa, 0xff686261, 0xff19171b, 0xffcdc789, 0xfffffde9, 0xfff1e36f, 0xff504822, 0xff1a171b, 0xff17141b, 0xff37331a,\n//0xffd3c627, 0xfffff252, 0xfffbeb49, 0xffd6cd7f, 0xff29272b, 0xff1a181c, 0xff1a181c, 0xff19171b, 0xff1f1d1c, 0xffa09020,\n//0xff23232e, 0xffe2e1e2, 0xffffffff, 0xffffffff, 0xff6d6d6f, 0xff99938e, 0xffa09890, 0xff838284, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xff636163, 0xffbab1a7, 0xffded4c8, 0xffddd3c7, 0xff534e53,\n//0xff7d7725, 0xffffffd1, 0xfffef47d, 0xffe6db55, 0xff565134, 0xff9e9694, 0xffe5dacd, 0xffd2c8bd, 0xff5b5655, 0xffbcb3aa,\n//0xff363234, 0xffb5aca4, 0xff1a181c, 0xffa59f62, 0xfff8f3c5, 0xff8d864b, 0xffd7ca62, 0xffbcb036, 0xff9e941d, 0xff6f6717,\n//0xff6a663f, 0xffaeab97, 0xfffffacc, 0xffbfbb9e, 0xff5c595c, 0xff1c1a1e, 0xff19171b, 0xff312f35, 0xff615a1d, 0xff403a19,\n//0xff69676b, 0xffffffff, 0xfffbfafb, 0xff7e7d7f, 0xff9a938e, 0xffb7afa6, 0xff6c6561, 0xffcdcdce, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffe2e2e2, 0xff5a5556, 0xffe6dbce, 0xff7f797a, 0xff6d6413,\n//0xfffff02c, 0xffedd933, 0xffb59d25, 0xffbfb228, 0xffe7d730, 0xff605b2d, 0xff605a5c, 0xffe8ddd0, 0xff98908a, 0xff756f6b,\n//0xff87807b, 0xff847c78, 0xff18161b, 0xff736f47, 0xfff2e891, 0xff242117, 0xff776f24, 0xffd4c626, 0xffecdb28, 0xffbfb224,\n//0xff544d19, 0xff13121b, 0xff646265, 0xffadaba4, 0xff777678, 0xffeeedee, 0xff92919c, 0xff4d4928, 0xffa19521, 0xff181517,\n//0xfff7f6f7, 0xfff3f3f3, 0xff444246, 0xffbab1a9, 0xff857e79, 0xffd2c9be, 0xff595453, 0xfffcfcfc, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffabaaac, 0xff585453, 0xff302c21, 0xffe6db55,\n//0xfffef8c6, 0xffe3d04b, 0xff3e3a2a, 0xff2f2c23, 0xff7d7628, 0xffcbbc19, 0xff58534f, 0xff575251, 0xffd4cabf, 0xff413e3e,\n//0xff8c8480, 0xff423d3e, 0xff292629, 0xff47442b, 0xfff3ea90, 0xff80761d, 0xfff8e60c, 0xffe2d548, 0xfffbeb3d, 0xfff9e92e,\n//0xffefdf25, 0xff847b24, 0xff1e1b1a, 0xff2a272a, 0xff252218, 0xff393418, 0xff958b26, 0xffecdc28, 0xff2c2919, 0xffa3a2a5,\n//0xffdededf, 0xff514f50, 0xffd7cdc4, 0xffada59c, 0xffaba39c, 0xffcbc1b7, 0xff737171, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xff7d7d7e, 0xff564f0c, 0xfffaf291,\n//0xfffdf59e, 0xfffbed44, 0xfff2e43c, 0xffc1b74d, 0xff4a472e, 0xff433e1e, 0xff534f3f, 0xff423d41, 0xff312d32, 0xff585354,\n//0xff111016, 0xff221f24, 0xff1c1a1d, 0xff1a181a, 0xffdcd15f, 0xffe4d52a, 0xffcdc026, 0xff26242d, 0xffc2ba77, 0xfffff250,\n//0xfffae82d, 0xffe1d121, 0xff898127, 0xff211e1c, 0xffa1951d, 0xfffcf5a0, 0xfff4e763, 0xff4b461f, 0xff535259, 0xff908f92,\n//0xff696564, 0xffd8cec3, 0xffaca49b, 0xff7e7875, 0xffcac1b7, 0xffaca39b, 0xff9c9b9d, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff5e5c5f, 0xff938813, 0xffffed17,\n//0xffe5d518, 0xffc0ae24, 0xffc9bb22, 0xffdccc1d, 0xfffeeb17, 0xff544f19, 0xffc9bf5f, 0xfff6efa1, 0xffbdb888, 0xff989371,\n//0xff8f8b66, 0xff676450, 0xff36332c, 0xff1b171b, 0xff776e20, 0xfffef05f, 0xfffff344, 0xff504a1f, 0xff19171e, 0xff8a866a,\n//0xfff6ee8c, 0xfffaee63, 0xffe2d338, 0xffa1951b, 0xffdace4b, 0xffefe79b, 0xff5d561e, 0xff232024, 0xff6b6a6d, 0xff8f8a86,\n//0xffe5d9ce, 0xff978f88, 0xff686462, 0xffa59d96, 0xffdcd1c6, 0xff65605e, 0xffd0d0d1, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff3f3d40, 0xffc0b546, 0xfffffab0,\n//0xffd7c138, 0xff352f22, 0xff2f2b21, 0xff534d24, 0xff807720, 0xff4a441d, 0xffe6d625, 0xfff2e223, 0xffe7d726, 0xff978c20,\n//0xff39341e, 0xff6b641f, 0xffbda71e, 0xffd9bd1f, 0xff6a5c1c, 0xffdfd264, 0xfffdef67, 0xffe8d935, 0xff2b281b, 0xff100e16,\n//0xff100e14, 0xff3b392f, 0xff6d6629, 0xfffbe812, 0xffd5c736, 0xff5e5719, 0xff241d1b, 0xff383538, 0xffa59e97, 0xffcec4b9,\n//0xff75706c, 0xff4b4848, 0xff8f8983, 0xffb7afa7, 0xffd5cbc0, 0xff3e3c40, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff504e51, 0xffcab420, 0xfffef153,\n//0xfff9eb55, 0xffe1d64c, 0xffd3c41e, 0xff8a801e, 0xff191719, 0xff4e4820, 0xffa59b2e, 0xff7c7527, 0xff2d291c, 0xff18161b,\n//0xff2a271b, 0xffd4c728, 0xfffaef62, 0xfffdf594, 0xfff1e558, 0xff726c3b, 0xfffffcb6, 0xffeedd37, 0xffbeb232, 0xff151317,\n//0xff85826d, 0xffebe16e, 0xffecdb1e, 0xffa39824, 0xff2e2c1d, 0xff211d1c, 0xff8f7120, 0xff3c383b, 0xff76706b, 0xff565151,\n//0xffc1b8b0, 0xffcbc0b7, 0xff706a68, 0xffddd3c7, 0xff5e5956, 0xffaeadaf, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffa3a2a4, 0xff6c5d1d, 0xffa19120,\n//0xff9f931f, 0xff988d1f, 0xff807727, 0xff484429, 0xff5d5c5e, 0xff737177, 0xff241f1d, 0xff755c23, 0xff3e381b, 0xff19171b,\n//0xff302c1b, 0xffeade66, 0xfffdfdfd, 0xfffdfdff, 0xfffff9a8, 0xffbaae33, 0xffccc9af, 0xfff7efb0, 0xffe0d033, 0xffddd048,\n//0xffe0d677, 0xffbfb124, 0xff5f5924, 0xff26211d, 0xff6c5821, 0xff342c1d, 0xffcba721, 0xff372c1e, 0xff746f6f, 0xffe5dace,\n//0xffaea69d, 0xff605c5a, 0xffded5ca, 0xffcbc1b6, 0xff403c3f, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffb6b6bb, 0xff969497,\n//0xff918f8f, 0xff9a999d, 0xffacacb3, 0xffcbcbce, 0xffffffff, 0xff807b71, 0xffa58d24, 0xffe3ce31, 0xfff1e13a, 0xff8f841b,\n//0xff564e1e, 0xfff9ec5c, 0xfffdf8c3, 0xfffbf6c9, 0xfffbf5c0, 0xfff2e240, 0xff938c4a, 0xffffffda, 0xffe5db78, 0xff8f8521,\n//0xff49421c, 0xff4c461f, 0xff80761e, 0xffad9524, 0xff43381f, 0xff3c351b, 0xfff4da17, 0xff977925, 0xff5d5a5f, 0xff807a76,\n//0xffa69f98, 0xffaaa29a, 0xffd4cac0, 0xff827b76, 0xffbcbbbd, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xfffcfcfc, 0xff494852, 0xffab8f2a, 0xffead942, 0xfffefad1, 0xfffdfdf8, 0xfffaed69,\n//0xffcdb722, 0xffe8d62e, 0xfffbed61, 0xfffbee6d, 0xfffbee7d, 0xfffbeb46, 0xffc2b428, 0xff4c4629, 0xff524b22, 0xff938824,\n//0xffddcd28, 0xffd3c522, 0xffc3b523, 0xff443e1e, 0xff13121c, 0xff82771b, 0xffffef20, 0xffd4be20, 0xff4a4240, 0xffc3bab0,\n//0xff56514f, 0xff9f9792, 0xffdbd1c5, 0xff525052, 0xfff5f5f5, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xff777577, 0xff0d0c18, 0xffc4ac32, 0xffffffc7, 0xffa0a6a4, 0xffa0b39d, 0xfff6ea97,\n//0xffead926, 0xffd8c924, 0xfff9e937, 0xfffbea35, 0xfffae932, 0xfffcec33, 0xfff0df25, 0xffb0a41f, 0xff9f973a, 0xff847c30,\n//0xff776e1d, 0xffc8ba22, 0xffa19723, 0xff2a261e, 0xff12111b, 0xffccbe1e, 0xfffcea2e, 0xffe8d918, 0xff4c401e, 0xff484447,\n//0xffbfb7ae, 0xffe9ded1, 0xff454040, 0xffc4c3c4, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xfffefefe, 0xffffffff, 0xff8a898b, 0xff151317, 0xff12101b, 0xffa89b29, 0xfffffb91, 0xffceca7e, 0xff157688, 0xff44756b,\n//0xffe1cb24, 0xffd7c826, 0xfff0df28, 0xfffbe92a, 0xfffbea1f, 0xffe2d214, 0xff7e793c, 0xffded894, 0xffecece0, 0xfff4f3e7,\n//0xffb5aa39, 0xff5d571c, 0xffada22a, 0xff7a6627, 0xff554820, 0xffdacb23, 0xfffbeb4f, 0xfff4e222, 0xff70621b, 0xff908986,\n//0xffe3d8cc, 0xff5f5956, 0xffa7a6a7, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,\n//0xffffffff, 0xffbcbcbe, 0xff241e18, 0xff1c1a1c, 0xff11101c, 0xff95891b, 0xfffff854, 0xffb9b155, 0xff24899c, 0xff07a9ba,\n//0xff25574d, 0xffdecb25, 0xffd4c525, 0xfffae828, 0xfff3e216, 0xff686335, 0xffeee587, 0xffddc62f, 0xfffcee55, 0xfffbf06b,\n//0xfffdf28a, 0xff998f2b, 0xff514723, 0xff655325, 0xffa68b25, 0xffd4c424, 0xfffbec5a, 0xfff7e841, 0xff86781c, 0xff696361,\n//0xff8a827d, 0xff807e81, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,\n//0xfff1f1f2, 0xff4c433c, 0xffb49723, 0xffac9f12, 0xff544d16, 0xff57501d, 0xffdcc81c, 0xff617c76, 0xff17aebd, 0xff00616e,\n//0xff56562a, 0xffb9ac2f, 0xffb4a019, 0xfff3e023, 0xff79701f, 0xffddcf2d, 0xff655e23, 0xff352d15, 0xffe7dd68, 0xfffefce7,\n//0xfffaf2a0, 0xffffee2f, 0xffbaad2a, 0xff463f20, 0xffaa8e25, 0xffdccd25, 0xfffbee62, 0xfff8ea4d, 0xff94861e, 0xff2c2828,\n//0xff979798, 0xfffdfdfd, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xff797779, 0xff7b651d, 0xffecdd4d, 0xfffffbd3, 0xfffcf057, 0xffd4c418, 0xff6d7b60, 0xff28adbb, 0xff008694, 0xff13656f,\n//0xff317c84, 0xff319ca7, 0xff369da8, 0xff70772c, 0xff645c1b, 0xff8b8124, 0xff2d2a24, 0xffe1d873, 0xfffbed5e, 0xfffbec35,\n//0xfff7e948, 0xfff8ea50, 0xfffae81a, 0xffeddc24, 0xff6c641f, 0xff8f8521, 0xfff6eb75, 0xfffaed5b, 0xff9a8919, 0xff5d5b5a,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc3c2c3,\n//0xff171210, 0xffb09d25, 0xfffbf8da, 0xfff7f1c9, 0xffebe18f, 0xff7e8a5e, 0xff2ca7b9, 0xff007a89, 0xff414b28, 0xffc1ae21,\n//0xffdfc913, 0xff556e39, 0xff007485, 0xff626a2a, 0xff413c1e, 0xff3e3a24, 0xffdcd268, 0xffa89d35, 0xff87750f, 0xfff9ec68,\n//0xfffdf8bb, 0xfffaee64, 0xfffae924, 0xfffbe91f, 0xfffff55b, 0xfff5e647, 0xfff9f193, 0xfffbf286, 0xff9b8915, 0xff6f6b6b,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfff2f2f2, 0xff3a383b,\n//0xff17151b, 0xff8e8222, 0xff808568, 0xff6d9a93, 0xff7ea19b, 0xff28a8b7, 0xff007f8f, 0xff273427, 0xffcfbf24, 0xfffae92e,\n//0xfff3e12a, 0xff4f7753, 0xff4d5523, 0xffe6d519, 0xff3e3920, 0xffab9f20, 0xff887f2b, 0xff1e1c1d, 0xff837f52, 0xfff7f0a3,\n//0xfff7ea60, 0xfff1e037, 0xfff7e726, 0xfffbe90e, 0xfffbed52, 0xfffcf9e1, 0xfffdfdff, 0xfffaf17f, 0xff927e15, 0xff8b8888,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffa2a1a3, 0xff27221d,\n//0xff1a181a, 0xff29261d, 0xffc7b913, 0xff0a6c7b, 0xff01a0b1, 0xff008e9e, 0xff234137, 0xffeede29, 0xffe3d326, 0xffe1d029,\n//0xfff8e72d, 0xffb9a923, 0xfff1df1d, 0xffcabb16, 0xff25221b, 0xff625b23, 0xff4d471a, 0xfff9eb4c, 0xfffffa7d, 0xfff2e12f,\n//0xffbfaa1e, 0xff7c6522, 0xffbba51f, 0xffe2ce19, 0xfff2df0f, 0xfff7e62b, 0xfff8eb56, 0xffecd91c, 0xff856b1c, 0xffafadad,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xff3f3932, 0xffa89321,\n//0xffada447, 0xff655d19, 0xff8a7e1e, 0xff838225, 0xff016b7a, 0xff037c88, 0xffab9f23, 0xfffbea2d, 0xfff9e82a, 0xffd0ba23,\n//0xffcaba28, 0xfff0df1f, 0xffe5d41a, 0xffdacb1b, 0xff645b23, 0xff13111b, 0xff4f491d, 0xffaea220, 0xffbcad20, 0xff928021,\n//0xff3f351c, 0xff606068, 0xff352e26, 0xff4b3e15, 0xff7a691c, 0xff93811d, 0xff95821a, 0xff79661a, 0xff4c3d26, 0xffdfdedf,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff848385, 0xff504216, 0xffe5d87a,\n//0xfffefef9, 0xfffbf3a2, 0xfff4e32d, 0xffd7c025, 0xff7b6f1d, 0xff054a57, 0xff24645a, 0xfff9e82c, 0xfffae92a, 0xffe5d51e,\n//0xff211e1e, 0xff887e23, 0xffc5b322, 0xffc6b724, 0xffaa8b29, 0xff11111b, 0xff1a181c, 0xff19171b, 0xff18161a, 0xff2f2d30,\n//0xffb2b1b3, 0xffffffff, 0xfffcfcfc, 0xffb1b1b1, 0xff6b696c, 0xff4f4d50, 0xff5b5a5c, 0xff9d9c9d, 0xfff3f3f3, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffe3e3e4, 0xff18161a, 0xff887324, 0xfff6eec2,\n//0xfffcf6c6, 0xfffbf4b7, 0xfffaec66, 0xfff7e628, 0xffe1cb24, 0xffb09c1c, 0xff79731b, 0xfff5e423, 0xffeada21, 0xffb4a427,\n//0xff0f0e1b, 0xff11101b, 0xff14121c, 0xff342c1f, 0xff513c1f, 0xff111117, 0xff525053, 0xffc9c8c9, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xff727073, 0xff19171b, 0xff675721, 0xfff4e15a,\n//0xfffaeb42, 0xfffae93e, 0xfffae933, 0xfffae931, 0xfff2e124, 0xffb9a720, 0xff322d1c, 0xff625b1f, 0xffaa9827, 0xff776325,\n//0xff15141b, 0xff1a181c, 0xff171519, 0xff0d0a0f, 0xff474649, 0xffc7c6c8, 0xfff8f8f8, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffdcdcdc, 0xff252326, 0xff1a181c, 0xff312a1d, 0xffd3c122,\n//0xfff7e72d, 0xfff5e42d, 0xfff3e22d, 0xffecdb2d, 0xffd3c423, 0xffaf9f25, 0xff261f1d, 0xff15131a, 0xff141119, 0xff1a171a,\n//0xff232125, 0xff302e32, 0xff626063, 0xffd0d0d1, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xfffdfdfd, 0xffe0e0e1, 0xffb1b0b2, 0xff39373a, 0xff0a070c, 0xff0e0b10, 0xff0b0910, 0xff332e12,\n//0xff797019, 0xff96891d, 0xff93831d, 0xff817219, 0xff716217, 0xff62511f, 0xff373233, 0xff525053, 0xff777679, 0xffa6a5a7,\n//0xffc9c9ca, 0xfff1f1f1, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffe2e2e2, 0xffc0bfc0, 0xffbcbbbc, 0xffbcbcbd, 0xffbab9ba, 0xffb6b5b6, 0xffb4b3b4,\n//0xffb4b3b5, 0xffb7b6b7, 0xffbfbfc0, 0xffd4d4d5, 0xffeeeeee, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\n//0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff];\n//\n//int width = 50;\n//int height = 50;\n//\n//Figure logo(){\n//  list[list[Figure]] boxes;\n//  boxes = for(i <- [0..height]){\n//              append for(j <- [0..width]){\n//                         append box(fillColor(LogoData[i*50+j]),lineWidth(0));\n//      }\n//  }\n//  return grid(boxes,aspectRatio(1.0));\n//}\n//\n//void renderLogo() {\n//  render(logo());\n//}\n")),(0,l.kt)("p",null,"We can use it as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                import demo::vis::Logo;\nrender(logo());\n")),(0,l.kt)("p",null,"will produce:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Rascal logo",src:n(4255).Z,width:"24",height:"24"})),(0,l.kt)("p",null,"or as a screenshot:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Screen shot",src:n(7143).Z,width:"732",height:"420"})),(0,l.kt)("h3",{id:"interactive-box-height"},"Interactive Box Height"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Control the height of a box with user input."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A text entry field to enter numbers.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A box, whose height is controlled by the numer entered in the text field."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is a solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::vis::Higher\n\n//import vis::Figure;\n//import vis::Render;\n//import String;\n//\n//bool intInput(str s){\n//  return /^[0-9]+$/ := s;\n//}\n//\n//Figure higher(){\n//  int H = 100;\n//    return vcat( [ textfield("<H>", void(str s){H = toInt(s);}, intInput),\n//                 box(width(100), vresizable(false), vsize(num(){return H;}), fillColor("red"))\n//               ], shrink(0.5), resizable(false));\n//}\n')),(0,l.kt)("p",null,"The auxiliary function ",(0,l.kt)("inlineCode",{parentName:"p"},"intInput")," checks that a strings consists solely of digits. Function ",(0,l.kt)("inlineCode",{parentName:"p"},"higher")," can be understood\nas follows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A local variable ",(0,l.kt)("inlineCode",{parentName:"p"},"H")," is used to maintain the current height.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"It returns a vertical concatenation of two elements: a ","[","Rascal:textfield","]"," and a ","[","Rascal:box","]",".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The textfield has three arguments:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A string that is the initial value of the text field.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A call back function ",(0,l.kt)("inlineCode",{parentName:"p"},"void(str s){H = toInt(s);}")," that is called when text entry is complete: argument ",(0,l.kt)("inlineCode",{parentName:"p"},"s")," is\nthe text entered and the effect is to convert that text to a number and assign it to ",(0,l.kt)("inlineCode",{parentName:"p"},"H"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Function ",(0,l.kt)("inlineCode",{parentName:"p"},"intInput")," that checks that only numbers are entered.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The box has")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a fixed width")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"it is not vertically resizable.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"It has a vertical size that that depends on an anonymous function ",(0,l.kt)("inlineCode",{parentName:"p"},"vsize(num(){return H;})")," that returns the\nvalue of ",(0,l.kt)("inlineCode",{parentName:"p"},"H"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Its color is red."))))),(0,l.kt)("p",null,"Rendering this figure:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"import demo::vis::Higher;\nrender(higher());\n")),(0,l.kt)("p",null,"gives"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"h1",src:n(9042).Z,width:"224",height:"262"})),(0,l.kt)("p",null,"Unfortunately we cannot show the interaction here, so run this example from the ",(0,l.kt)("inlineCode",{parentName:"p"},"demo")," directory and watch how the\nheight of the box changes when you enter a new number in the text field."),(0,l.kt)("h3",{id:"my-first-box"},"My First Box"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Drawing a box in many variations."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Drawing a red ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#box"},"box")," is as simple as this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'import vis::Figure;\nimport vis::Render;\nb = box(fillColor("red"));\nrender(b);\n')),(0,l.kt)("p",null,"and it will look like this:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Box 1",src:n(6943).Z,width:"24",height:"24"})," or rather, it will look like this:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Screenshot 1",src:n(7143).Z,width:"732",height:"420"})),(0,l.kt)("p",null,"Wow, the box fills the whole window","!"," So lets give our box a ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#size"},"size"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'import vis::Figure;\nimport vis::Render;\nb = box(fillColor("red"), size(200,100));\nrender(b);\n')),(0,l.kt)("p",null,"and it will look like this:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Box 2",src:n(6260).Z,width:"224",height:"124"})),(0,l.kt)("p",null,"On screen however, it still fills the whole window as shown above. The lesson here is that size is to be taken as\n",(0,l.kt)("strong",{parentName:"p"},"minimum size")," (and probably we should rename ",(0,l.kt)("inlineCode",{parentName:"p"},"size")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"minSize")," to emphasize this)."),(0,l.kt)("p",null,"So how can we produce a box that does ",(0,l.kt)("em",{parentName:"p"},"not")," fill the whole window? The answer is to define the size of the box\n",(0,l.kt)("em",{parentName:"p"},"relative")," to its surroundings by using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#shrink"},"shrink"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'import vis::Figure;\nimport vis::Render;\nb = box(fillColor("red"), shrink(0.5));\nrender(b);\n')),(0,l.kt)("p",null,"which says: ",(0,l.kt)("em",{parentName:"p"},"I am a red box and I want to occupy 50% of the available space.")," The result is:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Screen shot 2",src:n(1824).Z,width:"729",height:"421"})),(0,l.kt)("p",null,"Shrinking can also be limited to one dimension using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#hshrink"},"hshrink")," or\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#vshrink"},"vshrink"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'import vis::Figure;\nimport vis::Render;\nb = box(fillColor("red"), hshrink(0.5));\nrender(b);\n')),(0,l.kt)("p",null,"which says:","_"," I am a red box and I want to occupy 50% of the available space in the horizontal direction and 100% of the\navailable space in the vertical direction.","_"," The result is:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Screen shot 3",src:n(1830).Z,width:"733",height:"420"})),(0,l.kt)("p",null,"Relative sizes can also be used when figures are nested."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'import vis::Figure;\nimport vis::Render;\nb1 = box(fillColor("red"), hshrink(0.5));\nb2 = box(b1, fillColor("yellow"), size(200,100));\nrender(b2);\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Box 5",src:n(9362).Z,width:"224",height:"124"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,l.kt)("p",null,"In the above examples we have consistently added the two imports:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"import vis::Figure;\nimport vis::Render;\n")),(0,l.kt)("p",null,"In other recipes and the Rascal documentation we omit these two imports to avoid cluttering our examples with irrelevant\ndetails. Be aware that you will always need them when creating a visualisation."),(0,l.kt)("h3",{id:"parsetree"},"ParseTree"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Visualize a parse tree."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"A parse tree is a (usually large) internal representation of a parsed text. In the rare situation that it is necessary\nto read or inspect a parse tree, a visualization can be useful."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"We embark on visualizing parse trees for the language Exp:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Concrete::WithLayout::Syntax;\nimport ParseTree;\nparse(#Exp, "1+2*3");\n')),(0,l.kt)("p",null,"As can be seen, even for such a trivial example, the details in the parse tree representation become sizeable."),(0,l.kt)("p",null,"We can visualize it as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'import demo::lang::Exp::Concrete::WithLayout::Syntax;\nimport ParseTree;\nimport vis::Figure;\nimport vis::ParseTree;\nimport vis::Render;\nrender(visParsetree(parse(#Exp, "1+2*3")));\n')),(0,l.kt)("p",null,"With as result:"),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"t1",src:n(5464).Z,width:"34",height:"24"})),(0,l.kt)("p",null,"The figure is interactive (not available here):"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Rectangles with blue text are terminal symbols.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Little circles represent non-terminals: hovering over them shows the corresponding grammar rule.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Little grey rectangles represent layout: hovering over them also shows the corresponding lexical rule."))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A dense, structured, representation of a parse tree that provides extra information via interaction.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"This visualization does not scale to huge trees.")),(0,l.kt)("h3",{id:"playing-with-properties"},"Playing With Properties"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Illustrate the effect of various figure properties."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is an ellipse with minimum size 200x300 that occupies 80% of the available space:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                e = ellipse(size(200,100), shrink(0.8));\nrender(e);\n")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e1",src:n(6366).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"(we add the shrink to leave some space for thick lines and shadows below)."),(0,l.kt)("p",null,"Change the style of its border using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#linestyle"},"lineStyle"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'                e = ellipse(size(200,100), shrink(0.8), lineStyle("dot"));\nrender(e);\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e2",src:n(1623).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"Change the thickness of its border using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#linewidth"},"lineWidth"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                e = ellipse(size(200,100), shrink(0.8), lineWidth(5));\nrender(e);\n")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e3",src:n(377).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"Change the color of its border using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#linecolor"},"lineColor"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'                e = ellipse(size(200,100), shrink(0.8), lineColor("blue"));\nrender(e);\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e4",src:n(3411).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"Change the color of its area using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#fillcolor"},"fillColor"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'                e = ellipse(size(200,100), shrink(0.8), fillColor("yellow"));\nrender(e);\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e5",src:n(2070).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"Add a shadow using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#shadow"},"shadow"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},"                e = ellipse(size(200,100), shrink(0.8), shadow(true));\nrender(e);\n")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e6",src:n(6674).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"Add the color of the shadow using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#shadowcolor"},"shadowColor"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'                e = ellipse(size(200,100), shrink(0.8), shadow(true), shadowColor("grey"));\nrender(e);\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e7",src:n(7023).Z,width:"274",height:"149"})),(0,l.kt)("p",null,"Finally, enjoy the grande finale:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-figure"},'                e = ellipse(size(200,100), shrink(0.8), lineStyle("dot"), lineWidth(5), lineColor("blue"), fillColor("yellow"), shadow(true), shadowColor("grey"));\nrender(e);\n')),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"e8",src:n(1122).Z,width:"274",height:"149"})))}d.isMDXComponent=!0},106:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAAAAABzHgM7AAAAAmJLR0QAAKqNIzIAAABjSURBVHjaVY6xDcAwCAS/pPQaLim9QmajdOk2I2SNrMEIlARIoigU8Cek/4e7zdHaWOYOVwaoA6wOCw05Y7FBgE0tIWQ+sBcwKM8qoD/wB5wGL8hjfdzWrh01GRp1hInGjDoXwHgsFuzBVLQAAABDdEVYdFNvZnR3YXJlAEAoIylJbWFnZU1hZ2ljayA0LjIuOCA5OS8wOC8wMSBjcmlzdHlAbXlzdGljLmVzLmR1cG9udC5jb22RuiG4AAAAKnRFWHRTaWduYXR1cmUANThhMDcyZTA3MGRhMjJmNjEzNWNiZDNlNDE0NTQ2ZjloaiHtAAAADnRFWHRQYWdlADEyeDEyKzArMIRtu30AAAAASUVORK5CYII="},3875:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAAAAABzHgM7AAAAAmJLR0QAAKqNIzIAAAB4SURBVHjaJU6rFcNADBM09BqBhl6ltDCwKxQeDOwKB7tGYGCoYaChK6cmlt7TD1W5uap/sgoVBnEXWBTSoOdx7gpLDOAVorWC0ABdcBPqwZtx8Muf+DPXJpQ96Nu/LSMYl/n17oCOnplTOrpiwW3sUs4ZJmob5/wAUbg1Y/zrjUwAAABDdEVYdFNvZnR3YXJlAEAoIylJbWFnZU1hZ2ljayA0LjIuOCA5OS8wOC8wMSBjcmlzdHlAbXlzdGljLmVzLmR1cG9udC5jb22RuiG4AAAAKnRFWHRTaWduYXR1cmUAODBiYmRhMjcyNmRkYWNlOGFiOGEwMWY1OWRlMmViZGII/Q51AAAADnRFWHRQYWdlADEyeDEyKzArMIRtu30AAAAASUVORK5CYII="},3825:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAAAAABzHgM7AAAAAmJLR0QAAKqNIzIAAABzSURBVHjaHY0hEoUwEEMjkZVYZGVlr1CJxCKRXKPyy28reyVsZeXKsCFi573ZzAQk+x5jaQ6gFQAxIA8XceENZEN3DkOCH/TobUoSVuAYwSSLyzbvaHWVFJxUmmp+PF+twrLkuXzLwPmZ8+OjtH8KS6pGvuoGNo5b6rzDAAAAQ3RFWHRTb2Z0d2FyZQBAKCMpSW1hZ2VNYWdpY2sgNC4yLjggOTkvMDgvMDEgY3Jpc3R5QG15c3RpYy5lcy5kdXBvbnQuY29tkbohuAAAACp0RVh0U2lnbmF0dXJlADlmODJmY2FjOWUwMzljYmRiNzIzODBhNDU5MTMyNGY1gLv4dgAAAA50RVh0UGFnZQAxMngxMiswKzCEbbt9AAAAAElFTkSuQmCC"},7143:function(e,t,n){t.Z=n.p+"assets/images/Screenshot1-68568a972322122b2ef26efa9c45110e.png"},1824:function(e,t,n){t.Z=n.p+"assets/images/Screenshot2-fd4ce74e5468d1c42167ca70346a9d1a.png"},1830:function(e,t,n){t.Z=n.p+"assets/images/Screenshot3-ebf100273748dac4722b3b0836180743.png"},8620:function(e,t,n){t.Z=n.p+"assets/images/Screenshot4-d0a28f4e8a5572e2805df6117a73b948.png"},3628:function(e,t){t.Z="data:image/png;base64,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"},9855:function(e,t){t.Z="data:image/png;base64,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"},8430:function(e,t){t.Z="data:image/png;base64,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"},6943:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAIUlEQVR4nGNgZKAe+E8NNGrQqEGjBo0aNGrQCDXoHzUQAGDtDvh+84A6AAAAAElFTkSuQmCC"},6260:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAAB8CAIAAAD/6yuOAAABYElEQVR4nO3SQREAIAzAsOHfM+Nw0Ud6kdA5I7VbqDIoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoaQYlzaCkGZQ0g5JmUNIMSppBSTMoab8LVQ//sL802xtTfAAAAABJRU5ErkJggg=="},9362:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAAB8CAIAAAD/6yuOAAACIElEQVR4nO3SwQmEABAEQc0/Zz1M4F7K0FBLBzCwdZznkbjITPfB3XegZ6feK/T3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAQVUgALaKfT3/QhAAf0H9LoCPTv1XpW//wC3enHyE/d8zAAAAABJRU5ErkJggg=="},6931:function(e,t){t.Z="data:image/png;base64,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"},8393:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANEAAAECCAIAAADvhaWNAAAYoklEQVR4nO2dCVRUVR/AL5sD7oKMUIOCawohbkmRmBpI5obllqW4545+SuC+pWS5crTMxDSPVl8qYHpOpn1lahoqesgFNffjmgsqyYjA93/zcBxmhpk3b97c+97M/3femfOcudz//935ee/b5l1SiiB0IawTQFwOdA6hDTqH0AadQ2iDziG0QecQ2qBzCG3QOYQ26BxCG3QOoQ0D59zc3IiTQq8NWW+pWQQmz8A54ckpC5rbxcWS2YLOMQCdE5q8Q5vGfEh0TpJYMlvQOQagc0KTd2jTmA+JzkkSS2YLOscAdE5o8g5tGvMh0TlJYhkslUxOW2wn5JZu5UODYt8Q0kG38gohXroF8Hy2nktIdUK8CamiW+oQ8jYhl3TllxASQshjg6qgnmHoHHPYOnfCpOPhnfMj5LCJc/olgJCfDP4Jzv3xbP1fQtoR0k23/pSQCELmPPvoO0L8CbmDzjGHrXMnK3BuOSFtCSmx3TlY0ghp/Wz9oK7zu0DII0I0hKzHsVUOsHXuM0I2P1u2GTgH3VVLQtYKdu4XnVWwZBPSyqBvK9UN0/GEpBDyBu7P2c+cOXOmTZs2d+7clJQUcQVKWTvXVucTv/QycE5LyAFC1ITcFeacIYG6v9J/ek+3k1eZkFPonP0sXbo0NTV12bJlCxYsEFeglLVzFY2tWt36QEJGC3NuHyFFuuWCbgxNKl9+KiE9zQmnYOeWLFkSGhoaHBz86aefGn308ccff/nll1Yrt1ADz9ixY+/fv2/05tq1a1euXJmenp6Wlgb/3LlzZ/v27YOCggYMGHD79m3TArZul+TY6tx1QmoRMtHG/bl5hHQpX34WIX2cyblTp06FhYVdvXp17969Go0mLy/P8FNwaN26ddevX/+zPH///bfAGngCAgKgEqM3z549C3/Lv5aUlIC127dvv3nzJjg3ffp0owK2bpcjMHXugO5AUr8UlncOlsW6EyI2ObeakGjndm7Pnj1qtTonJwfWr1y5kp+fb1oGurr65UlMTLSpBrPOGVJQUADKwopWq501a1bnzp3t3C5HYPX83Fcmzj0hpKnJ7r9l537Q9Y53ndg5YPLkydWqVQOTYJ+9uLhYROUV1QDDYqgOT0/PJk2awMqUKVPM1gD9HAzQUAbsbNmypSKck8OiSOdgNwv6mMLCQtidatiw4datW03LHDx4MLU8WVlZQmqAbu83Hb6+vvA+rFQ0SsJHderUOXfuHKyvX78+Li7Ozu1yBOicbVSU3Jo1axISEvjOqV+/fl999ZXhp/v27Tt69CjINKg8n3/+ucAaeKyOratXr46NjYWVoqKiLl26YD/nzM5BLwVjYr169SIjI6Ojox89emT46bvvvjtp0iTLNVuugceqc3fv3m3cuDGMqjC8Lly4EHYQMzIyrG0TBzonNHmHNo35kBUnB7vtubm5N27cEF25/TXwwNgK/RyswIHI48ePhfwJOic0eYc2jfmQFL8bmqBzQpN3aNOYD4nOSRFLhghN3qFNYz4kOicbmOSMzkmGErcLnVM2StwudE7ZKHG70Dllo8TtQueUjRK3C51TNkrcLhdyzlmh35h2wiRn5TUTz4EDB/z9/S9dumRnPZcvX65cubKnp+dLL71UpUqVuLi4FStWSJKhIkDnhHL79m2NRrNjxw5JagPJ9B0VeKzE7ko06JxQevToMXXqVKlqKyoq4oVTqVSgsv33BygIdE4Q69atCw8P12q1EtZZs2ZNNze3+vXr37t3T8Jq5Q86Zx3YgfP19c3NzZW22sTExE6dOkHNFy9elLZmmYPOWaGkpCQ6OnrRokUOqh9qhvohioPqlyHonBUWL178+uuvi/ttjhCgZqgfojiofhmCzlnixIkTMPZduHDBoVGgfogCsRwaRT6gcxXy5MmTiIgIs7+pkRyIArEgIoVYzEHnKmTGjBnx8fHUwkEsiEgtHEPQOfPk5eX5+fldu3aNWkSIBRHNPnrCyUDnzNOpU6dly5ZRDgoRIS7loPRB58ywefPm5s2bP336lHJciAhxITrluJRB54x58OBBYGDgH3/8wSQ6xIXokAOT6HRA54yZMGHCsGHDGCYwfPjw8ePHM0zAQfz777+JiYn/+c9/wDl4hXV4h1p0+Tp37Ngxf3//O3fuMMwBousfLuZM7N69G2yLjo7Wv8I71KLL17nIyMgNGzawzqIUcoBMWGchPREREfo7uGDPlWZomTq3a9eupk2byuHSJ+Tw8ssv//jjj6wTkZizZ896eHiAcPAK6zRDy9Q56PA3btzIOosytmzZ0qpVK9ZZSM97770HzsEr5bhydG7fvn0hISH0z49UBHR14eHh27dvZ50Ih/xn+ba6CXJ0Li4uTsgj0mmSkZERFRXFOgsOIV8qQxTp3JEjR1588UVpbwO2n6KiooCAAAsPTacGOic9vXr1on+lSwhTp06dOHEi6yzQOamBjgS6E7l1cjznz5/38/Njnhs6JzFz586dMGEC6ywqJCYmZtu2bWxzQOckpnnz5vx8IPJk+fLlQ4YMYZsDOicl586dU6vVcjgPXBEXL1709/d33A8yhIDOSUlqauqoUaNYZ2GF8PDw/fv3M0wAnZOS1q1b79mzh3UWVpg9e3ZycjLDBNA5yYBhq3bt2vK59lARP//8c7t27RgmgM5JxuLFi9neKieQhw8fVqlSheEZEzrOjRgx4tixY/p/5uXljR8//q233lq0aJHl3VklOdezZ88tW7awzkIQLVq0YHXrcqnjncvKyho+fDhE+fXXX/l34L9ZkyZNxowZc/To0W7dulU0H6Tw9OTiXHBw8JkzZ1hnIYhx48ZVNAk2BSr6Uo8fP56QkADHYSEhIS1btjTspXgETvQNxRITE6tVq6Z37ocffmjbti2/Dm/6+vpa6OoU49z9+/dhwJLzWRJDNm3a1LdvX1bRK/pSDxw44OnpCSMgjIPx8fFdu3Y1KiBkom899erV0zsHHo8cOZJfv3LlCiRw8+ZNW9MrV8ZqCQrA5r322mussxBKTk5OWFgYq+gWnPPz8+MPwvbv39+oUSOzxSxP9K3H0LkPP/xQP55Cv+Dm5nb+/Hlb0ytXxmoJCixfvlz+Z+b0FBYWqlQqftZD+lhwrlmzZvw6jLMajcaeKIbOTZo0SX/1paCgoFKlSha2XTHODR48ePXq1ayzsIGGDRuyuq/JgnP63teCc5Yn+tZj6Bz0CB07duTXT5w4YbmPV4xzsM8LbcE6Cxvo0aMH7FkzCS3aOSETfesxdA5GUm9vb9hNhE7ugw8+GDFihIj0ypWxWsLRwEEQbBLze4RsIjk5eeHChUxCi3ZOyETfegydK9U95rtq1aoBAQERERFwwCcivXJlBCbhOO7cuVOrVi3WWdhGWlra6NGjmYRmdR3iwYMHZo9wjVCGc9B1BwcHs87CNrZt29a9e3cmofHalwTk5ORQ/k2v/WRnZ8M+KJPQ6JwEwH5DdHQ06yxs48aNG/7+/kxCo3MSkJmZ2a1bN9ZZ2IxKpWLy/Fd0TgLWr18PR+Css7AZtVrNZMYcdE4C4Dh87NixrLOwmcaNG58+fZp+XHROAubPn6/EB0a/8sorTM5jo3MSMHv27JkzZ7LOwmZiYmJ++ukn+nHROQlQqHO9e/f+7rvv6MdF5yRAoc4NHz6czhwpRkjz7CRHYn0TKDSTZRTq3MiRI81eHVcWQhSRPij9kEYo1Dk41naCWdTROSUxceJEJ5gBEZ1TEklJSampqayzsBd0TklMmzZt3rx5rLOwFxd1bs6cOaAd6yxsRqFpG+Gizim0n1No2kagc0pCoWkbgc4pCYWmbQQ6pyQUmrYR6JySUGjaRqBzSkKhaRuBzikJhaZtBDqnJBSathGu5Zx+quTXXnvt1VdfpTxVsv0o2jkXnadaP1VyvXr16tatS+hOlWw/inbOdeepZjhVsv0o2rlSl52nWj9VspubG+Wpku1H6ddbXXeean6qZIaPrRSN0vu5UpnPUy3/uZEt44iGY+Wc/L8Lq5sg6PsQUpFscVDyrJyT+XeBznGgczRB5zjQOZqgcxzoHE3QOQ50jiboHAc6RxN0jgOdowk6x4HO0QSd43BQ8qyufcn8u0DnOLCfo4nzO2c0nbJZ0DmBQM89bdq0uXPnpqSkiCsgMD2lOmc6nXJFoHMCWbp0aWpq6rJlyxYsWCCugMD07HJOkrmRrVZiFtPplG1N3k5k6NySJUtCQ0ODg4NNp9EW8kWsXbt25cqV6enpaWlp8M+dO3e2b98+KChowIABt2/fNi1ga3rPy1gtYaEiSeZGtlqJBYymQrMpeTuRm3OnTp0KCwu7evXq3r17NRoNNKbhp0K+iLNnz0Il/GtJSQnou3379ps3b4Jz06dPNypga3rlytiznZLMjWy5Emimozpu3bplWjM6p2fPnj1qtTonJ6dUN4N5fn6+aRmBk1SX6uYGBndhRavVzpo1q3PnznamV66MPRVJMjey5Urgq3XXAbsRpn+LzhkyefJk2NkAk2Bnv7i42J4o0M/BSN2kSZOAgADY4ZGXc/bPjSywErOgc3ru378PnVNhYSHshzVs2HDr1q2mZQROUg389ttvderUOXfuXKluoqK4uDg70ytXxp6KJJkbGZ2ziYo2Z82aNXAoxndv/fr1M3qmu02TVAOrV6+OjY2FlaKioi5duiipnxMyNzI6ZxMW+jkYVaFBIiMjo6OjHz16ZPipTZNUA3fv3m3cuDGMqjC8Lly4EPYUMzIy7EmvXBmpKpItrnPtC/b3c3NzJZz5DsZW6OdgBY5IHj9+bGd6z8tIVZFscZF+TiagcxzoHE3QOQ50jiboHAc6RxN0jgOdowk6x4HO0QSd40DnaILOcaBzNEHnOFznnLAckNI5RWN3S5qBYT8nc6xvAoVmkpacnJyAgICvv/6abRryef5cfn5+TExMly5djK6xyhblOQfk5eUFBQWZvaOOGjJx7vLly6GhoWPGjLHzhjmaKNK5Ul1bN2rUaNasWawSkINzR44cCQwMXLp0Kds0bEWpzgG3bt2KiIgYP358SUkJ/ejMncvKyvLz8xN4i5GsULBzpbqbxqKiogYNGsT/nIImbJ1bsWIF7NRmZ2ezSsAelO1cqW56jc6dO/fs2bOwsJBmXFbOwX7bhAkTmjZteunSJfrRJUHxzgFPnjzp3bt3p06dHj58SC0oE+cKCgq6d+/esWNH6OAph5YQZ3CuVPe/f9iwYW3btr1z5w6diPSdu379eqtWrRISEuD/GM24kuMkzvFMmTIlNDT02rVrFGJRvg7x119/1a1bd968edQiOg6ncg5YuHBhSEjI+fPnHR2IZj+3e/fu2rVrb9q0iU44R+NszgFffPHFCy+8AB2DQ6NQcy49Pd3f3//333+nEIsOTugcsHnzZrVafejQIceFoOBcSUnJtGnToNs+c+aMQwNRxjmdA3bs2AHj0S+//OKg+h3tXGFhYf/+/SMjI//55x/HRWGC0zoH7N27F7TLzMx0ROUOdQ48i4qK6t27N+WTjnRwZudKdVckYZDdsGGD5DU7zrmzZ882aNAgOTmZyTU9Cji5c8Dp06c1Go2Fx/SJw0HO7du3D/6TGD1txMlwfueAS5cuQc8xd+5cCet0hHPffvst7Azs2rVL2mrlhks4B9y8eTM8PHzixIlSDViSO7dgwQLoj3NzcyWsU564inPAvXv3Xn311cGDB0tyEwr0mlLdvVdUVDR06NAWLVpcv35dkgpljgs5V6q7Rh4bG/vOO+9otVpb/7a4+Fx6ethbb3m88goJCiKeniQwkEREuEVFVf7ssyTRt+nm5+e/+eabb7/9tlLuLLcf13KuVPfArF69esXExAj/jvPzM0eMUAUHg2FkzRqyezf5+29SVMS9wjq8Ex5O1GoSG/uy2af4WgB2NENDQ8eOHaugO8vtx+WcK9XdhAIjLIyzMNpaLbxnT6ewMDJwIMnOJrrmMr/ApwMGgHkewm/cPXz48AsvvKC4O8vtxxWd45k0aVJYWJjFJwQ+TEur4udH0tMt2Wa4fPEF92O7ceNGWI2emZkJh6hKvLPcflzXOWD+/PkhISEXLlww92HRp59WBoFOnRIqHL9A+apVyQcfvGch7ooVKwIDAxV6Z7n9uLRzwKpVqzQazcmTJzdv3gyG6W+CWrXKDw4RzpyxTTh+gf286tVJUlKSPsqoUaPgKKFYh9LvLLcfV3cO2LhxY/Xq1VUqFTiXnJwM72za1LxOHZt7OKPernJlor/4AcNovXr1hgwZ0r179w4dOij6znL7Qee4ia0qVarEP/egQYMGWu0hOGiAXk+0cPzyzTcwyFaCw+SjR496enpC5V5eXq1bt+afCu3KuLpzf/75J9hQuXJl3jk3N7eUFO9OnewVjl9atHCLj48fAAe0Ojw8PGrUqPH999+z3mjGuLpzpbrb2du3b+/j4+Pv75+QQHx9SV6eNM5BPV5enMe8zdDPubu7p6amst5ixqBzZcCQd/jw4YED3ZOSpBGOXwYNcgfb+vTpk5WVdeXKFdZbKQvQuec8fvwHHDqcPi2lc1Cbh4ebwAk9XAR07jnLlwe3ayelcPzSsKEHfziM8KBzz+nYkWzcKL1zX37prlarWW+cjEDnytBqT8LBa36+9M5BnXAUIeJOFmcFnSsjM/OdZs2kF45fatb0cJpfRNsPOlfGRx/VHjLEUc7FxHj37duX9SbKBXSujK5d3YXfP2Lr8tln3iEhIaw3US6gc2W0bk3+9z9HOffjj141atRgvYlyAZ0ro0kTcvy4dXugTEICSU0lISGkZUty7Jgg5w4f9lCpVKw3US6gc2UEBJCrV63bc+AA90uI8eO561rx8aRrV0HOXb5M3N3dWW+iXEDnylCpyL//CnLOz488fcqt799PGjUS5FxBgaDJOlwEbIgyvL05M4Q4pz+lAuOsRoPO2Qw2RBl16pArVwQ5FxZms3MXL3rg2KoHnSsDRkkhxxDinDt4UIXHEHrQuTIiItyEnCsR51xGRhU8V6IHnSvjjTe8HXdOePZsNZ4T1oPOlTFqVJjjrn21beuH1770oHNlfP/9sqZNHeWcj48XXuPXg86VodVqfXzI/fvSC3f3rhcheC/Tc9C554SHeznins358zV4z6Yh6Nxzpk8f8vrr0jvn61sF7003BJ17zuPHj2vVkvg3OEeP1nJ3d8ff4BiCzpUjJiZI2t8axsbWbdOmDevNkhfoXDmOHz9etapkv6k+ckTt5uYGdbLeLHmBzhnTp0+HN96Qxjm1unp8fDzrDZId6JwxWq02IMDd/mfkfPxxQ29vbzxFYgo6Z4a0tLTq1e16FtjBg3Xh0EHyiVCcA3TOPElJk+EY9tw5McIdO1YbhDN85iFiCDpXIQMH9oPjCVt7u+xsP0LI0KFDWacvX9A5S4wdOxYEWrVKqHApKY3gQHXcuHGsE5c16JwVMjIyqlb1iovzPHTIkm0//1y7WbNAlUrlmo9Ctwl0zjoPHz6Mjo6uVMkjMNB9wQKfrCzPM2eIVktOnqz03/9WT0qqW6WKytPTE8pASdbJKgB0TijFxcWffPJJSEhIzZo1PTw8+Ge1wjq8A++71EQ2doLOiQR/xyUabDiRoHOiwYYTCTonGmw4kaBzosGGEwk6JxpsOJGgc6LBhhMJOicabDiRoHOiwYYTCTonGmw4kaBzosGGEwk6JxpsOJGgc6LBhhMJOicabDibuaQDnONXWKejPNA528jIyADbAgMD9a94k6atoHO2UVBQ4OPjQ54B6/AO66QUBjpnM2lpae7u7iAc/ppQHOicGDQaDTgHr6wTUSTonBiys7PBOXhlnYgiQec4CC1Yb6gswFbgABtmOx50jgdbgQOdowm2Agc6RxNsBQ50jibYChzoHE2wFTjQOZpgK3AYOcc/GsKQ/v37DxkyxN3dPSEhgS+TmJioUqn69OkD62q1ulevXi+++KK7DqK7RMEzatQodM4IbAUOU+dGjx5t2lFFRUXVqlUrJSUF1uvXrx8eHs6/zzunL1a1atX3338f+7mKwFbgMHVuzJgxptJMnz4d9GrdunXXrl2rVav20UcfoXMiwFbgMHUuNjb2nWf07dtX/9HIkSPhUy8vL0Or0DmbwFbgMHUOds6Cn9G0aVP9RzNmzPD19fXx8UlOTkbnxIGtwCFwbAU6dOgAhgUFBbVp0wadEwe2AodA5+DAwtPTc+jQoXA0CmVgBZ0TAbYCh6lz4FOSAXD0MHPmTI1GAwcQfJnIyEh/f38YatE5W8FW4LB6fq579+5xcXEgk343LiUlBQ5dYahF52wFW4EDr0PQBFuBA52jCbYCBzpHE2wFDnSOJtgKHOgcTbAVONA5mmArcAj92ZbdsN5QWYCtgNAGnUNog84htEHnENqgcwht0DmENugcQht0DqENOofQBp1DaIPOIbT5P+vCEgtLBD2BAAAAAElFTkSuQmCC"},6366:function(e,t){t.Z="data:image/png;base64,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"},1623:function(e,t){t.Z="data:image/png;base64,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"},377:function(e,t){t.Z="data:image/png;base64,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"},3411:function(e,t){t.Z="data:image/png;base64,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"},2070:function(e,t){t.Z="data:image/png;base64,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"},6674:function(e,t){t.Z="data:image/png;base64,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"},7023:function(e,t){t.Z="data:image/png;base64,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"},1122:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARIAAACVCAIAAAAbl+KgAAAclklEQVR4nO1dCVwT1/Ye9j4W11p3bBFc26oo6FO7+K9a0VrXPrdq3euKihZBUQEREB4CilpAUVqKCyoqQt0XxIcWcGutCEhBQZTKDoUEkvs/yWC4ExETSHJDcr/f92vjHL1z55zzzV3mzh0GUVBQyAmGdAUoKJofqGwoKOQGlQ0FhdygsqGgkBtUNhQUcoPKhoJCblDZUFDIDSobCgq5QWVDQSE3qGwoKOQGlQ0FhdygslEuyspQZSXnyC+/oEWL0LRpyM4ODRuGjhzhWN3ckKEhMjBA+vpITw85OnKskZHIygoNGICGD0djxiA/P441Px8lJKCMDFRRoZyLoXgFKhvFw9cXjRqFevdGLVoghhHlOo7ly0UHJfTx4Vjd3TnW9es51p07OdYFCzjWw4frTGZmaO5cjrW8HOXmKvAqtRpUNo1BejqKihKl+IwZqH9/dPYsxzp/Pie5d+x4idBvCMUhFI6Qn4vLJdy6ZUsIQh8j1AuhDxDq5Om5Fbc6O/8XoXfhuNjay8fHD7c6OJxHyBnKFJcct3NnFm6Vks2pU6KDpqbI2hpNn46Cg1XpME0Dlc3b8c8/0t0e6GJxhQHHXiCUCF0whLa6ukbjVkfH7WI/19LPzwG3rlvni1t9fdfh1o0bPXCru/sm3Ormthm3btrkjltdXEBL86A+4lol+vuX4taZMzlX9PAh2rULJSZKdykp6gWVTf3IykI//YSWLRPdm2GYsW8fbqzeujUPT8ElS0Lx9D1wYC5unTMnvAHrsmW7cau//2rcCkrArRs2bMOtAQGrcOuSJXtx648/fo9bV6zYhVs9PG4jdB+uhb0kf//a4zCsgrET9AYpGgCVTf1YtQpxhfEcoT0ILUJoEEJGJ09OwK1ffHERT9BLl/5PYjI05M2e/RNuTUuzgoSOjJxx5sy4+PhPsrPNcWtNjR6PZ8jnG1RX6wsEurgJWFTUKjW1Z0qK9bVrn8bF2f311/u41cvLydb2VteuT+CkcGooH7fa2cXhdT5+fLL4uJH4ihbNmZPK7TpyvJGdjR49IhMI9YS2y6aoCB09iubNQ/v3c45HReXiaTRoUBKego8fW+BWyFSp5I6J+erOnf75+e2EQh2p1FcB4aQvX7atrHwHPzh58nFT0zJJnR8+7IVbP/roPn5FZ8+eQahOKOvXiw6am4smIY4cQQUFqg6TukF7ZXPpkmgaV0+vNlHGjIFjmQiBer5FqHNeXgc8jeD+DY0Anpdjx8auXLlzz56lV658/vx5e9Vro3HMze0EFQ4OXgytmeQgCExfv1pysTo6QlC+2NRZ7I39trZV3M4h6eCRhvbKJj6e0w0zNv4HFwawe/cMibVbt6zMzA+IJ72SWFZm6unpPGnSCWg24WL79HmAW0tKWujp1eC+SkvjeDImBqWkEIoiIWiFbB4+RBs3iqa/MGTU1Pi0bVuMZwPchvF08fZe7+i4PTp6IrQ8xDNbZYSW8+7dfvgRGCPhXrK0TEfIFqHt4EPWldB5g+NWVsjFBf3xB4kAqxyaLJuqKtEE0cCBkr4HysqC+6Q7QrVpAYP1BmZ7KVleuDDy00+vGRjwWS9B1xSz9ktKCsV9CE5+8oR04JUPTZaNQACDdU5PzNd3HZ4QR49+AwehM7Z8eRDcUysqjInnqNoSOnIxMV/Z2wdevz4cP+7k5IV7GIaLUhAKScReydAo2RQUiJaQYCh1cUluYEIMdJKWZkU8I5s1razScA8HB0Njvhc8zwbgzh1kYSF6HFxcTCIhlAYNkU16uujRpLGxqFcmRrL4GYtJRkZ3HR2hJKj6+tVaNVBRNgUC3eDgxSNGXNbVFYB7jYyqXk3BmYj9n/z997WeNzFBS5eKBpmagWYvm/v30cSJSFdXMmAtFgoH4qH97LOrbDsTELCqGc0UNy/CzSgw0F5qTUNpqZmpaQXeFnl6kk4XBaHZyyYxkTN6AcbF2eHBS0mxTk3tSTyxtJB79y7B42JiIigsJJ0uCkKzlw1CmZ9/zlkYMnZsLPGMoQSuWbMD7yHb2+9CaKH4mbIIQqFoqXh8PNnkaSQY0hWQD7dvgyrQX3+xf8oQr/DVP3dutCQ2LVqUSK0ppiTI9HTLVasCICh6ejWvnhfri6OWcfRobcjs7EQzB80LDOkKyIrcXNELJDo67JriEoS+Q0hPEp6BA5PNzbP9/BxKSloQzxVKKcIgJzZ2LH5EINDv2zdHcrMzMBC1PM+fk04ymcGQroBMgEbGxKSuG6arK/jjj754GJ4+7YIvsqJUcx4+PE0STT094auegujFWD6fdLbJAIZ0BWSCQID69+csi5o4MZp47CkbzalTo/CbIB5ZG5tm8ISUIV0BGfHT9eucV1ysrNKg6ScefsrGUSDQjYiY1b17htQiUWBQEOlckwEM6QrUj5Mn0c8/sz/TEBrB+nrWrAhwa9u2L3ftWkG7ZBpAPt8AQtm6dSG2jCNVIEhrODfUAQzpCkijvBwtXCjyoJmZMDt7N0J171rl5nZat8731XNoSg3hy5dtly3bDc0O9NaSkweKI+7Fvq1dU4NcXVFpKemkfA0M6QpwcPMmsrSsa69Hjz5HPKiUquH9+x/t3r0MOzIAoT/d3NiVH2r3Pg9DugIcjB4t/ch/374FxCNKSYRJScP09WtnCwwNUWAg6ezEwJCuAAd5eYXt2xfispHa9oVSS/jPP//q1euh1D300iXSCfoKDOkK4ICW+P2LF79gZyRNTMpDQxcSjx8lEd66ZWtmxtnYbfly0umJgSF7+sRE9OwZ+/OAZPS/ZYvr4ME309MtiQePkiAhAaytU1jNDB36Pz7/INFU5YAheO6zZ0VvyFhbC8vLN+D+Egh06fwyJZDHM1y1KqBjx2fPnnUUH/kBodpHoU+fEsxcUVXI4MgR0Uok9l4yfvzp17fSo6RkyX3kMA2hqtOnkZGR9J70qgRD5KzBwXUvlr1aVR5IPDyUzYIJCcv+9S+heDGbaMNhImCInBXuE5IFfJK3/KV2kaSkfJ1//NEXX1UAN9+wMAIJzBA4pwiFkZEbJOuRRoy4TBeYUcrCefPCpGale/Qg8JUERtUnFKEcIRs49aFD00E5EyacrKoyIh4PymZBHs8QRsISzXz8sYDIWzqMys7E47H/5yM0RuKFhIRhNTV6yvAvpaaSzzeYNOkEaGbw4JuFhVPFGaVqMKo5TUGBqDEND4efs4n7nbK5s7pa38NjY1mZKRJ92mTmW9NP4WBUcA6hEH31VW2r6uTkReTbFZQazNLSTZBmMMLx8RG90agCMCo4h7c3ZwwHLWx5uQlxX1NqDAUCnatXf7G2FmWXl5cKMlp0VuUiPl70ET9cNm3aFDx50pW4ryk1hr/+OqZ16wLJbh4qeMuAUfYJ0tPR0KH4jvRCqU1MKCmbwqdPu0i+hsCyVy/RV4qVCka5xYshEOzZvt3RyEj0RS5nZ0/ijqbUMEp9CRgo9UlJhYNRbvEiPBVvpM38/vuHS5bspdPNlAonn28wcGDtpyVatSpcseJcVVWVUnOaUWrpYkwn7lZKjWdqak8zs9LVq/1v3bJxdXUNCQmpVObaAUZJ5T54wO6ccJW4Qym1hIWFrdkfYWFzQTmhoaF8pW1VyCipXBsb1K4d8vf3pwtnKFXMJ0+6uIoREREhUM5zHEYZhV67Vjc4MzfPDgubR9yVlFrF8PDZzs6eI0ee37IlQRkZziij0PHjOdMaQ4YkEvcjpfbw5cu2K1cGvPNOpXizqLQbN24oPMMZhZf48GHtdwEkPHZsCnFXUmoJ09KsTEzK8eeEDg6BmZmZik1yRrHFAS5fRv361WnGwuIxfeGZUmUUCnUsLdPxu/ann17z8fEpKytTYJIzCiwLQ9Xt25/Y2wey+zUTdyWlVnH7dkdcNmZmpZs2uUVERCgwvxkFloWh9jOAPJ4hkLgfKbWK+fntDA154vVpvJ49UydOPOHi4u7q6pqUlKSo/GYUVRAXi4n7jlKb6efncOjQ9Pj44a4YPD09SxW0DTujkFJeQ2fijqOkLClp4crFsWPHFJLfjEJKYVFcjGJjUUFBDnF/UVKy3LFjjZRysrOzm57qTNOLkODKldopv169Hs6bFxYdPZG41yi1nEePfiMlm/2KWB3NNL0ICYKDOY9rZs2KIO41Si1nTMy47747YGcX++23P0uU0/THOIxCBMNi7VqObNzdNxH3GqXW8tixKe3bP5dko43NbxLZHDhwoImpzihCL7WQWlNz+PA04r6j1FpGRU3Fs7F37z/xrtqLFy+akuqMojQDGDasbjd04O3bA4j7jlJrmZAwDJdNly5PcNnExcU1JdUZRWlGgpKSrpmZHyQlDaIPOikJMiOjOy6bVq2KcNl4e3vX1NQ0OskZBQrmFQyIu4ySsqLCuEePR336/NGhQ17nzjkWFo+lptTS09MbneKMAuXyClQ2lOrCmhpd1zcgJiam0SnOKFAur9BKqY6gpJSdlZXvvEk2O3bsaHSKMwqUyyt0Lilp8fixBf2QICVxvr6+BkdJSUnjUpxRoFzGj0cdOiADg2o6k0apJszN7dSAbB48eEBeNpL90elzG0rivH//Iw+Pjdu3/7Bgwb61a323bKlHNhcvXiQvG6lVAm5um4n7jlJr6eXlhGejtXXy67KJiooiL5uQEI5sZs78hbjvKLWWkycfx7Nx3Lgzr8smBFKWuGyuXq2tYrt2+V9/fSo8fA5x31FqLc3Ns3HZLFoUosDJNEaBsiksRAcPorQ0+NmFuNcotZn5+e1wzejq1ri4bH1dNt7e3uRlg4G+FE1JmA8f9lq71tfSMl1fn9+x47N6Z9K2bt3auPxmFCuXV4gl7jVKyoiImaCNjRu3rlixq1nIpgqhlmzV6Zc5KImwstJo61aXetWitp00lJOzwdPTuUePR0FBy4l7kFILyX6xo2GoxZQAi+RkZGeH9PSE7Gise/cMuisnpSq5a9eK58/b79mz5K2yUYsJaBav7wEdFTWVuCsptYTR0RPZjQX79bu7eHFww7JRi8edEkitshk8+CZxb1JqA4VCHVALnnu2tjcbkI1aLK6RAP++TcuWxdu2baD9NEoVUGr/AODs2eENyEYtlnLisLVF77yD1q17UlDQhrg3KbWEs2ZF4JoxN89quJOmFi8O4EhORjk57E/6yVtKFRE6NW5umyTft/nuuwMNaEbdXlOTQu0H1ikplU0ez8DPb42Tk9eQIf+zsMhouKlRt5eiX8ceOFF6uuWqVQH06Sel8njmzDiJKjZvdmtYNuq2BUc92L17F9t0Ojt7EncupYYxOXkgEt2XuzesExxquOETB0+fotGj60ZpOjrC2NixxB1NqTH89dcxurqC8eNPubtvlF02are9oBTi45GeHmdOsE2bguxsc+LuptQAPnrUo1WrolePOooWLNgno2zUaDPbN8HbmyOb0aPPFRe3JO5xyuZOyKKePVO579UI5s4Ne6tm1Gvr9DdBKKxbN7B8+QW6ERSlQpiQMMzYuAKXjaVl+ubNb29q1OtDHQ2gsBB1746CguAnH6ExxD1OqRmMippibFz7lKZt25dOTl5v1YzafRaqYfzzj+RnOUI27GUnJg6hU9KUjWNOTqdt2zasWLEThjdGRpVvehdNCmr3EUJ5UIjQoKioqfr61RMmnKyqMiIeA8pmQT7foKSkBRLvG+jtvZ5Vwtq1vnPnNrQgQAJ1/OStXIiKKgfNsM3riBGXS0vNiIeEUs0JSTJq1PkhQxJTU628vJxk0QkO9f/A+lsQFYX09TnTa4MGJVVUGBMPDKXaEpoXyUsBFhYZGzfWsxNNw0hKSlJUAjOKKkguBAcjXV2ObJYu3UM8MJRqywcP+nTt+gRPmB49UjdtesvyGRwREREKTGBGgWXJhSNH6r5Y+OWXD+jEAGUDzMrq1q5dvtQjmu++OyijZnx8fMrKyhSYvYwCy5IXZ88iY2PUrx+CDmd+vo/keQ78oM92KHFCPnh4OOvq1rCaMTTkzZr189vlIoa7u3vTH9RIgVFscfIiMVG0aI3F3bthRUWiT0o5Om4fPPhmerol8WhREqSkAwJZ8eOPi0EA48bFgGZMTUu///5H2btnN27cUHjeMgovsSk4c+ankJCFOjqiXW9MTMpDQxcSDx4lEe7fP9/C4nFubqdHj6y8vR0lGvjiiwurV/vLrpno6GhlJCqjjEIbjawsgalpFd6FnT9/P/EQUqqSIBU7uzg2+v373673uzQyIiIiQiAQKCNRGWUU2mh89hlneg0YGTmDeCApVcaUFGvJimaWo0ada5xmQkND+Xy+khKVUVK5jcPNm8jSss5lQ4cm0LkBrWJVlVGPHpxFzXp6NXKNZFiEhIRUVlYqL1EZ5RXdOJSXo4ULRf4yNq5au9Z3586VmZnvsz5NT7d0cPBjpw0oNZKZme/b2wcwjFAiG+inybJAE8e+ffuqqqqUmqWMUktvNGAgFxnJP3CgdqHRiROTSkvNxo07wy50DQpaTlshDSCfbwChXLNmBxIvnIEos+G2tk6BQJuZlc6c+Yu87QzkDI/HU3Z+Mso+QVNQU1Nz7Ngx1h1z5hyQerMiK6sb8cBTNo4CgW5ExKzu3TPE0RSGhCzcts1Zkvrr13vb2NyC/8qrGciWpuwQIDsYFZyjibhw4YKLi3ubNi9x2fTp84Du9Nl8aW8fKNc+gLIA8kRlOcmo7ExNwcGDaQYGPNzRfn5rBAIdSRiKi1vS5TnNiCkp/fEBDPA//znSaMF4eHjcvXtXlQnJqPJkTcGdOy9sbR+wvu7UKQecFRhof/t2f7bNmT9/f7duWX5+DuzLGJRqRRi3hIXNEwpFtzmIF0QNYte79wNMNsLhw+Mbp5mAgIC8vDwVZyOj4vM1BZWVlZ6ev0KHGN8POyBgVVzcl/r6fDYALVqUODj4lZfTfUDVguyekhAUCM2pU1+lpAyAeLGBW7p0N3sThGFqI6aYWURGRip1ovlNYFR/yiYiKSlp27ZtuO+GDEnEm3todmiHTR3o67uOXSfF1H4gLE0q6UeMuCTLRjP1AnJAge/PyAuG1Imbgr///js4uPaLP46O26WGPRs2eODBe/Kka2pqT+I5pIVMSBgmtebjrd9pkhEQfcgBghnYLGWDRJtICa9fvw5jQegD9Oz5UHJX09evBiEFBy9OTrbm8QzgAleu3Mm+PQrdg+fP2xNPJo1kXl4HGK5Mn36I/SN4HvwPUXjvvRe4bPr2/b2JgoGIQ9wh+mTTr7nKhkVBQUF4uGics3JloI3NLQMDfv/+dyQu9vR0jo6e0Lp1Ab5S48aNocSTTJMYHj5nxIjLuroC1sNxcWPOnBkHnmdDMHZsLHscegQ2Nr8tXy7T5jJvAsQaIk466URo3rJhce/ePT8/P1dRh83bwcEPd/Q33xzB73YtWxZL7ZKTmfkB8cxr1pw06QTuYVvbW7j/nZw833vv+ejRZ+VdICMFiC9EmXSi1UETZAPg8/mXLl2CFlzK3VZWadyg3rx8eUReXm1XLS3NSjxUzVi+PAjukXQPkAZYVmYaE/OVvX3g/v3zJQfBkzCSxD1sbFyxaZN7UxQiBYgpRFZ5a5kbBw2RDYvi4uITJ064u9eFzc4urmPHXElQJWucoCN+/vzIzZtd8ZB//fUp4tmphrx//6NPP70GHWDWS8OHx+fkdAbvgQ9dRe2JF3R9cTc2/LlM2QFxhGhCTEmnVT3QKNmwgO5vdHQ0Lh7oUkPgO3Z8JnUjfP/9v/B4+/uvxtMlKmrq+vXe0dETYbxLPHdVRrjYq1c/w488fdoF95KOjmD9ek6Pi23S27R5CU5etixIIYKBCKrJMKZeaKBsWBQWFp46dQoXjxQg9pKBLEs4curU1/fufcTudYj32s3Ns6F3RzynlUcfnx8mTz7ObqoEDUtl5TtI/HQfvAE+efddzq4xU6cexT25aFGIomaWIV4QNYgd6fR5CzRWNiyKiopOnz69dWs9W9HBeKZr12y4d7KpYGpahlt37lzRsiXnNcN79z7G82zVqoCVK3fu2bP0ypXPm9G89rNnHaHCwcGL4Qd+vHfvP/GL9fZ2BA9IvDFwYDJu7dfvzmvubCogRhApiBfplJEJGi4bFtA/jo2N9fKqZzIHWphvvjk6YMDtf//7f/hx9mmPhAYGvFOnxicnW+fmdqquFi1BYBeMSIh/R14g0D1zZtydO/3z89uxC7FUTDjpy5dtpZbnrV37XzOzUkmFjx2bgkQbKenBFcF1ffbZFfxyRo06j3tjypQodh5ywIAUaGocHbcrUDAQF4iOeo5h3gStkA0LPp+fkpISEhIiSywnTDiJp1GXLk8kJje3TR4eG3Br69YFeILCiFliMjTkDR9+HbeCluBmHxk5A6QVH/+J1L5WIDkez5DPN6ip0YPfUqorKzN99KhHSoo1/MO4OLvff/8Qt0ZEzLK1vQUdLTgpnNrXdx1uXbfOF6/z9Om/QFMJ18Je1OjR53Brr15/4t5wcvKUcT9/uQCxgIio2yyZLNAi2Ujw7NmzmJgYT0/PBiLq4PBfGNvY2PzWseMzGALZ2t7ErTNnRuBJ1rnzUx+fdaGhC44fnwxDoIMH5+DWIUMS8fSFjMetkK+49fTp8bh1xoxI3Lp//3zcCv1M3BoYaI9b584NgxYP6gO1grpNmnQMt374IeeB/Zw5B9njuro1HTo8++STRq5HlgXgefA/RIF0IjQe2igbFjweLykp6ccf3772duNGjx9+4HRLRo68gKfgxx/fxa1slwZL0PshIQsjImaeODHx7NnRXl7rceuYMXEwNPr773cLC1vBEPzQoWlSg++KCmM4Dlb4O3v3fo9b7exir18fDmVCyVD+woUhuBWGK3itZs/+Cbe2b/8ctzo5ednZxS1YENqILcllB3gbfK6Cl5aVDe2VjQR5eXmXLl0KCpJj5nT16h0wIhox4jJIokOHPKmRwMiR5/EEHTgwCbdOnBjNldw93ArF4tY+fR7g1mnTDuPWHj1SceucOeHcNjAHt4q3thB1GqH9hKbmiy8uyn69TQT4Fjys+rdilAcqmzrk5+dfu3ZNlvanYUDvzsLi8bvv5hsZibZKhNE2bv3yy1+5okrGrVOmcLpSUi3GrFk/49Zu3bJw65Ile7AxVZWUdfNmUc+ziZcmF8CT4E/wKunAKh5UNvWgsLDwxo0boaGhbm5yfAqiXjg7b4PxNH7k229/trZO7tv3d0vLtK5ds6W2z5s8+TiMLmA0paMDFErJZsGCfW3avISxh7l5tqVl+tChCbgVOpPz5u23tw/csEF6kZHKAB4Dv4H31P/ZS1NAZdMQSktL7969e/LkSX9/OfYd1kKAf8BL4CtFfa5MzUFlIyuKiopu37594sQJdrU1BfgBvAE+aS7PKBUIKpvGoKCgIDk5GZJm9+7dTe/INRfAlcL1wlXDtavzgjEVgMqmqaiurs7JyUlKSoqJiQkJCXn95YXmC7gWuCK4Lrg6uEa4UtLOVhdQ2SgYQqHwxYsX9+7dO3/+/OHDh/fu3dvwc1X1AdQTagt1hppD/eEqiL97rLagslEFKioq4G59//79a9euwdD5wIEDMIaud4GpCgDnhbNDHaAmUB+oFdQNakjaSc0JVDYkwePxYDydm5ubnp4ON/jExMSLFy+ePn0abvnh4eFhYWGhoaHQAgQFBQUGBsIQ3MfHx8vLC/IehhnwX/gNR+A4WOHvwN+Evw//Cv4tlADlQGlQJpQM5cNZ4Fwa8IReHUBlQ0EhN6hsKCjkBpUNBYXcoLKhoJAbVDYUFHLj/wGBCA7WRha7iwAAAABJRU5ErkJggg=="},9042:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAAEGCAIAAADzJQ6dAAADXElEQVR4nO3SwQ3DMAwAMWv/odN0gcLIJ2eUhAYQpFsXhK23F4BfBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSDg50Frtm5u13PXRwoPfdL7M331ud6dS9L4EKNE6gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk0TqEDTBCrQNIEKNE2gAk2bmcWe+1Zvv+uhgwPlHwiUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkCJU2gpAmUNIGSJlDSBEqaQEkTKGkf195C8c1io/AAAAAASUVORK5CYII="},4255:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAEgUlEQVR4nGP4TyXAgEfu+/fvQgIif/78IcGgvvamCZ0tZ86cRZMOCw7Ho/nfv3+fP39GGHTixMlX9y/t3rTy6c2zC+YtRFMtJiIBZz99+hRNlo9H4NevX1CDAnz97189+eLuxcbqsie3zh06dAho1d+/f4FSnz6BLBQWFLt8+UpkeJSVufX9+/dfvXr17u07iEGPHj5CuGj14rn3r5zITk1+fONMbnrKzfOHX79+DRSPjYkHkob6Rs+v6CrKqUhJyACRpJj0siXLFi9aAtFvqG+MMOjI7o27Nq7YvHrR7fNHivOyF82cVF6QA3bOJzVl9RmTEkqKSyCqgU77/7v/+gk1RXmVb9++6+kYoAT2iX1bHl4//fzO+WXzpt+/egLou1MHtycnpQClmptafr9LADJCgsOA0WdvIiEiJC0jKSsuKiUjIXn82PHHj58gDDqwfe2Dqyf3b117+cTeC8d2H961YfqErlsXjgBDMT0l48cz11s3bxoZmEyeNPXKHt2crFyglvAQF2N1mc6Orv3790OiD2RQTkbaw2ungDqBcXds39b2xtqDO9bFR0WkJMRJikv/fRsyd848IENWSv7NXQegegkxqZwMG2trl6VLl718+VJaUhbqooOHDj+7c/7R9dNFOenTJ+cf3bPp8Y2zt84f3rtlFVD//78vpcSlzY2l/n8Kuna2HhTe4tILJihA4mvm5D6g9//DE2RUaFh9ZdX/Dzpb56o+v26QEBUzY0JXe0O1hJj0pxcTrxxT279JRVhIeu3qJcCI9/XUkBAVBybFXRtXXjq5D5L0EVlkcofw06sSJ3cr/XstfnJ//N4dHf3daWbGOuV5CgFe8l1tWb/eJS+cKv3++WxlBZX+rrbp/R1L505LTYhDBDYEnNqi8PN16OUjcpLikktn6+lqymipS/96n/TxacS7u+aiwuKvH+YtnqGiKCtjY2EdFhh4+sD2u5ePr1u7HsUgYLBv27Z7Yn//mjWbgdylvSofH1qF+cn9/XH499cD///f6m9V9HGTXztVxcZUenqlakNV2apFs5qqy1DSERrg5QFmruMLNs99dVPt50vzXy+NNiyRb6kxOLFLSUtN7sw+uRc3JTxc3F/eu3jk8BGcBqnISQgKyPz/EaLSOUc13PfKUdXPj8TuHtP//SF7Zr92arDqlSMq3184ZiYnNtQ1Av2B3aDK8so3d33/fAjPrU5gaJtiWNNiNndFSoz0wxvFv9+Y/ngV8PaOCtCPv95Gx0ZHobkAYRAwZ4mLSje0ZtQtnM1Q339+v8rnh1q+ocp2lgpyMrLfPyz++MD890u+Pz8f/vpY393RgdMge0ujtUvcu+rkGLOrVs9X/vlC69QujadXpFKildctUpjUoJiQkOFtJzq5UbYyTer+vfvYDQLmvY5ilT/fjv16k/bwtEplsfSrW4r8fNIiQjKBNvInT5yExCxcGzIbxSBVZTVDLdnvz3U/P9K9fERZTV5WRFBSWVE1KSH5P3EAnPv3H9izZ++2rdu2bN66f/+Bd+/eEakZi4soBwCGkvotk1T0mwAAAABJRU5ErkJggg=="},2678:function(e,t,n){t.Z=n.p+"assets/images/parts-19a410f2ec2666340b572ed9d475ee4b.png"},5464:function(e,t){t.Z="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAYCAIAAAAQxLheAAAA/0lEQVR4nO2TPQqDMBiGFVEHFxcP4SRSt55A8ALewjM4urg6eALrpJujbjqICE46eIUOShFpA8GPtIX+gQ7FZwpvyPuEL4S6bgK1a3bN9ppxHKkFnuc1TQvDEHY5jqPuieP4Oadp+iNN27Zo3fe9bduSJIEJ1eV5fiaYpgnnWZaR+RcajOu6iqKApmma5wqUl2X5YmLvNUVRsCw7zzOuQ9bTQhRFoHEcB3Ly+KearusYhkE5rlNV9bhgGAZoZFk+LARB8LUmTVNUAXVrDc2yLNM0V9QMw+B5niiKdV1DXVVVFwJ4s180GEEQdF1PkoS89cO/8X3/F8167Jpd81eaGw9zqXkBHOQhAAAAAElFTkSuQmCC"}}]);