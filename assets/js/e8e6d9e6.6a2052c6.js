"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[4743],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var o=n.createContext({}),s=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(o.Provider,{value:t},e.children)},k={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=s(a),d=l,N=u["".concat(o,".").concat(d)]||u[d]||k[d]||r;return a?n.createElement(N,p(p({ref:t},m),{},{components:a})):n.createElement(N,p({ref:t},m))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,p=new Array(r);p[0]=u;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:l,p[1]=i;for(var s=2;s<r;s++)p[s]=a[s];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4384:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return o},default:function(){return d},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return k}});var n=a(3117),l=a(102),r=(a(7294),a(3905)),p=["components"],i={sidebar_position:5,title:"Language Reference",slug:"/Rascal"},o=void 0,s={unversionedId:"LanguageReference",id:"LanguageReference",title:"Language Reference",description:"Synopsis.",source:"@site/docs/LanguageReference.md",sourceDirName:".",slug:"/Rascal",permalink:"/docs/Rascal",draft:!1,editUrl:"https://github.com/usethesource/rascal-website/tree/main/packages/create-docusaurus/templates/shared/docs/LanguageReference.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Language Reference",slug:"/Rascal"},sidebar:"tutorialSidebar",previous:{title:"Concepts",permalink:"/docs/RascalConcepts"},next:{title:"Libraries",permalink:"/docs/Libraries"}},m={},k=[{value:"Declarations",id:"declarations",level:2},{value:"Module Declaration",id:"module-declaration",level:3},{value:"Import",id:"import",level:3},{value:"Program",id:"program",level:3},{value:"StaticTyping",id:"statictyping",level:3},{value:"The Type Lattice",id:"the-type-lattice",level:3},{value:"Advanced Features",id:"advanced-features",level:3},{value:"Reified Types",id:"reified-types",level:3},{value:"Type Constraints",id:"type-constraints",level:3},{value:"Type Parameters",id:"type-parameters",level:3},{value:"Algebraic Data Type",id:"ADT",level:3},{value:"Variable Declaration",id:"variable-declaration",level:3},{value:"Function Declaration",id:"function-declaration",level:3},{value:"Variant 1",id:"variant-1",level:3},{value:"Variant 2",id:"variant-2",level:3},{value:"Variant 3 and 4",id:"variant-3-and-4",level:3},{value:"Body types",id:"body-types",level:3},{value:"Parameterized types in function declaration",id:"parameterized-types-in-function-declaration",level:3},{value:"Overloading",id:"overloading",level:3},{value:"Modifiers",id:"modifiers",level:3},{value:"Syntax Definition",id:"syntax-definition",level:3},{value:"Action",id:"action",level:3},{value:"Ambiguity Detection",id:"ambiguity-detection",level:3},{value:"Ambiguity Diagnosis",id:"ambiguity-diagnosis",level:3},{value:"Disambiguation",id:"disambiguation",level:3},{value:"Associativity Declaration",id:"associativity-declaration",level:5},{value:"Follow Declaration",id:"follow-declaration",level:5},{value:"Precede Declaration",id:"precede-declaration",level:5},{value:"Priority Declaration",id:"priority-declaration",level:5},{value:"Reserve Declaration",id:"reserve-declaration",level:5},{value:"Parse Trees",id:"parse-trees",level:3},{value:"Symbol",id:"symbol",level:3},{value:"Alias Declaration",id:"alias-declaration",level:3},{value:"Annotation Declaration",id:"annotation-declaration",level:3},{value:"Tag Declaration",id:"tag-declaration",level:3},{value:"Patterns",id:"patterns",level:2},{value:"Concrete Patterns",id:"concrete-patterns",level:3},{value:"Descendant Pattern",id:"descendant-pattern",level:3},{value:"Labelled Pattern",id:"labelled-pattern",level:3},{value:"List Pattern",id:"list-pattern",level:3},{value:"Literal Pattern",id:"literal-pattern",level:3},{value:"MultiVariable Pattern",id:"multivariable-pattern",level:3},{value:"Node pattern",id:"node-pattern",level:3},{value:"Regular Expression Pattern",id:"regular-expression-pattern",level:3},{value:"Set Pattern",id:"set-pattern",level:3},{value:"Tuple Pattern",id:"tuple-pattern",level:3},{value:"Type Constrained Pattern",id:"type-constrained-pattern",level:3},{value:"Typed and Labelled Pattern",id:"typed-and-labelled-pattern",level:3},{value:"Variable Pattern",id:"variable-pattern",level:3},{value:"Variable Declaration Pattern",id:"variable-declaration-pattern",level:3},{value:"Expressions",id:"expressions",level:2},{value:"Values",id:"values",level:3},{value:"Boolean",id:"boolean",level:3},{value:"Boolean All",id:"boolean-all",level:5},{value:"Boolean And",id:"boolean-and",level:5},{value:"Boolean Any",id:"boolean-any",level:5},{value:"Boolean Equivalence",id:"boolean-equivalence",level:5},{value:"Boolean IfDefinedElse",id:"boolean-ifdefinedelse",level:5},{value:"Boolean Implication",id:"boolean-implication",level:5},{value:"Boolean IsDefined",id:"boolean-isdefined",level:5},{value:"Boolean Match",id:"boolean-match",level:5},{value:"Boolean Negation",id:"boolean-negation",level:5},{value:"Boolean NoMatch",id:"boolean-nomatch",level:5},{value:"Boolean Or",id:"boolean-or",level:5},{value:"Constructor",id:"constructor",level:3},{value:"DateTime",id:"datetime",level:3},{value:"DateTime Equal",id:"datetime-equal",level:5},{value:"DateTime Field Selection",id:"datetime-field-selection",level:5},{value:"DateTime GreaterThan",id:"datetime-greaterthan",level:5},{value:"DateTime GreaterThanOrEqual",id:"datetime-greaterthanorequal",level:5},{value:"DateTime LessThan",id:"datetime-lessthan",level:5},{value:"DateTime LessThanOrEqual",id:"datetime-lessthanorequal",level:5},{value:"DateTime NotEqual",id:"datetime-notequal",level:5},{value:"Integer",id:"integer",level:3},{value:"List",id:"list",level:3},{value:"List Append",id:"list-append",level:5},{value:"List Comprehension",id:"list-comprehension",level:5},{value:"List Concatenation",id:"list-concatenation",level:5},{value:"List Difference",id:"list-difference",level:5},{value:"List Equal",id:"list-equal",level:5},{value:"List Insert",id:"list-insert",level:5},{value:"List Intersection",id:"list-intersection",level:5},{value:"List NotEqual",id:"list-notequal",level:5},{value:"List Product",id:"list-product",level:5},{value:"List Slice",id:"list-slice",level:5},{value:"List Splice",id:"list-splice",level:5},{value:"List StrictSubList",id:"list-strictsublist",level:5},{value:"List StrictSuperList",id:"list-strictsuperlist",level:5},{value:"List SubList",id:"list-sublist",level:5},{value:"List Subscription",id:"list-subscription",level:5},{value:"List SuperList",id:"list-superlist",level:5},{value:"List in",id:"list-in",level:5},{value:"List notin",id:"list-notin",level:5},{value:"ListRelation",id:"listrelation",level:3},{value:"ListRelation CartesianProduct",id:"listrelation-cartesianproduct",level:5},{value:"ListRelation Composition",id:"listrelation-composition",level:5},{value:"ListRelation FieldSelection",id:"listrelation-fieldselection",level:5},{value:"ListRelation Join",id:"listrelation-join",level:5},{value:"ListRelation Reflexive Transitive Closure",id:"listrelation-reflexive-transitive-closure",level:5},{value:"ListRelation Subscription",id:"listrelation-subscription",level:5},{value:"Variant 1",id:"variant-1-1",level:6},{value:"Variant 2",id:"variant-2-1",level:6},{value:"Variant 1",id:"variant-1-2",level:6},{value:"Variant 2",id:"variant-2-2",level:6},{value:"ListRelation Transitive Closure",id:"listrelation-transitive-closure",level:5},{value:"Location",id:"location",level:3},{value:"Location AddSegment",id:"location-addsegment",level:5},{value:"Location Equal",id:"location-equal",level:5},{value:"Location FieldSelection",id:"location-fieldselection",level:5},{value:"Location GreaterThan",id:"location-greaterthan",level:5},{value:"Location GreaterThanOrEqual",id:"location-greaterthanorequal",level:5},{value:"Location LessThan",id:"location-lessthan",level:5},{value:"Location LessThanOrEqual",id:"location-lessthanorequal",level:5},{value:"NotEqual",id:"notequal",level:5},{value:"Map",id:"map",level:3},{value:"Map Composition",id:"map-composition",level:5},{value:"Map Comprehension",id:"map-comprehension",level:5},{value:"Map Difference",id:"map-difference",level:5},{value:"Map Equal",id:"map-equal",level:5},{value:"Map Intersection",id:"map-intersection",level:5},{value:"Map NotEqual",id:"map-notequal",level:5},{value:"Map StrictSubMap",id:"map-strictsubmap",level:5},{value:"Map StrictSuperMap",id:"map-strictsupermap",level:5},{value:"Map SubMap",id:"map-submap",level:5},{value:"Map Subscription",id:"map-subscription",level:5},{value:"Map SuperMap",id:"map-supermap",level:5},{value:"Map Union",id:"map-union",level:5},{value:"Map in",id:"map-in",level:5},{value:"Map notin",id:"map-notin",level:5},{value:"Node",id:"node",level:3},{value:"Node Equal",id:"node-equal",level:5},{value:"Node GreaterThan",id:"node-greaterthan",level:5},{value:"Node GreaterThanOrEqual",id:"node-greaterthanorequal",level:5},{value:"Node LessThan",id:"node-lessthan",level:5},{value:"Node LessThanOrEqual",id:"node-lessthanorequal",level:5},{value:"Node NotEqual",id:"node-notequal",level:5},{value:"Node Slice",id:"node-slice",level:5},{value:"Node Subscription",id:"node-subscription",level:5},{value:"Number",id:"number",level:3},{value:"Number Addition",id:"number-addition",level:5},{value:"Number Conditional",id:"number-conditional",level:5},{value:"Number Division",id:"number-division",level:5},{value:"Number Equal",id:"number-equal",level:5},{value:"Number GreaterThan",id:"number-greaterthan",level:5},{value:"Number GreaterThanOrEqual",id:"number-greaterthanorequal",level:5},{value:"Number LessThan",id:"number-lessthan",level:5},{value:"Number LessThanOrEqual",id:"number-lessthanorequal",level:5},{value:"Number Multiplication",id:"number-multiplication",level:5},{value:"Number Negation",id:"number-negation",level:5},{value:"Number NotEqual",id:"number-notequal",level:5},{value:"Number Remainder",id:"number-remainder",level:5},{value:"Number Subtraction",id:"number-subtraction",level:5},{value:"Range",id:"range",level:3},{value:"Real",id:"real",level:3},{value:"ReifiedTypes",id:"reifiedtypes",level:3},{value:"Relation",id:"relation",level:3},{value:"Relation CartesianProduct",id:"relation-cartesianproduct",level:5},{value:"Relation Composition",id:"relation-composition",level:5},{value:"Relation FieldSelection",id:"relation-fieldselection",level:5},{value:"Relation Join",id:"relation-join",level:5},{value:"Relation ReflexiveTransitiveClosure",id:"relation-reflexivetransitiveclosure",level:5},{value:"Relation Subscription",id:"relation-subscription",level:5},{value:"<code>Exp_0 [ Exp1, Exp2, \u2026\u200b Expn]</code>",id:"exp_0--exp1-exp2--expn",level:5},{value:"<code>Exp_0 [ Exp1]</code>",id:"exp_0--exp1",level:5},{value:"Variant 1",id:"variant-1-3",level:6},{value:"Variant 2",id:"variant-2-3",level:6},{value:"Variant 1",id:"variant-1-4",level:6},{value:"Variant 2",id:"variant-2-4",level:6},{value:"Relation TransitiveClosure",id:"relation-transitiveclosure",level:5},{value:"Set",id:"set",level:3},{value:"Set splicing",id:"set-splicing",level:5},{value:"Set Comprehension",id:"set-comprehension",level:5},{value:"Set Difference",id:"set-difference",level:5},{value:"Set Equal",id:"set-equal",level:5},{value:"Set Insert",id:"set-insert",level:5},{value:"Set Intersection",id:"set-intersection",level:5},{value:"Set NotEqual",id:"set-notequal",level:5},{value:"Set Product",id:"set-product",level:5},{value:"Set Splice",id:"set-splice",level:5},{value:"Set StrictSubSet",id:"set-strictsubset",level:5},{value:"Set StrictSuperSet",id:"set-strictsuperset",level:5},{value:"Set SubSet",id:"set-subset",level:5},{value:"Set SuperSet",id:"set-superset",level:5},{value:"Set Union",id:"set-union",level:5},{value:"Set in",id:"set-in",level:5},{value:"Set notin",id:"set-notin",level:5},{value:"String",id:"string",level:3},{value:"String Concatenation",id:"string-concatenation",level:5},{value:"String Equal",id:"string-equal",level:5},{value:"String GreaterThan",id:"string-greaterthan",level:5},{value:"String GreaterThanOrEqual",id:"string-greaterthanorequal",level:5},{value:"String LessThan",id:"string-lessthan",level:5},{value:"String LessThanOrEqual",id:"string-lessthanorequal",level:5},{value:"String NotEqual",id:"string-notequal",level:5},{value:"String Slice",id:"string-slice",level:5},{value:"<code>Exp1 [ Exp2 .. Exp4]</code>",id:"exp1--exp2--exp4",level:5},{value:"<code>Exp1 [ Exp2 , Exp3 .. Exp4]</code>",id:"exp1--exp2--exp3--exp4",level:5},{value:"String Subscription",id:"string-subscription",level:5},{value:"Tuple",id:"tuple",level:3},{value:"Tuple Concatenation",id:"tuple-concatenation",level:5},{value:"Tuple Equal",id:"tuple-equal",level:5},{value:"Tuple FieldSelection",id:"tuple-fieldselection",level:5},{value:"Tuple GreaterThan",id:"tuple-greaterthan",level:5},{value:"Tuple GreaterThanOrEqual",id:"tuple-greaterthanorequal",level:5},{value:"Tuple LessThan",id:"tuple-lessthan",level:5},{value:"Tuple LessThanOrEqual",id:"tuple-lessthanorequal",level:5},{value:"Tuple NotEqual",id:"tuple-notequal",level:5},{value:"Tuple Subscription",id:"tuple-subscription",level:5},{value:"Value",id:"value",level:3},{value:"Value Conditional",id:"value-conditional",level:5},{value:"Value Equal",id:"value-equal",level:5},{value:"Value GreaterThan",id:"value-greaterthan",level:5},{value:"Value GreaterThanOrEqual",id:"value-greaterthanorequal",level:5},{value:"Value LessThan",id:"value-lessthan",level:5},{value:"Value LessThanOrEqual",id:"value-lessthanorequal",level:5},{value:"Value NotEqual",id:"value-notequal",level:5},{value:"Void",id:"void",level:3},{value:"Operators",id:"operators",level:3},{value:"Field Assignment",id:"field-assignment",level:3},{value:"Field Projection",id:"field-projection",level:3},{value:"Call",id:"call",level:3},{value:"Comprehensions",id:"comprehensions",level:3},{value:"Enumerator",id:"enumerator",level:3},{value:"Filter",id:"filter",level:3},{value:"Concrete Syntax",id:"concrete-syntax",level:3},{value:"Reducer",id:"reducer",level:3},{value:"Statement as Expression",id:"statement-as-expression",level:3},{value:"Visit",id:"visit",level:3},{value:"Pattern With Action",id:"pattern-with-action",level:3},{value:"Statements",id:"statements",level:2},{value:"Append",id:"append",level:3},{value:"Assert",id:"assert",level:3},{value:"Assignment",id:"assignment",level:3},{value:"Annotation",id:"annotation",level:3},{value:"Constructor",id:"constructor-1",level:3},{value:"Field",id:"field",level:3},{value:"IsDefined",id:"isdefined",level:3},{value:"Multiple",id:"multiple",level:3},{value:"Slice",id:"slice",level:3},{value:"Subscription",id:"subscription",level:3},{value:"Variable",id:"variable",level:3},{value:"Block",id:"block",level:3},{value:"Break",id:"break",level:3},{value:"Continue",id:"continue",level:3},{value:"Do",id:"do",level:3},{value:"Fail",id:"fail",level:3},{value:"For",id:"for",level:3},{value:"If",id:"if",level:3},{value:"Insert",id:"insert",level:3},{value:"Return",id:"return",level:3},{value:"Solve",id:"solve",level:3},{value:"Switch",id:"switch",level:3},{value:"Test",id:"test",level:3},{value:"Throw",id:"throw",level:3},{value:"Try Catch",id:"try-catch",level:3},{value:"Visit",id:"visit-1",level:3},{value:"While",id:"while",level:3}],u={toc:k};function d(e){var t=e.components,i=(0,l.Z)(e,p);return(0,r.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Reference manual for the Rascal meta-programming language."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Here we describe ",(0,r.kt)("em",{parentName:"p"},"all")," features of the Rascal language in detail, for reference purposes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#declarations"},"Declarations"),": The entities that can be declared in Rascal programs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns"),": Patterns are a notation for pattern matching used to detect if a value has a certain\nshape,.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#expressions"},"Expressions"),": The expressions available in Rascal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#statements"},"Statements"),": All Rascal statements."))),(0,r.kt)("p",null,"You can find more (accessible) information related to Rascal here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/docs/WhyRascal"},"Why Rascal"),": gives the motivation for the Rascal language and describes various usage scenarios.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/docs/GettingStarted"},"Getting Started")," describes how to download, install and start Rascal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"/docs/GettingHelp"},"Getting Help")," shows how to use the help facilties and search the documentation. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/GettingHelp#FurtherReading"},"Further\nReading")," for a reading guide.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Library functies are described in ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries"},"Rascal Libraries"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We do not maintain a list of frequently asked questions (faq) but use\n",(0,r.kt)("a",{parentName:"p",href:"http://stackoverflow.com/questions/tagged/rascal"},"StackOverflow")," instead."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We show examples for each Rascal language construct described here.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You can find many simple code examples in ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes"},"Recipes"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries"},"Rascal Libraries")," contain examples for most functions."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Rascal has everything you need for any kind of (meta-)program you want to write. See ",(0,r.kt)("a",{parentName:"li",href:"/docs/WhyRascal"},"Why Rascal"),".")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rascal is a procedural/functional language with immutable data. Do not confuse this with object-oriented\nprogramming.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Rascal allows you to write highly imperative code, but it has declarative constructs that lead to shorter and more\nreadable code."))),(0,r.kt)("h2",{id:"declarations"},"Declarations"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The entities that can be declared in Rascal programs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The following concepts are relevant for declarations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#module-declaration"},"Module Declaration"),": Declare a module.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#import"},"Import"),": Declare the import a module.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#program"},"Program"),": A Rascal program consists of a number of ",(0,r.kt)("a",{parentName:"p",href:"#module-declaration"},"Module\nDeclaration"),"s.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#staticTyping"},"StaticTyping"),": The static type system of Rascal."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reifiedtypes"},"Reified Types"),": Reified types are types that can be used as values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#typeconstraints"},"Type Constraints"),": Type constraints restrict the acceptable type for parameters.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#typeparameters"},"Type Parameters"),": Type parameters enable parameterized types.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type"),": Define a user-defined type (Algebraic Data Type).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Declaration"),": Declare a variable.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration"),": Declare a function.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),": Syntax Definitions allow the definition of parsers for\nprogramming languages, domain-specific languages and data formats."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#action"},"Action"),": Actions are functions that are called when parse trees are constructed\n(right after parsing).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#ambiguityDetection"},"Ambiguity Detection"),": Ambiguity detection helps to find ambiguities in\nsyntax definitions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#ambiguityDiagnosis"},"Ambiguity Diagnosis"),": Ambiguity diagnosis suggests changes to syntax\ndefinitions to make them non-ambiguous.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#parseTrees"},"Parse Trees"),": An algebraic data-type for parse trees; produced by all parsers\ngenerated from syntax definitions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),": The symbols that can occur in a syntax definition.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#alias"},"Alias Declaration"),": Declare an alias for a type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#annotation"},"Annotation Declaration"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#tag"},"Tag Declaration"),": Tag declarations are not implemented (yet)."))),(0,r.kt)("h3",{id:"module-declaration"},"Module Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare a module."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"module Name\nImports;\nDeclaration1;\n...\nDeclarationn;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A module declaration consists of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A module name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Zero or more imports;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Zero or more declarations."))),(0,r.kt)("p",null,"The module name ",(0,r.kt)("em",{parentName:"p"},"Name")," will be used when the current module is imported in another module. A module name is in general a\nqualified name of the form:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Name1::_Name2:: ... ::_Namen\n")),(0,r.kt)("p",null,"which corresponds to a path relative to the root of the current workspace."),(0,r.kt)("p",null,"The constituents of a module are shown in the figure below."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Module Parts",src:a(8903).Z,width:"550",height:"697"})),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"#import"},"Import")," declares other modules that are used by the current module. Following imports, a\nmodule may contain declarations (in arbitrary order, but a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition")," can occur\ndirectly following the imports) for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Declaration"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#alias"},"Alias Declaration"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#annotation"},"Annotation Declaration"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#tag"},"Tag Declaration")))),(0,r.kt)("p",null,"Each declaration may contain a ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," keyword that determines the ",(0,r.kt)("em",{parentName:"p"},"visibility")," of the declared entity."),(0,r.kt)("p",null,"The entities that are ",(0,r.kt)("em",{parentName:"p"},"visible inside")," a module are"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The private or public entities declared in the module itself.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The public entities declared in any imported module."))),(0,r.kt)("p",null,"The only entities that are ",(0,r.kt)("em",{parentName:"p"},"visible outside")," the module, are the public entities declared in the module itself. If\ndifferent imported modules declare the same visible name, it can be disambiguated by explicitly qualifying it with its\nmodule name:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Module :: Name\n")),(0,r.kt)("p",null,"Each module resides in a separate file with extension ",(0,r.kt)("inlineCode",{parentName:"p"},".rsc"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is the ",(0,r.kt)("inlineCode",{parentName:"p"},"Hello")," module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::basic::Hello\n\nimport IO;\n\nvoid hello() {\n   println("Hello world, this is my first Rascal program");\n}\n')),(0,r.kt)("p",null,"It defines a module with the name ",(0,r.kt)("inlineCode",{parentName:"p"},"demo::basic::Hello")," and imports the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#io"},"IO")," library. Finally, it\ndeclares the ",(0,r.kt)("inlineCode",{parentName:"p"},"hello")," function."),(0,r.kt)("p",null,"The actual source of this module can be found in ",(0,r.kt)("inlineCode",{parentName:"p"},"library/demo/basic/Hello.rsc")," in the Rascal sources."),(0,r.kt)("p",null,"More ways to write this example are discussed in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#Hello"},"Hello")," example in ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes"},"Recipes"),"."),(0,r.kt)("h3",{id:"import"},"Import"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare the import a module."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"import QualifiedName;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An import has as effect that all public entities declared in module ",(0,r.kt)("em",{parentName:"p"},"QualifiedName")," are made available to the importing\nmodule. Circular imports are allowed. All publicly visible entities in the imported module become available in the\nimporting module."),(0,r.kt)("p",null,"Import is ",(0,r.kt)("em",{parentName:"p"},"non-transitive"),", i.e., the visible entities from an imported module are not re-exported by the importing\nmodule."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here, is how to import the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#io"},"IO")," library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nprintln("IO library was imported.");\n')),(0,r.kt)("h3",{id:"program"},"Program"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A Rascal program consists of a number of ",(0,r.kt)("a",{parentName:"p",href:"#module-declaration"},"Module Declaration"),"s."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A Rascal program consists of a number of ",(0,r.kt)("a",{parentName:"p",href:"#module-declaration"},"Module Declaration"),"s, each stored in a separate file\nwith extension ",(0,r.kt)("inlineCode",{parentName:"p"},".rsc"),"."),(0,r.kt)("h3",{id:"statictyping"},"StaticTyping"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The static type system of Rascal."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Rascal is based on static typing, this means that as many errors and inconsistencies as possible are spotted before the\nprogram is executed."),(0,r.kt)("h3",{id:"the-type-lattice"},"The Type Lattice"),(0,r.kt)("p",null,"The types are ordered in a so-called ",(0,r.kt)("em",{parentName:"p"},"type lattice")," shown in the following figure."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Type Lattice",src:a(4867).Z,width:"847",height:"951"})),(0,r.kt)("p",null,"The arrows describe a ",(0,r.kt)("em",{parentName:"p"},"subtype-of")," relation between types. The type ",(0,r.kt)("inlineCode",{parentName:"p"},"void")," is the ",(0,r.kt)("em",{parentName:"p"},"smallest")," type and is included in all\nother types and the type ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," is the ",(0,r.kt)("em",{parentName:"p"},"largest")," type that includes all other types. We also see that ",(0,r.kt)("inlineCode",{parentName:"p"},"rel")," is a\nsubtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," and that each ADT is a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"node"),". A special role is played by the datatype ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," that is the\ngeneric type of syntax trees. Syntax trees for specific languages are all subtypes of ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),". As a result, syntax trees\ncan be addressed at two levels:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in a generic fashion as ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," and,")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in a specific fashion as a more precisely typed syntax tree. Finally, each ",(0,r.kt)("inlineCode",{parentName:"p"},"alias")," is structurally equivalent to one\nor more specific other types."))),(0,r.kt)("p",null,"The fact that the types are ordered in a lattice makes it possible to define a ",(0,r.kt)("strong",{parentName:"p"},"Least Upper Bound")," (lub) on types.\nGiven two types ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"lub(T1, T2)")," is defined as the nearest common super type of\n",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2")," in the type lattice."),(0,r.kt)("h3",{id:"advanced-features"},"Advanced Features"),(0,r.kt)("p",null,"The Rascal type system has various advanced features that are described separately:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Types may be be ",(0,r.kt)("em",{parentName:"p"},"parameterized")," resulting in very general and reusable types, see ","[","Type Parameters","]",".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Declarations of ","[","Function","]","s and ","[","AlgebraicDataType","]","s may be parameterized and ","[","Type Constraints","]"," can be used\nto define constraints on the actual type to be used.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The formal arguments of functions are bound to ",(0,r.kt)("em",{parentName:"p"},"values")," but in exceptional cases a function may need a type as\nargument value, ",(0,r.kt)("a",{parentName:"p",href:"#reifiedtypes"},"Reified Types")," make this possible."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here are some simple examples of correct and incorrect typing:"),(0,r.kt)("p",null,"We can assign an integer value to an integer variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int i = 3;\n")),(0,r.kt)("p",null,"But assigning a string value gives an error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'int j = "abc";\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"num")," type accepts integer and real values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"num n = i;\nn = 3.14;\n")),(0,r.kt)("p",null,"A variable of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," accepts all possible values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value v = true;\nv = "abc";\nv = [1, 2, 3];\n')),(0,r.kt)("h3",{id:"reified-types"},"Reified Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Reified types are types that can be used as values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"# Name")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"type")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Usually one declares functions that have arguments that have a type that corresponds to one of the many forms of values\nin Rascal. In exceptional circumstances it is desirable to define functions that have a type itself as argument."),(0,r.kt)("p",null,"To solve this problem in a more general manner something special has to be done. Types are not values and without an\nadditional mechanism they cannot be passed as arguments to functions. To achieve this effect we introduce reified types\nthat are denoted by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),". In other words, reified types make it possible to use types as values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"The prototypical example is a parse function: how to write a type safe parse function that expresses the type of the\nresult we expect? Suppose we want to parse a language that has the non-terminals ",(0,r.kt)("inlineCode",{parentName:"p"},"EXP"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"STAT")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"PROGRAM"),". A first,\nnaive, solution introduces a parse function for each non-terminal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"EXP parseEXP(str s){ ... }\nSTAT parsePROGRAM(str s) { ... }\nPROGRAM parsePROGRAM(str s) { ... }\n")),(0,r.kt)("p",null,"Unfortunately this solution does not scale well to large languages with many non-terminals and it breaks down completely\nwhen we do not know the non-terminals before hand."),(0,r.kt)("p",null,"Now we can write (see ",(0,r.kt)("a",{parentName:"p",href:"#typeparameters"},"Type Parameters")," for a description of the ",(0,r.kt)("inlineCode",{parentName:"p"},"&T")," notation):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"&T parse(type[&T] start, str s) { ... }\n")),(0,r.kt)("p",null,"and use the parse by giving it a type as argument:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'parse(#eXP, "1+3");\n')),(0,r.kt)("h3",{id:"type-constraints"},"Type Constraints"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Type constraints restrict the acceptable type for parameters."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"& Name <: Type")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Constraints can be imposed on the actual types to which a type parameter may be bound. This is expressed by a subtype\nconstraint which expresses that actual types bound to ",(0,r.kt)("em",{parentName:"p"},"Name")," should be a subtype of ",(0,r.kt)("em",{parentName:"p"},"Type"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is the definition of the absolute value function ",(0,r.kt)("inlineCode",{parentName:"p"},"abs")," from the ",(0,r.kt)("a",{parentName:"p",href:"#number"},"Number")," library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"public &T <: num abs(&T <: num N)\n{\n    return N >= 0 ? N : -N;\n}\n")),(0,r.kt)("p",null,"The argument ",(0,r.kt)("inlineCode",{parentName:"p"},"N")," is constrained to be at most of type ",(0,r.kt)("inlineCode",{parentName:"p"},"num"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import util::Math;\nabs(-3);\nabs(-3.5);\n")),(0,r.kt)("p",null,"Here is an example from the ",(0,r.kt)("a",{parentName:"p",href:"#node"},"Node")," library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"&T <: node setAnnotations(&T <: node x, map[str, value] annotations);\n")),(0,r.kt)("p",null,"(we don\u2019t give the body of this function since it has been implemented in Java). ",(0,r.kt)("inlineCode",{parentName:"p"},"setAnnotations")," takes a value of any\ntype that is at most ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," and adds annotations to it. This makes it possible to set annotations on any ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data\nType"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import Node;\nnd = "f"(10, "abc");\n')),(0,r.kt)("p",null,"First we apply ",(0,r.kt)("inlineCode",{parentName:"p"},"setAnnotations")," to a node value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'setAnnotations(nd, ("color" : "red", "size" : "large"));\n')),(0,r.kt)("p",null,"Next, we introduce a new data type ",(0,r.kt)("inlineCode",{parentName:"p"},"Suite"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"data Suite = hearts() | diamonds() | clubs() | spades();\nst = diamonds();\n")),(0,r.kt)("p",null,"And apply ",(0,r.kt)("inlineCode",{parentName:"p"},"setAnnotations")," to a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Suite"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'setAnnotations(st, ("player" : "Hossein", "gain" : "120"));\n')),(0,r.kt)("h3",{id:"type-parameters"},"Type Parameters"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Type parameters enable parameterized types."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"& Name")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A type parameter may occur at every syntactic position where a type is required and turns an ordinary type into a\nparameterized type. Parameterized types are used to define polymorphic functions and data types, i.e., functions and\ndata types that are applicable for more than one type. Type parameters are bound to an actual type when the function or\ndata type is applied and further uses of the type parameter are consistently replaced by the actual type."),(0,r.kt)("p",null,"The following syntactic positions are ",(0,r.kt)("em",{parentName:"p"},"binding occurrences")," for type parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Type parameters in the type declaration of a function are bound to the types of the actual parameters in the call of\nthat function. Type parameters that occur in the body of the function are replaced by the corresponding actual\ntypes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The left-hand side of an alias. The type parameters are bound when the alias is used and occurrences of type\nparameters in the right hand side are replaced by corresponding actual types.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The alternatives of a data type. Binding and replacement is identical to that of function declarations."))),(0,r.kt)("p",null,"All other occurrences of type parameters are ",(0,r.kt)("em",{parentName:"p"},"using occurrences"),". The following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When the same type parameter is used at different binding occurrences it should be bound to the same actual type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For every using occurrence of a type parameter there should be a binding occurrence of a type parameter with the\nsame name."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Let's consider a small example of the use of function parameters in a function declaration, see ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function\nDeclaration")," for more details on function declarations. The following function ",(0,r.kt)("inlineCode",{parentName:"p"},"swap")," returns a\ntuple in which its arguments are swapped and can be applied to arbitrary values in a type safe manner:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'tuple[&B, &A] swap(&A a, &B b) { return <b, a>; }\nswap(1,2);\nswap("abc", 3);\n')),(0,r.kt)("p",null,"Observe that the type parameters that are used in the return type should be defined in the declarations of the formal\nparameter of the function."),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"#alias"},"Alias")," declaration may also be parameterized. So we can generalize graphs as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'alias Graph[&Node] = rel[&Node, &Node];\nGraph[int] GI = {<1,2>, <3,4>, <4,1>};\nGraph[str] GS = {<"a", "b">, <"c","d">, <"d", "a">};\n')),(0,r.kt)("p",null,"The type parameters that are used in the type in the right part of the alias declaration should be defined in the left\npart of the alias definition."),(0,r.kt)("h3",{id:"ADT"},"Algebraic Data Type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Define a user-defined type (Algebraic Data Type)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"In ordinary programming languages record types or classes exist to introduce a new type name for a collection of\nrelated, named, values and to provide access to the elements of such a collection through their name."),(0,r.kt)("p",null,"In Rascal, algebraic data types provide this facility. They have to be declared, and then values can be declared using\ncalls to the declared constructor functions, see ",(0,r.kt)("a",{parentName:"p",href:"#constructor"},"Constructor"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"The following data declaration defines the datatype ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool")," that contains various constants (",(0,r.kt)("inlineCode",{parentName:"p"},"tt()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ff()")," and\nconstructor functions ",(0,r.kt)("inlineCode",{parentName:"p"},"conj")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"disj"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"data Bool = tt() | ff() | conj(Bool L, Bool R)  | disj(Bool L, Bool R);\n")),(0,r.kt)("p",null,"terms of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool")," can be constructed using the defined constructors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"conj(tt(),ff());\n")),(0,r.kt)("h3",{id:"variable-declaration"},"Variable Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare a variable."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Type Name = Exp ;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Type Name;")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Type")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Type")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<: Type"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The effect of a variable declaration is to introduce a new variable ",(0,r.kt)("em",{parentName:"p"},"Name")," and to assign the value of expression ",(0,r.kt)("em",{parentName:"p"},"Exp"),"\nto ",(0,r.kt)("em",{parentName:"p"},"Name"),". A mention of ",(0,r.kt)("em",{parentName:"p"},"Name")," later on in the same scope will be replaced by this value, provided that ",(0,r.kt)("em",{parentName:"p"},"Name"),"\\","'s value\nhas not been changed by an intermediate assignment."),(0,r.kt)("p",null,"When a variable is declared, it has as scope the nearest enclosing block, or the module when declared at the module\nlevel."),(0,r.kt)("p",null,"The following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Double declarations in the same scope are not allowed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The type of ",(0,r.kt)("em",{parentName:"p"},"Exp")," should be compatible with ",(0,r.kt)("em",{parentName:"p"},"Type"),", i.e., it should be a subtype of ",(0,r.kt)("em",{parentName:"p"},"Type"),"."))),(0,r.kt)("p",null,"As a convenience, also declarations without an initialization expression are permitted inside functions (but not at the\nmodule level) and have the form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Type Name;\n")),(0,r.kt)("p",null,"and only introduce the variable ",(0,r.kt)("em",{parentName:"p"},"Name"),"."),(0,r.kt)("p",null,"Rascal provides local type inference, which allows the implicit declaration of variables that are used locally in\nfunctions. The following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An implicitly declared variable is declared at the level of the current scope, this may the whole function body or a\nblock nested in it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An implicitly declared variable gets as type the type of the first value that is assignment to it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a variable is implicitly declared in different execution path of a function, all these implicit declarations\nshould result in the same type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All uses of an implicitly declared variable must be compatible with its implicit type."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Two explicit variable declarations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int max = 100;\nmin = 0;\n")),(0,r.kt)("p",null,"An implicit variable declaration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'day = {<"mon", 1>, <"tue", 2>, <"wed",3>,\n       <"thu", 4>, <"fri", 5>, <"sat",6>, <"sun",7>};\n')),(0,r.kt)("p",null,"Variable declaration and assignment leading to type error"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'int month = 12;\nmonth ="December";\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Local type inference for variables always uses the smallest possible scope for a variable; this implies that a\nvariable introduced in an inner scope is not available outside that scope. Here is how things can go wrong:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if( 4 > 3){ x = "abc"; } else { x = "def";}\nx;\n')),(0,r.kt)("h3",{id:"function-declaration"},"Function Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare a function."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Modifiers Type Name( Type1 Var1, \u2026\u200b, Typen Varn ) Body"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Modifiers Type Name( Type1 Var1, \u2026\u200b, Typen Varn Type0 Name0\u2026\u200b ) Body"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Modifiers Type Name( Pattern1, \u2026\u200b, Patternn) Body"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Modifiers Type Name( Pattern1, \u2026\u200b, Patternn, Type0 Name0\u2026\u200b) Body")))),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"Body")," is one of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"{ Statements }"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"throws Exception1, Exception2, \u2026\u200b { Statements }"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"= Expression;")))),(0,r.kt)("p",null,"and where ",(0,r.kt)("inlineCode",{parentName:"p"},"Modifiers")," may be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'("public" | "private")? ("java" | "test" | "default")?'))),(0,r.kt)("h3",{id:"variant-1"},"Variant 1"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A function declaration introduces a new function with name ",(0,r.kt)("em",{parentName:"p"},"name"),", typed formal parameters ",(0,r.kt)("inlineCode",{parentName:"p"},"Type1 Var1"),", a return type\n",(0,r.kt)("em",{parentName:"p"},"Type")," and a ",(0,r.kt)("em",{parentName:"p"},"Statement")," that forms the function body. The type of ",(0,r.kt)("em",{parentName:"p"},"Statement")," should be equal to ",(0,r.kt)("em",{parentName:"p"},"Type"),"."),(0,r.kt)("p",null,"The formal parameters may be used in ",(0,r.kt)("em",{parentName:"p"},"Statement")," and get their value when function ",(0,r.kt)("em",{parentName:"p"},"Name")," is invoked."),(0,r.kt)("h3",{id:"variant-2"},"Variant 2"),(0,r.kt)("p",null,"A function may have a variable list of arguments, this has as syntax variant 2 given above."),(0,r.kt)("p",null,"The last parameter of a function may be followed by ",(0,r.kt)("inlineCode",{parentName:"p"},"\u2026\u200b")," and this has as effect that all remaining actual parameters\nthat occur in a call to this function are collected as list value of the last formal parameter. Inside the function\nbody, the type of this parameter will therefore be ",(0,r.kt)("inlineCode",{parentName:"p"},"list[Type0]"),"."),(0,r.kt)("h3",{id:"variant-3-and-4"},"Variant 3 and 4"),(0,r.kt)("p",null,"All formal parameter of a function can be ",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns"),". There are some restrictions however:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A Pattern in formal parameter positions may not refer to variables in the scope.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Patterns in formal parameter positions may not introduce fresh variables without an explicit type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The last parameter, if followed by ",(0,r.kt)("inlineCode",{parentName:"p"},"\u2026\u200b")," can only be a normal typed parameters, not just any pattern."))),(0,r.kt)("h3",{id:"body-types"},"Body types"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Functions with list of statements as bodies must eventually use ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," on every control flow path.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The declarations to ",(0,r.kt)("inlineCode",{parentName:"p"},"throw")," an exception are documentation only")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Single expressions can be bodies of functions, the return value is the value of the expression."))),(0,r.kt)("h3",{id:"parameterized-types-in-function-declaration"},"Parameterized types in function declaration"),(0,r.kt)("p",null,"The types that occur in function declarations may also contain ",(0,r.kt)("a",{parentName:"p",href:"#typeparameters"},"Type Parameters"),". In this\nway functions can be defined for arbitrary types. The type variable is bound (statically) at by the types of the\nparameters given at location of the call. The result type must be used at least once in any of the parameters."),(0,r.kt)("h3",{id:"overloading"},"Overloading"),(0,r.kt)("p",null,"Function definitions may be overloaded, i.e. a function with the same name may be defined twice and a function may\nredefine a constructor of an ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type")," or a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),"."),(0,r.kt)("p",null,"There are some restrictions however:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Overloaded alternatives for the same function name but with different patterns must return the same type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Overloaded alternatives for the same function name must have mutually exclusive patterns, unless one alternative is\nlabeled ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," and the other is not. The patterns of formal parameters are mutually exclusive if for at least one\nparameter position:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"They range over incomparable types, as in ",(0,r.kt)("inlineCode",{parentName:"p"},"int f(int a)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"int f(real a)"),", or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"They range over different alternatives of an ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type"),", as in ",(0,r.kt)("inlineCode",{parentName:"p"},"int\nf(and(Bool a, Bool b))")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"int f(or(Bool a, Bool b))"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"They range over different alternatives of a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"And note that deep matches using the ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," alternative are considered to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," and therefore overlap\nwith all other patterns.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Overlapping patterns are allowed if the one alternative has the ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," modified while the other does not.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a function is fallible, it uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," statement to back-track to a different alternative, then there must be\na ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," alternative defined which can handle the general case. An ","[","AlgebraicDataType","]"," or a\n","[","syntax-definition","]"," with the same name and return type counts as a ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," alternative.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"default")," functions may not fail."))),(0,r.kt)("h3",{id:"modifiers"},"Modifiers"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Modifiers")," affect ",(0,r.kt)("em",{parentName:"p"},"visibility")," and ",(0,r.kt)("em",{parentName:"p"},"special behaviour")," of functions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Visibility"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," declares that a function is only visible in the current module. ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," declares that it is\nvisible outside the module as well. When visibility is not specified, ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," is assumed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Special Behaviour"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"java")," declares that the body of the function is implemented in Java. The function should have a ",(0,r.kt)("inlineCode",{parentName:"p"},"javaClass"),"\nannotation that determines where the Java implementation can be found.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"test")," declares that this is a test function. A test function is a boolean function (currently) without\narguments. It can be called as any other function. However, it can also be called automatically by the unit test\nframework, by typing ",(0,r.kt)("inlineCode",{parentName:"p"},":test")," at the command line, see ",(0,r.kt)("a",{parentName:"p",href:"#help"},"Help"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"default")," declares an alternative for an overloaded function that will only be tried after all non-default\nalternatives have been tried. Note that ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type"),"s and ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),"s ",(0,r.kt)("em",{parentName:"p"},"implicitly")," define ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," functions that may be overloaded by\nnormal ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration"),"s."))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Declare a function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rel[int, int] invert(rel[int,int] R){\n   return {<Y, X> | <int X, int Y> <- R };\n}\n")),(0,r.kt)("p",null,"Call it"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"invert({<1,10>, <2,20>});\n")),(0,r.kt)("p",null,"In the following example we illustrate the use of type variables in function declarations. Declare an inversion function\nthat is applicable to any binary relation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rel[&T2, &T1] invert2(rel[&T1,&T2] R){\n   return {<Y, X> | <&T1 X, &T2 Y> <- R };\n}\n")),(0,r.kt)("p",null,"Now apply it to relations with different types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'invert2({<1,10>, <2,20>});\ninvert2({<"mon", 1>, <"tue", 2>});\n')),(0,r.kt)("p",null,"As another example declare a function that can be used to swap the elements of pairs of arbitrary types (also see ",(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Tuple\nSubscription"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'tuple[&T2, &T1] swap(tuple[&T1, &T2] TP) { return <TP[1], TP[0]>;}\nswap(<1, 2>);\nswap(<"wed", 3>);\n')),(0,r.kt)("p",null,"Here we use an overloaded definition with incomparable patterns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int f(int i) = 1;\nint f(real r) = 2;\nf(0);\nf(0.0);\n")),(0,r.kt)("p",null,"And we may use ",(0,r.kt)("inlineCode",{parentName:"p"},"default"),", as in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int f(0) = 1;\ndefault int f(int n) = n * f(n - 1);\nf(0);\nf(2);\n")),(0,r.kt)("p",null,"In combination with an ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type"),", which defines ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," functions\nimplicitly for every alternative, we can define canonicalization functions. The same holds for ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),"s, see ",(0,r.kt)("a",{parentName:"p",href:"#action"},"Action"),"s."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"In case of overlapping function definitions, the order in which the functions are tried is left undefined. The only\nexceptions are functions marked ",(0,r.kt)("inlineCode",{parentName:"p"},"default"),", those will be tried after non-",(0,r.kt)("inlineCode",{parentName:"p"},"default")," functions."),(0,r.kt)("h3",{id:"syntax-definition"},"Syntax Definition"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Syntax Definitions allow the definition of parsers for programming languages, domain-specific languages and data\nformats."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Start syntax Nonterminal = Alternatives;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"lexical Nonterminal = Alternatives;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"layout Nonterminal = Alternatives;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"keyword Nonterminal = Alternatives;")))),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"Start")," is either ",(0,r.kt)("inlineCode",{parentName:"p"},"start")," or nothing, and ",(0,r.kt)("em",{parentName:"p"},"Alternatives")," are one of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Tags Associativity Symbols"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Tags Associativity Name : Symbols"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Associativity ( Alternatives )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Alternatives1 | Alternatives2"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Alternatives1 > Alternatives2")))),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"Associativity")," is nothing, or one of ",(0,r.kt)("inlineCode",{parentName:"p"},"assoc"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"left"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"right")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"non-assoc"),", and ",(0,r.kt)("em",{parentName:"p"},"Tags")," are a possibly empty\nlist of tags."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Rascal supports full context-free grammars for syntax definition. It generates scannerless parsers from these\ndefinitions. These parsers produce ",(0,r.kt)("a",{parentName:"p",href:"#parseTrees"},"Parse Trees")," that can be further processed by Rascal\nusing ",(0,r.kt)("a",{parentName:"p",href:"#concretesyntax"},"Concrete Syntax")," fragments in ",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns")," and\n",(0,r.kt)("a",{parentName:"p",href:"#expressions"},"Expressions"),", or they can be ",(0,r.kt)("em",{parentName:"p"},"imploded")," to ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data\nType"),"s."),(0,r.kt)("p",null,"There are four kinds of non-terminals that can be defined with slightly different characteristics."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Syntax")," non-terminals are general context-free non-terminals. This mean left-recursion, right-recursion, any of the\nregular expression ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s and all kinds of\n",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation")," can be used to define it. It is important to note that in between\nthe ",(0,r.kt)("em",{parentName:"p"},"Symbols")," that define a syntax non-terminal the locally defined layout non-terminal will be interleaved. For\nexample, if you define ",(0,r.kt)("inlineCode",{parentName:"p"},"layout ML = [\\ ]*;")," and ",(0,r.kt)("inlineCode",{parentName:"p"},'syntax A = "a" "a"'),", Rascal will ",(0,r.kt)("em",{parentName:"p"},"modify")," the definition of A to\n",(0,r.kt)("inlineCode",{parentName:"p"},'syntax A = "a" ML "a";')," before generating a parser.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Lexical")," non-terminals are just like ",(0,r.kt)("em",{parentName:"p"},"syntax")," non-terminals, very much like ",(0,r.kt)("em",{parentName:"p"},"syntax")," non-terminals. However, the\ndefinition of a lexical is ",(0,r.kt)("em",{parentName:"p"},"not")," modified with interleaved layout non-terminals. And, the structure of lexicals is\nnot traversed by the ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," statement and equality is checked between lexicals by checking the\ncharacters (not its structure) for equality.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Layout")," non-terminals are just like ",(0,r.kt)("em",{parentName:"p"},"syntax")," non-terminals as well. However, they are used to preprocess all\n",(0,r.kt)("em",{parentName:"p"},"syntax")," definitions in the same module scope (see above).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Keyword")," non-terminals are ",(0,r.kt)("em",{parentName:"p"},"not")," like ",(0,r.kt)("em",{parentName:"p"},"syntax")," non-terminals. These only allow definition of enumeration of literal\nsymbols and single character classes. Keyword non-terminals play an important role in the semantics of\n",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation")," where some disambiguation constructs require finite, non-empty\nenumeration of strings. The prime example is the definition of reserved keywords."))),(0,r.kt)("p",null,"Each alternative of a syntax definition is defined by a list of ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s. Each of the\n",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s can be labeled or not. The alternative of a defined syntax type may be labeled or\nnot as well. With the label additional operations are activated on the corresponding parse trees:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"is")," operator is defined for labeled alternatives (see ",(0,r.kt)("a",{parentName:"p",href:"#operators"},"Operators"),").")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"has")," operator is defined for labeled ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s in the right-hand side (see\n",(0,r.kt)("a",{parentName:"p",href:"#operators"},"Operators"),").")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#action"},"Action")," functions can be written to override the construction of a parse tree, using the\nlabel of an alternative as the function name")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"[","implode","]"," uses labeled alternatives to map to an ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type")))),(0,r.kt)("p",null,"Alternatives can be combined in a single ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"|"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">")," and\nassociativity combinators. The latter two represent ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation")," constructs that\nyou should read more about. The ",(0,r.kt)("inlineCode",{parentName:"p"},"|")," is a short-hand for not having to repeat ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax A =")," for every alternative of ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),"."),(0,r.kt)("p",null,"Alternatives can be named or not. The names are essential only if:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"you need to ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#implode"},"implode")," ",(0,r.kt)("a",{parentName:"p",href:"#parseTrees"},"Parse Trees"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"you need to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"is")," expression, as in ",(0,r.kt)("inlineCode",{parentName:"p"},"myStatement is ifThenElse")," instead of using concrete pattern matching.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"you want to write ",(0,r.kt)("a",{parentName:"p",href:"#action"},"Action"),"s that triggers on the construction of the alternative."))),(0,r.kt)("p",null,'However, it is generally a good idea to name your rules even if you do not need them. Note that a name may be reused for\ndifferent alternatives for a single non-terminal, provided that the lists of symbols for these "overloaded" alternatives\nuse ',(0,r.kt)("em",{parentName:"p"},"different non-terminal symbols"),". This implies that alternatives for lexicals generally do not use overloaded names\nbecause they are often defined only by regular expressions over terminal ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s (literals\nand character classes)."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"start")," modifier identifies the start of a grammar. The effect of a start modifier is that Rascal will generate an\nextra syntax definition before generating a parser that allows layout to before and after the start non-terminal. For\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"layout L = [\\ ]*; start Program = Statement*;`\n")),(0,r.kt)("p",null,"will produce ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax start[Program] = L Program top L;"),". Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"start[Program]")," type is now available in your\nprogram, and ",(0,r.kt)("a",{parentName:"p",href:"#parseTrees"},"Parse Trees")," assigned to variable of that type will allow access to the\n",(0,r.kt)("em",{parentName:"p"},"top")," field."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"The following example makes use of practically all of the ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition")," features,\nexcept parse actions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'// layout is lists of whitespace characters\nlayout MyLayout = [\\t\\n\\ \\r\\f]*;\n\n// identifiers are characters of lowercase alphabet letters,\n// not immediately preceded or followed by those (longest match)\n// and not any of the reserved keywords\nlexical Identifier = [a-z] !<< [a-z]+ !>> [a-z] \\ MyKeywords;\n\n// this defines the reserved keywords used in the definition of Identifier\nkeyword MyKeywords = "if" | "then" | "else" | "fi";\n\n// here is a recursive definition of expressions\n// using priority and associativity groups.\nsyntax Expression\n  = id: Identifier id\n  | null: "null"\n  | left multi: Expression l "*" Expression r\n  > left ( add: Expression l "+" Expression r\n         | sub: Expression l "-" Expression r\n         )\n  | bracket "(" Expression ")"\n  ;\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Modular and compositional.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"No grammar normalization or grammar factoring necessary.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Generate a parser for any context-free grammar.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Generate parsers are really fast (for general parsers).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Powerful disambiguation constructs for common programming language disambiguation patterns.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Data-dependent (context-sensitive) disambiguation via arbitrary functions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Embedding of concrete syntax fragments in Rascal programs")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"s follow the syntax and semantics of ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data\nType"),"s quite closely."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Grammars may be ambiguous, so read about ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),", ",(0,r.kt)("a",{parentName:"p",href:"#ambiguityDetection"},"Ambiguity\nDetection")," and ",(0,r.kt)("a",{parentName:"p",href:"#ambiguityDiagnosis"},"Ambiguity Diagnosis"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Static grammar checker is not implemented yet."))),(0,r.kt)("h3",{id:"action"},"Action"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Actions are functions that are called when parse trees are constructed (right after parsing)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A so-called ",(0,r.kt)("a",{parentName:"p",href:"#action"},"Action")," is a normal rascal ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration")," that\noverloads a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),". A ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),",\nvery similar to ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type")," definitions, defines a constructor for a parse\ntree node. This constructor is the default function, and when it is overloaded by a non-default function this overloaded\nfunction will be tried first. You can overload any labeled ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition")," using the\nname of an alternative."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"syntax A = a: B  C;\n\npublic A a(B b, C c) {\n  return f(b, c);\n}\n")),(0,r.kt)("p",null,"In this example ",(0,r.kt)("a",{parentName:"p",href:"#action"},"Action")," function the a is replaced by whatever A the ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," function returns."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#action"},"Action"),"s are executed every time a parse tree is constructed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Right after parsing.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"On the way back from a visit statement.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When a ",(0,r.kt)("a",{parentName:"p",href:"#concretesyntax"},"Concrete Syntax")," expression is executed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When ",(0,r.kt)("a",{parentName:"p",href:"#parseTrees"},"Parse Trees"),' are constructed "manually".'))),(0,r.kt)("p",null,"They can be used as a ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation")," method, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," statement, as in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax E = id: Id i;\nset[Id] types = {};\n\npublic E id(Id i) {\n  if (i in types)\n    filter; // remove this parse tree and all its parents up to the first amb node\n  else\n    fail; // just build the parse tree "E = id: Id i", by defaulting to the constructor\n}\n')),(0,r.kt)("h3",{id:"ambiguity-detection"},"Ambiguity Detection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Ambiguity detection helps to find ambiguities in syntax definitions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"AmbiDexter is a tool that analyzes ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"s, including their\n",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),"s, to try and determine which ambiguities it contains. Static\ndetection of ambiguity is not decidable, nevertheless AmbiDexter does a fine job at finding them."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"AmbiDexter can find ambiguity for you before testing the parser, after which you can use ","[","AmbiguityDiagnosis","]"," to\nexplain it.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"AmbiDexter is now a separate command-line tool which still needs integration")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"AmbiDexter is not a silver bullet. It has a time-limit to stop after having searcher only so much of a language.\nAfter the time limit has expired, your ","[","syntax-definition","]"," may still be ambiguous."))),(0,r.kt)("h3",{id:"ambiguity-diagnosis"},"Ambiguity Diagnosis"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Ambiguity diagnosis suggests changes to syntax definitions to make them non-ambiguous."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Ambiguity")," library, a.k.a. DrAmbiguity, contains a diagnosis tool that can help you find the causes of ambiguous\nparse trees and possible ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),"s to solve them in a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),". DrAmbiguity is a library that processes any parse forest produced by a\nparser generated from Rascal\u2019s ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"s. Please read\n",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation")," first."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"import analysis::grammars::Ambiguity;\ndiagnose(t); // for any t of which you know it contains an ambiguity\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"DrAmbiguity automatically proposes ",(0,r.kt)("a",{parentName:"li",href:"#disambiguation"},"Disambiguation"),"s that will work")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DrAmbiguity does not scale to large parse trees, so please first make your example smaller.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DrAmbiguity proposes several ","[","Disambiguation","]","s for each ambiguity, only few of which make sense from a language\ndesign point of view","!")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DrAmbiguity is now only a library function, while it should be integrated into the Rascal IDE"))),(0,r.kt)("h3",{id:"disambiguation"},"Disambiguation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Disambiguation is the definition of filters on the parse trees that ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"s\ndefine. There are several ways of defining ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation")," in Rascal."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"There are generally three ways of removing ambiguity from parse forests that are produced by parsers generated from\n",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"s."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The first way is to add disambiguation declarations to the ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),". You\ncan choose from:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#priority"},"Priority Declaration"),"s, which can be used to define the relative priority in\nexpression languages")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#associativity"},"Associativity Declaration"),"s, which can be used to define relative associativity\nbetween operators of expression languages")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#follow"},"Follow Declaration"),"s, which can be used to implement longest match using lookahead")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#precede"},"Precede Declaration"),"s, which can be used to implement first match using look behind")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reserve-Declaration%3Es"},"which allow you to finite sets of strings from a \\<\\<Syntax Definition")," to implement\nkeyword reservation")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The second way is to add ",(0,r.kt)("a",{parentName:"p",href:"#action"},"Action"),"s that will be triggered just after parsing and allow you\nto trim a parse forest using any information necessary.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The third way is use the ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," statement on a parse tree and implement your own filter\npost-parsing time, or any other kind of program that processes ",(0,r.kt)("a",{parentName:"p",href:"#parseTrees"},"Parse Trees"),"."))),(0,r.kt)("h5",{id:"associativity-declaration"},"Associativity Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Define associativity of operators"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"syntax Exp = Assoc Label Symbol1 Symbol2 \u2026\u200b"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"syntax Exp = Assoc ( Alt1 | Alt2 | \u2026\u200b )"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"syntax Exp = Assoc Symbol1 Symbol2 \u2026\u200b")))),(0,r.kt)("p",null,"Here ",(0,r.kt)("em",{parentName:"p"},"Assoc")," is one of: ",(0,r.kt)("inlineCode",{parentName:"p"},"left"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"right"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"assoc")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"non-assoc"),". See ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),"s on how to define alternatives and ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Using Associativity declarations we may disambiguate binary recursive operators."),(0,r.kt)("p",null,"The semantics are that an associativity modifier will instruct the parser to disallow certain productions to nest ",(0,r.kt)("em",{parentName:"p"},"at\nparticular argument positions"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"assoc")," will disallow productions to directly nest in their ",(0,r.kt)("em",{parentName:"p"},"right-most")," position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"right")," will disallow productions to directly nest in their ",(0,r.kt)("em",{parentName:"p"},"left-most")," position.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"non-assoc")," will disallow productions to directly nest in either their left-most or their right-most position."))),(0,r.kt)("p",null,"When associativity is declared for a group of productions, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"left ( Alt1 | Alt 2 | Alt3)"),", then each alternative\nwill be mutually associative to each other alternative ",(0,r.kt)("em",{parentName:"p"},"and itself"),". If an alternative of a group defines its own local\nassociativity, as in ",(0,r.kt)("inlineCode",{parentName:"p"},"left ( right Alt1 | Alt2 | Alt3)"),", then ",(0,r.kt)("em",{parentName:"p"},"Alt"),(0,r.kt)("sub",null,"1")," is right associative with respect to\nitself and left associative with respect to all others in the group."),(0,r.kt)("p",null,"A finer point is that associativity has no effect on any other position than the left-most and right-most position (see\nalso ",(0,r.kt)("a",{parentName:"p",href:"#priority"},"Priority Declaration"),"). This is to guarantee that associativity does not introduce parse\nerrors. The following tables explain when an assocativity declaration filters given two productions ",(0,r.kt)("inlineCode",{parentName:"p"},"father")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"child"),"\nthat share an associativity group."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"If ","`","left (Parent"),(0,r.kt)("th",{parentName:"tr",align:null},"Child)","`"),(0,r.kt)("th",{parentName:"tr",align:null},"Parent None: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = "[" E "]"')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Left-most: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = E "*"')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Right-most: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = "*" E')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Both: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = E "*" E')))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child None:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = "{" E "}"')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Left-most:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under right"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under right"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Right-most:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = "+" E')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Both:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+" E')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"If ","`","right (Parent"),(0,r.kt)("th",{parentName:"tr",align:null},"Child)","`"),(0,r.kt)("th",{parentName:"tr",align:null},"Parent None: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = "[" E "]"')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Left-most: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = E "*"')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Right-most: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = "*" E')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Both: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = E "*" E')))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child None:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = "{" E "}"')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Left-most:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Right-most:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = "+" E')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Both:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+" E')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Short notation for common constructs in programming languages.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Removes ambiguity but can not introduce parse errors.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Allows the use of less non-terminals for the same expression grammar (typically only one), which makes parse trees\nsimpler as well as the mapping to an abstract syntax tree more direct."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Please do not assume that Rascal\u2019s associativity declarations have the same semantics as SDF\u2019s associativity\ndeclarations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use of productions that are not both left and right recursive in an associativity group, although safe, is not very\nmeaningful. We would advise to use the ",(0,r.kt)("a",{parentName:"p",href:"#priority"},"Priority Declaration")," relation such a case. For\nexample:"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Original associativity"),(0,r.kt)("th",{parentName:"tr",align:null},"Better written as priority"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"`",'E = left ( "+" E'),(0,r.kt)("td",{parentName:"tr",align:null},'E "+" E );',"`")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+" E > "+" E;')),(0,r.kt)("td",{parentName:"tr",align:null},"`",'E = right ( "+" E')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'E "+" E );',"`"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'E = "+" E > E "+" E;'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"`",'E = left ( E "+"'),(0,r.kt)("td",{parentName:"tr",align:null},'E "+" E);',"`")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+" > E "+" E;')),(0,r.kt)("td",{parentName:"tr",align:null},"`",'E = right ( E "+"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},'E "+" E);',"`"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+" E > E "+" ;'))))),(0,r.kt)("h5",{id:"follow-declaration"},"Follow Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A conditional ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),", constraining the characters that can immediately follow a symbol in\nthe input source text."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Symbol >> constraint"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Symbol !>> constraint")))),(0,r.kt)("p",null,"where a ",(0,r.kt)("em",{parentName:"p"},"constraint")," is any character class, a literal or a keyword non-terminal ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"!>>"),", the parser will not accept the ",(0,r.kt)("em",{parentName:"p"},"Symbol")," if it is immediately followed by the ",(0,r.kt)("em",{parentName:"p"},"terminal")," in the input\nstring. If the end of the symbol coincides with end-of-file, the constraint will always succeed and the symbol is\naccepted."),(0,r.kt)("h5",{id:"precede-declaration"},"Precede Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A conditional ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),", constraining the characters that can immediately precede a symbol in\nthe input source text."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"constraint << Symbol"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"constraint !<< Symbol")))),(0,r.kt)("p",null,"where a ",(0,r.kt)("em",{parentName:"p"},"constraint")," is any character class, a literal or a keyword non-terminal ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"!<<"),", the parser will not accept the ",(0,r.kt)("em",{parentName:"p"},"Symbol")," if it is immediately preceded by the ",(0,r.kt)("em",{parentName:"p"},"terminal")," in the input\nstring. If the start of the symbol coincides with start of the inout, the constraint will always succeed and the symbol\nis accepted."),(0,r.kt)("h5",{id:"priority-declaration"},"Priority Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare the priority of operators."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"syntax Exp = alt1 > alt2 > alt3")," is the basic syntax for priorities.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"syntax Exp = alt1 | alt2 > alt3 | alt4"),", where the ",(0,r.kt)("inlineCode",{parentName:"p"},"|")," signifies groups of equal priority")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"syntax Exp = associativity ( _alt1 | \u2026\u200b ) > _alt2"),", where an associativity group denotes a group of equal priority"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Priority declarations define a partial ordering between the productions ",(0,r.kt)("em",{parentName:"p"},"within a single non-terminal"),". The feature is\nspecifically designed to fit with the semantics of expression sub-languages embedded in programming languages. There\nexist other mechanisms for ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),", if ",(0,r.kt)("a",{parentName:"p",href:"#priority"},"Priority\nDeclaration")," does not work for you."),(0,r.kt)("p",null,"The semantics of a priority relation ",(0,r.kt)("inlineCode",{parentName:"p"},"A > B")," is that B will not be nested under A in the left-most or right-most\nposition. Any other position of A will allow B fine. Note that the priority relation you define is transitively closed,\nso if A ",">"," B and B ",">"," C then A ",">"," C."),(0,r.kt)("p",null,"A finer point is that Rascal restricts the filtering of priority such that it is guaranteed that no parse errors occur\nat the cause of a priority. The following table defines when and where Rascal forbids a direct nesting between two\nproductions ",(0,r.kt)("inlineCode",{parentName:"p"},"parent > child"),", depending on at which left-most or right-most positions the parent and the child are\nrecursive."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"If ",(0,r.kt)("inlineCode",{parentName:"th"},"Parent > Child")),(0,r.kt)("th",{parentName:"tr",align:null},"Parent None: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = "[" E "]"')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Left-most: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = E "*"')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Right-most: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = "*" E')),(0,r.kt)("th",{parentName:"tr",align:null},"Parent Both: ",(0,r.kt)("inlineCode",{parentName:"th"},'E = E "*" E')))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child None:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = "{" E "}"')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Left-most:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+"')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under right"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Right-most:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = "+" E')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left"),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Child Both:")," ",(0,r.kt)("inlineCode",{parentName:"td"},'E = E "+" E')),(0,r.kt)("td",{parentName:"tr",align:null},"No filter"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under right"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter under left and right")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"The following snippet uses all ",(0,r.kt)("a",{parentName:"p",href:"#priority"},"Priority Declaration")," features:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Exp\n  = A: Id\n  | B: Number\n  > C: Exp "[" Exp "]"\n  | D: Exp "!"\n  > E: Exp "*" Exp\n  > F: Exp "+" Exp;\n  | bracket G: "(" Exp ")"\n  ;\n')),(0,r.kt)("p",null,"A short explanation:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"C and D share a group of equal priority. They are incomparable in the partial ordering. That\u2019s fine because ",(0,r.kt)("inlineCode",{parentName:"p"},"1![2]"),"\nis not ambiguous.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Similarly A and B share a group; yet they are not recursive and so do not play any role in the priority ordering.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"C and D both have higher priority then E and F, which means that E and F may not be directly nested under C or D.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"However: E and F will be allowed under the second argument of C because it is not an outermost position. That\u2019s fine\nbecause ",(0,r.kt)("inlineCode",{parentName:"p"},"1 [2 + 3]")," is not ambiguous."))),(0,r.kt)("p",null,"Here a number of strings for this language, with brackets to show how they will be parsed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"1 + 2 ',"*",' 3" will be parsed as "1 + (2 ',"*",' 3)" because E ',">"," F.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"1 + 2 ',"["," 3 ","]",'" will be parsed as "1 + (2',"\\","[","3","\\","]",')" because C ',">"," F.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"1 ',"*"," 3","!",'" will be parsed as "1 + (3',"!",')" because D ',">"," E.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'"1 + ',"[","2 ","*"," 3","]",'" will be parsed as "1 + (',"[","2 ","*"," 3","]",')" because priority is only defined for outermost positions.'))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Short notation for common expression grammars")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Removes ambiguity but can not introduce parse errors")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Allows the use of less non-terminals for the same expression grammar (typically only one), which makes parse trees\nsimpler as well as the mapping to an abstract syntax tree more direct."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Please do not assume that Rascal\u2019s priorities have the same semantics as SDF\u2019s priorities.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When a priority does not have a filtering effect, such as in ",(0,r.kt)("inlineCode",{parentName:"p"},'E = E "+" > E ""')," it is usually better to use normal\nalternative composition: ",(0,r.kt)("inlineCode",{parentName:"p"},'E = E "+" | E "</emphasis>"'),". There is no difference in the semantics of parsing, but the\nlatter expression is more intentional.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'You should not hide right or left recursion behind a nullable non-terminal, since the system will not filter the\nambiguity then. Example: E = left "a"? E "',"*",'" E ',">",' E "" E will remain ambiguous. This should be written as: E = left\n("a" E "',"*",'" E | E "',"*",'" E ) ',">",' E "" E; (unfolding the optional such that E becomes explicitly left-most).'))),(0,r.kt)("h5",{id:"reserve-declaration"},"Reserve Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Reserve is a conditional ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),", constraining the set of strings that a symbol may produce."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Symbol \\ constraint"))),(0,r.kt)("p",null,"where a ",(0,r.kt)("em",{parentName:"p"},"constraint")," is any character class, a literal or a keyword non-terminal ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"."),(0,r.kt)("h3",{id:"parse-trees"},"Parse Trees"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"An algebraic data-type for parse trees; produced by all parsers generated from syntax definitions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Below is the full definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol"),". A parse tree is a nested tree structure of type\n",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Most internal nodes are applications (",(0,r.kt)("inlineCode",{parentName:"p"},"appl"),") of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," to a list of children ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," nodes. ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," is\nthe abstract representation of a ","[","syntax-definition","]"," rule, which consists of a definition of an alternative for a\n",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," by a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbols"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The leaves of a parse tree are always characters (",(0,r.kt)("inlineCode",{parentName:"p"},"char"),"), which have an integer index in the UTF8 table.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Some internal nodes encode ambiguity (",(0,r.kt)("inlineCode",{parentName:"p"},"amb"),") by pointing to a set of alternative ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," nodes."))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," types are an abstract notation for rules in ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),"s, while the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," type is the actual notation for parse trees."),(0,r.kt)("p",null,"Parse trees are called parse forests when they contain ",(0,r.kt)("inlineCode",{parentName:"p"},"amb")," nodes."),(0,r.kt)("p",null,"You can analyze and manipulate parse trees in three ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Directly on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," level, just like any other ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data Type"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Using ",(0,r.kt)("a",{parentName:"p",href:"#syntax"},"Concrete Syntax"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Using ",(0,r.kt)("a",{parentName:"p",href:"#action"},"Action"),"s"))),(0,r.kt)("p",null,"The type of a parse tree is the symbol that it\u2019s production produces, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},'appl(prod(sort("A"),[],{}),[])')," has type\n",(0,r.kt)("inlineCode",{parentName:"p"},"A"),". Ambiguity nodes Each such a non-terminal type has ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," as its immediate super-type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'// the following definition\nsyntax A = "a";\n// would make the following [Test] succeed:\ntest a() = parse(#A,"a") ==\nappl(prod(\n    sort("A"),\n    [lit("a")],\n    {}),\n  [appl(\n      prod(\n        lit("a"),\n        [\\char-class([range(97,97)])],\n        {}),\n      [char(97)])]);\n// you see that the defined non-terminal A ends up as the production for the outermost node. As the only child is the tree for recognizing the literal a, which is defined to be a single a from the character-class [ a ].\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'// when we use labels in the definitions, they also end up in the trees:\n// the following definition\nlexical A = myA:"a" B bLabel;\nlexical B = myB:"b";\n// would make the following [Test] succeed:\ntest a() = parse(#A,"ab") == appl(prod(label("myA",lex("A")),[lit("a"),sort("bLabel",lex("B"))],{}),[appl(prod(lit("a"),[\\char-class([range(97,97)]),[char(97)]),appl(prod(label("myB", lex("B"),[lit("b")],{}),[appl(prod(lit("b"),[\\char-class([range(98,98)]),[char(98)])]) ]);\n// here you see that the alternative name is a label around the first argument of `prod` while argument labels become labels in the list of children of a `prod`.\n')),(0,r.kt)("h3",{id:"symbol"},"Symbol"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The symbols that can occur in a syntax definition."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,"Nonterminal symbols are identifier names that ",(0,r.kt)("em",{parentName:"p"},"start with an uppercase letter"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol fieldName")),(0,r.kt)("td",{parentName:"tr",align:null},"Any symbol can be labeled with a field name that ",(0,r.kt)("em",{parentName:"td"},"starts with a lowercase letter"))))),(0,r.kt)("p",null,"The following literal symbols and character classes are defined:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"stringliteral"')),(0,r.kt)("td",{parentName:"tr",align:null},"Literal string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"'stringliteral'")),(0,r.kt)("td",{parentName:"tr",align:null},"Case-insensitive literal string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[range1 range2 \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},"Character class")))),(0,r.kt)("p",null,"The following operations on character classes can be composed arbitrarily:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Class"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!Class")),(0,r.kt)("td",{parentName:"tr",align:null},"Complement of ",(0,r.kt)("inlineCode",{parentName:"td"},"Class")," with respect to the UTF8 universe of characters")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Class1 - Class2")),(0,r.kt)("td",{parentName:"tr",align:null},"Difference of character classes ",(0,r.kt)("inlineCode",{parentName:"td"},"Class1")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"Class2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Class1 \\|\\| Class2")),(0,r.kt)("td",{parentName:"tr",align:null},"Union of character classes ",(0,r.kt)("inlineCode",{parentName:"td"},"Class1")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"Class2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Class1 && Class2")),(0,r.kt)("td",{parentName:"tr",align:null},"Intersection of character classes ",(0,r.kt)("inlineCode",{parentName:"td"},"Class1")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"Class2"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(Class)")),(0,r.kt)("td",{parentName:"tr",align:null},"Brackets for defining application order of class operators")))),(0,r.kt)("p",null,"The following regular expressions can be constructed over ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol?")),(0,r.kt)("td",{parentName:"tr",align:null},"Optional ",(0,r.kt)("em",{parentName:"td"},"Symbol"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol+")),(0,r.kt)("td",{parentName:"tr",align:null},"Non-empty list of ","_","Symbol","_","s")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol*")),(0,r.kt)("td",{parentName:"tr",align:null},"Possibly empty list of ","_","Symbol","_","s.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{Symbol1 Symbol2}+")),(0,r.kt)("td",{parentName:"tr",align:null},"Non-empty list of ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1"))," separated by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{Symbol1 Symbol2}*")),(0,r.kt)("td",{parentName:"tr",align:null},"Possibly empty list of ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1"))," separated by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2")),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(Symbol1 Symbol2 \u2026\u200b )")),(0,r.kt)("td",{parentName:"tr",align:null},"Embedded sequence of symbols")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(Symbol1 \\| Symbol2 \\| \u2026\u200b )")),(0,r.kt)("td",{parentName:"tr",align:null},"Embedded choice of alternative symbols")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"()")),(0,r.kt)("td",{parentName:"tr",align:null},"The anonymous non-terminal for the language with the empty string")))),(0,r.kt)("p",null,"Inline conditions (",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),"s) can be added to symbols to constrain their\nacceptability:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Disambiguation"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol _")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol")," ends at end of line or end of file")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^Symbol")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol")," starts at begin of line")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol @ ColumnIndex")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol")," starts at certain column index.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol1 >> Symbol2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1"))," must be (directly) followed by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol1 !>> Symbol2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1"))," must ",(0,r.kt)("em",{parentName:"td"},"not")," be (directly) followed by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol1 << Symbol2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2"))," must be (directly) preceded by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol1 !<< Symbol2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2"))," must ",(0,r.kt)("em",{parentName:"td"},"not")," be (directly) preceded by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Symbol1 \\ Symbol2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"1"))," must not be in the language defined by ",(0,r.kt)("em",{parentName:"td"},"Symbol",(0,r.kt)("sub",null,"2")))))),(0,r.kt)("p",null,"Symbols can be composed arbitrarily."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,"Every non-terminal symbol is a type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The basic symbols are the non-terminal name and the labeled non-terminal name. These refer to the names defined by\n",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),". You can use any defined non-terminal name in any other definition\n(lexical in syntax, syntax in lexical, etc)."),(0,r.kt)("p",null,"Then we have literals and character classes to define the ",(0,r.kt)("em",{parentName:"p"},"terminals")," of a grammar. When you use a literal such as\n",(0,r.kt)("inlineCode",{parentName:"p"},'"begin"'),", Rascal will produce a definition for it down to the character level before generating a parser: ",(0,r.kt)("inlineCode",{parentName:"p"},'syntax\n"begin" = [b][e][g][i][n];'),". This effect will be visible in the ",(0,r.kt)("a",{parentName:"p",href:"#trees"},"Parse Trees")," produced by\nthe parser. For case insensitive literals you will see a similar effect; the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"'begin'")," produces ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax 'begin' =\n[bB][eE][gG][iI][nN]"),"."),(0,r.kt)("p",null,"Character classes have the same escaping conventions as characters in a ",(0,r.kt)("a",{parentName:"p",href:"#string"},"String")," literal, but spaces and\nnewlines are meaningless and have to be escaped and the ",(0,r.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"]")," brackets as well as the dash ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," need escaping. For\nexample, one writes ",(0,r.kt)("inlineCode",{parentName:"p"},"[\\[ \\] \\ \\n\\-]")," for a class that includes the open and close square brackets and a space, a newline\nand a dash. Character classes support ranges as in ",(0,r.kt)("inlineCode",{parentName:"p"},"[a-zA-Z0-9]"),". Please note about character classes that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the operations on character classes are executed before parser generation time. You will not find explicit\nrepresentation of these operations in ","[","ParseTrees","]",", but rather their net effect as resulting character classes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Character classes are also ordered by Rascal and overlapping ranges are merged before parsers are generated.\nEquality between character classes is checked after this canonicalization.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Although all ",(0,r.kt)("a",{parentName:"p",href:"#symbol"},"Symbol"),"s are type constructors, the character class operators are not\nallowed in types."))),(0,r.kt)("p",null,"The other symbols either ",(0,r.kt)("em",{parentName:"p"},"generate")," for you parts of the construction of a grammar, or they ",(0,r.kt)("em",{parentName:"p"},"constrain")," the rules of the\ngrammar to generate a smaller set of trees as ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),"s."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"generative symbols")," are referred to as the ",(0,r.kt)("em",{parentName:"p"},"regular symbols"),". These are like named non-terminals, except that they\nare defined implicitly and interpreted by the parser generator to produce a parser that can recognize a symbol\noptionally, iteratively, alternatively, sequentially, etc. You also need to know this about the regular symbols:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In ",(0,r.kt)("a",{parentName:"p",href:"#parse-trees"},"Parse Trees")," you will find special nodes for the regular expression symbols that\nhide ",(0,r.kt)("em",{parentName:"p"},"how")," these were recognized.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns")," using ",(0,r.kt)("a",{parentName:"p",href:"#concrete-syntax"},"Concrete Syntax")," have special semantics for the\nregular symbols (list matching, separator handling, ignoring layout, etc.).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Regular symbols are not allowed in ",(0,r.kt)("em",{parentName:"p"},"keyword")," ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"s")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Depending on their occurrence in a ",(0,r.kt)("em",{parentName:"p"},"lexical"),", ",(0,r.kt)("em",{parentName:"p"},"syntax")," or ",(0,r.kt)("em",{parentName:"p"},"layout")," ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition")," the semantics of regular symbols changes. In the ",(0,r.kt)("em",{parentName:"p"},"syntax")," context,\nlayout non-terminals will be woven into the regular symbol, but not in the ",(0,r.kt)("em",{parentName:"p"},"lexical")," and ",(0,r.kt)("em",{parentName:"p"},"layout")," contexts. For\nexample, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol*")," in a ",(0,r.kt)("em",{parentName:"p"},"syntax")," definition such as ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax X = A*;")," will be processed to ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax X = `{A\nLayout}*"),". Similarly, ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax X = {A B}+;")," will be processed to ",(0,r.kt)("inlineCode",{parentName:"p"},"syntax X = {A (Layout B Layout)}+;"),"."))),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"constraint")," symbols are specially there to deal with the fact that Rascal does not generate a scanner. There are no\na priori disambiguation rules such as prefer keywords or longest match. Instead, you should use the constraint symbols\nto define the effect of keyword reservation and longest match."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"It is important to note that these constraints work on a character-by-character level in the input stream. So, a\nfollow constraint such as ",(0,r.kt)("inlineCode",{parentName:"p"},"A >> [a-z]")," means that the character immediately following a recognized A must be in the\nrange ",(0,r.kt)("inlineCode",{parentName:"p"},"[a-z]"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Read more on the constraint symbols via ",(0,r.kt)("a",{parentName:"p",href:"#disambiguation"},"Disambiguation"),"s."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"A character class that defines all alphanumeric characters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"lexical AlphaNumeric = [a-zA-Z0-9];\n")),(0,r.kt)("p",null,"A character class that defines anything except quotes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'lexical AnythingExceptQuote = ![\\"];\n')),(0,r.kt)("p",null,"An identifier class with longest match (can not be followed immediately by ","[","a-z","]","):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"lexical Id = [a-z]+ !>> [a-z];\n")),(0,r.kt)("p",null,"An identifier class with longest match and first match (can not be preceded or followed by ","[","a-z","]","):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"lexical Id = [a-z] !<< [a-z]+ !>> [a-z];\n")),(0,r.kt)("p",null,"An identifier class with some reserved keywords and longest match:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'lexical Id = [a-z]+ !>> [a-z] \\ "if" \\ "else" \\ "fi";\n')),(0,r.kt)("p",null,"An optional else branch coded using sequence and optional symbols:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Statement = "if" Expression "then" Statement ("else" Statement)? "fi";\n')),(0,r.kt)("p",null,"A block of statements separated by semicolons:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Statement = "{" {Statement ";"}* "}";\n')),(0,r.kt)("p",null,"A declaration with an embedded list of alternative modifiers and a list of typed parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Declaration = ("public" | "private" | "static" | "final")* Type Id "(" {(Type Id) ","}* ")" Statement;\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The symbol language is very expressive and can lead to short definitions of complex syntactic constructs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There is no built-in longest match for iterators, which makes syntax definitions open to languages that do not have\nlongest match.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There is no built-in keyword preference or reservation, which makes syntax definitions open to language composition\nand legacy languages."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"By nesting too many symbols definitions can be become hard to understand.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"By nesting too many symbols pattern matching and term construction becomes more complex. Extra non-terminals and\nrules with meaningful names can make a language specification more manageable.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The lack of automatic longest match and prefer keyword heuristics (you have to define it yourself), sometimes leads\nto unexpected ambiguity. See ","[","Disambiguation","]","."))),(0,r.kt)("h3",{id:"alias-declaration"},"Alias Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare an alias for a type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"alias Name = Type;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Everything can be expressed using the elementary types and values that are provided by Rascal. However, for the purpose\nof documentation and readability it is sometimes better to use a descriptive name as type indication, rather than an\nelementary type. The use of aliases is a good way to document your intentions."),(0,r.kt)("p",null,"An alias declaration states that ",(0,r.kt)("em",{parentName:"p"},"Name")," can be used everywhere instead of the already defined type ",(0,r.kt)("em",{parentName:"p"},"Type"),". Both types\nare thus structurally equivalent."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Introduce two aliases ",(0,r.kt)("inlineCode",{parentName:"p"},"ModuleId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Frequency")," for the type str."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"alias ModuleId = str;\nalias Frequency = int;\n")),(0,r.kt)("p",null,"Another example is an alias definition for a graph containing integer nodes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"alias IntGraph = rel[int,int];\n")),(0,r.kt)("p",null,"Note that the Rascal Standard Library provides a graph data type that is defined as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"alias Graph[&T] = rel[&T, &T];\n")),(0,r.kt)("p",null,"In other words the standard graph datatype can be parameterized with any element type."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#typeparameters"},"Type Parameters")," for other examples parameterized alias declarations."),(0,r.kt)("h3",{id:"annotation-declaration"},"Annotation Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Declare an annotation type for nodes. This feature is deprecated; please use ",(0,r.kt)("a",{parentName:"p",href:"#keyword-fields"},"Keyword Fields")," instead."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"anno AnnoType OnType @ Name")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An annotation may be associated with any node value, be it a pure node or some ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data\nType")," derived from it."),(0,r.kt)("p",null,"Annotations are intended to attach application data to values, like adding position information or control flow\ninformation to source code or adding visualization information to a graph."),(0,r.kt)("p",null,"An annotation declaration defines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"AnnoType"),", the type of the annotation values,")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"OnType"),", the type of the values that are being annotated,")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Name"),", the name of the annotation."))),(0,r.kt)("p",null,"Any value of any named type can be annotated and the type of these annotations can be declared precisely."),(0,r.kt)("p",null,"The following constructs are provided for handling annotations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Val @ Anno"),": is an expression that retrieves the value of annotation ",(0,r.kt)("em",{parentName:"p"},"Anno")," of value ",(0,r.kt)("em",{parentName:"p"},"Val")," (may be undefined","!",").\nSee ","[","Selection","]",".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Val1[@Anno = Val2]"),": is an expression that sets the value of annotation ",(0,r.kt)("em",{parentName:"p"},"Anno")," of the value ",(0,r.kt)("em",{parentName:"p"},"Val",(0,r.kt)("sub",null,"1"))," to\n",(0,r.kt)("em",{parentName:"p"},"Val",(0,r.kt)("sub",null,"2"))," and returns ",(0,r.kt)("em",{parentName:"p"},"Val",(0,r.kt)("sub",null,"1"))," with the new annotation value as result. See ",(0,r.kt)("a",{parentName:"p",href:"#replacement"},"Replacement"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Var @ Anno = Val"),": is an assignment statement that sets the value of annotation ",(0,r.kt)("em",{parentName:"p"},"Anno")," of the value of variable\n",(0,r.kt)("em",{parentName:"p"},"Var")," to ",(0,r.kt)("em",{parentName:"p"},"Val"),"."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Examples have been removed since this feature is deprecated."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Annotations are cumbersome since they change the structure of ",(0,r.kt)("a",{parentName:"li",href:"#values"},"Values")," without changing the\nsemantics of the identity of a value. This is why they are deprecated.")),(0,r.kt)("h3",{id:"tag-declaration"},"Tag Declaration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Tag declarations are not implemented (yet)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Tag declarations explain which type the expected value of a tag should have."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"They help the type checker to find common errors and they can help the parser to parse the contents of a string tag\nusing a context-free grammar declaration.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Not yet implemented, so basically tags are not checked")),(0,r.kt)("h2",{id:"patterns"},"Patterns"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Patterns are a notation for pattern matching used to detect if a value has a certain shape, and then to bind variables\nto parts of the matched value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,"For most of the ",(0,r.kt)("a",{parentName:"p",href:"#values"},"Values"),', there is a corresponding pattern matching operator. Then there are some\n"higher-order" matching operators which make complex patterns out of simpler ones. This is the complete list:'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Pattern"),(0,r.kt)("th",{parentName:"tr",align:null},"Syntax"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Literal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#boolean"},"Boolean"),", ",(0,r.kt)("a",{parentName:"td",href:"#integer"},"Integer"),", ",(0,r.kt)("a",{parentName:"td",href:"#real"},"Real"),", ",(0,r.kt)("a",{parentName:"td",href:"#number"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#string"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#location"},"Location"),", or ",(0,r.kt)("a",{parentName:"td",href:"#datetime"},"DateTime"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Regular Expression"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/<Regular Expression>/"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Variable declaration"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Type Var"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Multi-variable"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*Var"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*Type Var"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Variable"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Var"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"List"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[ Pat1, Pat2, \u2026\u200b, Patn ]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Set"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{ Pat1, Pat2, \u2026\u200b, Patn }"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Tuple"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"< Pat1, Pat2, \u2026\u200b, Patn >"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Node"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Name ( Pat1, Pat2, \u2026\u200b, Patn )"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Descendant"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/ Pat"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Labelled"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Var : Pat"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TypedLabelled"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Type Var : Pat"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TypeConstrained"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[Type] Pat"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Concrete"),(0,r.kt)("td",{parentName:"tr",align:null},"(Symbol) ","`"," ",(0,r.kt)("em",{parentName:"td"},"Token",(0,r.kt)("sub",null,"1"))," ",(0,r.kt)("em",{parentName:"td"},"Token",(0,r.kt)("sub",null,"2"))," \u2026\u200b ",(0,r.kt)("em",{parentName:"td"},"Token",(0,r.kt)("sub",null,"n"))," ","`")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Patterns are used to ",(0,r.kt)("strong",{parentName:"p"},"dispatch")," functions and conditional control flow, to ",(0,r.kt)("strong",{parentName:"p"},"extract")," information from values and to\nconditionally ",(0,r.kt)("strong",{parentName:"p"},"filter")," values. The pattern following pattern kinds can be arbitrarily nested, following the above\nsyntax:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concrete"},"Concrete Patterns"),": Concrete patterns.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#descendant"},"Descendant Pattern"),": Deep match in an abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#labelled"},"Labelled Pattern"),": Labelled abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#list"},"List Pattern"),": List in abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#literal"},"Literal Pattern"),": Literal in abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#multivariable"},"MultiVariable Pattern"),": Multi-variable (also known as Splice-variable) in abstract\npattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#node"},"Node pattern"),": Node in abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#regular"},"Regular Expression Pattern"),": Regular expression patterns.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#set"},"Set Pattern"),": Set in abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#tuple"},"Tuple Pattern"),": Tuple in abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#typeconstrained"},"Type Constrained Pattern"),": Type constrained abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#typedlabelled"},"Typed and Labelled Pattern"),": Typed, labelled, abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Pattern"),": Variable in abstract pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#variabledeclaration"},"Variable Declaration Pattern"),": Variable declaration in abstract pattern."))),(0,r.kt)("p",null,"All these patterns may be used in:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"cases of a ",(0,r.kt)("a",{parentName:"p",href:"#switch"},"Switch")," or ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit"),",")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"on the left of the ",(0,r.kt)("a",{parentName:"p",href:"#match"},"Boolean Match")," operator (",(0,r.kt)("inlineCode",{parentName:"p"},":="),"),")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"on the left of the ",(0,r.kt)("a",{parentName:"p",href:"#enumerator"},"Enumerator")," operator (",(0,r.kt)("inlineCode",{parentName:"p"},"\u2190"),"), and")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"as formal parameters of ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration"),"s.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#try-catch"},"Try Catch")," statements to match thrown exceptions."))),(0,r.kt)("p",null,"Each pattern binds variables in a conditional scope:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in further patterns to the right of the name which is bound in the same pattern")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in the body of case statement (either a replacement or a statement body)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in the conditions and bodies of \\<If",">",", \\<For",">",", and \\<While",">"," control flow statements")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"in the yielding expressions of comprehensions and in furter conditions of the comprehensions"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a pattern does not match, then it may be hard to find out why. A small test case is the best thing to create.\nOften a default alternative which \\<Throw",">","s an exception with the value which is not matched can be used to find\nout why this is happening.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a variable is bound in the scope of a pattern, then it acts as an ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," test, so make sure to use fresh variables\nto avoid such accidental collisions."))),(0,r.kt)("h3",{id:"concrete-patterns"},"Concrete Patterns"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Concrete patterns."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Concrete pattern with expected symbol type: (Symbol) ` Token1 Token2 ... Tokenn `\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Typed variable inside a concrete pattern: Type</emphasis> Var>\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A concrete pattern is a pattern for matching a ",(0,r.kt)("a",{parentName:"p",href:"#parse-trees"},"Parse Tree"),". The notation of a concrete pattern is the ",(0,r.kt)("strong",{parentName:"p"},"object\nlanguage")," itself, the language that the parse tree describes. In other words, you can use a code example to match\nparsed code using a concrete pattern. These concrete code examples can contain ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Pattern"),"s\nlike the other ",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns"),"."),(0,r.kt)("p",null,"The mechanism of concete patterns gives a good notation for matching complex structures such as a ",(0,r.kt)("a",{parentName:"p",href:"#parse-trees"},"Prase Tree"),",\nand it works in a simple manner:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the input code is parsed using a parser generated from a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"; this\ngenerates parse trees.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the pattern example code is parsed using the ",(0,r.kt)("strong",{parentName:"p"},"same")," parser; this generates parse trees with ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable\nPattern"),"s.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the parse tree with the ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Pattern"),"s is matches against the parse tree of the input code,\nsimilarly to the way ",(0,r.kt)("a",{parentName:"p",href:"#node"},"Node pattern"),"s work."))),(0,r.kt)("p",null,"So, you could say that ",(0,r.kt)("a",{parentName:"p",href:"#concrete"},"Concrete Patterns")," are a short notation for otherwise highly complex ",(0,r.kt)("a",{parentName:"p",href:"#node"},"Node\npattern"),"s on ",(0,r.kt)("a",{parentName:"p",href:"#parse-trees"},"Parse Tree"),". Note that the ",(0,r.kt)("a",{parentName:"p",href:"#typed-variable"},"Typed Variable"),"s in a concrete pattern can\nonly occur in the pattern at the location where the code for a full non-terminal of the ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition")," would be. The structure of a concrete pattern follows the structure of the\ngrammar in the ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition")," and the types of the ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable\nPattern"),"s are the syntax non-terminals of the ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),"."),(0,r.kt)("p",null,"Inside concrete syntax patterns, layout is ignored while pattern matching. So parse trees which have different\nwhitespace and comments but are otherwise the same will match anyway."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Examples (in a context where an appropriate concrete syntax has been defined):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Quoted syntax pattern with two pattern variable declarations:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'import ParseTree;\nsyntax Id = [a-z]+;\nsyntax Num = [0-9]+;\nsyntax Exp = left Exp "*" Exp > Exp "+" Exp |  Id | Num;\nlayout WS = [\\ \\n\\r\\t]*;\nvisit (parse(#exp, "x + x")) {\n   case (Exp) `<Id a> + <Id b>` => (Exp) `2 * <Id a>` when a == b\n}\n')),(0,r.kt)("p",null,"Some observations about this example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Notice how the non-terminals ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Id")," from the ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition")," become\ntypes for the pattern.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When this example pattern actually matches the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is bound and can be used again like any other ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable\nPattern"),"."))),(0,r.kt)("p",null,"A full example of concrete patterns can be found in ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#with-layout"},"WithLayout"),"."),(0,r.kt)("h3",{id:"descendant-pattern"},"Descendant Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Deep match in an abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A descendant pattern performs a deep match of the pattern ",(0,r.kt)("em",{parentName:"p"},"Pat"),". In other words, it matches when any element of the\nsubject at any depth that matches ",(0,r.kt)("em",{parentName:"p"},"Pat")," and is used to match, for instance, tree nodes at an arbitrary distance from the\nroot."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\ndata ColoredTree = leaf(int N)\n                 | red(ColoredTree left, ColoredTree right)\n                 | black(ColoredTree left, ColoredTree right);\nT = red(red(black(leaf(1), leaf(2)), black(leaf(3), leaf(4))), black(leaf(5), leaf(4)));\n")),(0,r.kt)("p",null,"Now we match for ",(0,r.kt)("inlineCode",{parentName:"p"},"black")," nodes with ",(0,r.kt)("inlineCode",{parentName:"p"},"leaf(4)")," as second argument:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for(/docs/black(_,leaf(4)) := T)\n    println("Match!");\n')),(0,r.kt)("p",null,"We use an ",(0,r.kt)("em",{parentName:"p"},"anonymous variable")," ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," at a position where we don\u2019t care about the actual value that is matched. In order to\nprint the actual values of the matches, we would need an ","[","Abstract/Labelled","]"," pattern."),(0,r.kt)("p",null,"Here we match all leaves that occur as second argument of ",(0,r.kt)("inlineCode",{parentName:"p"},"black"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for(/docs/black(_,leaf(int N)) := T)\n    println("Match <N>");\n')),(0,r.kt)("p",null,"Here we list all integers that occur in any leaf:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for(/docs/int N := T)\n    println("Match <N>");\n')),(0,r.kt)("p",null,"Rather than printing, we can also collect them in a list using ","[","$Statements/Append","]",":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"for(/docs/int N := T)\n    append N;\n")),(0,r.kt)("h3",{id:"labelled-pattern"},"Labelled Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Labelled abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A labelled pattern matches the same values as ",(0,r.kt)("em",{parentName:"p"},"Pat"),", but has as side-effect that the matched value is assigned to ",(0,r.kt)("em",{parentName:"p"},"Var"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\ndata ColoredTree = leaf(int N)\n                 | red(ColoredTree left, ColoredTree right)\n                 | black(ColoredTree left, ColoredTree right);\nT = red(red(black(leaf(1), leaf(2)), black(leaf(3), leaf(4))), black(leaf(5), leaf(4)));\nfor(/docs/M:black(_,leaf(4)) := T)\n    println("Match <M>");\n')),(0,r.kt)("p",null,"We use an ",(0,r.kt)("strong",{parentName:"p"},"anonymous variable")," ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," at a position where we don\u2019t care about the actual value that is matched."),(0,r.kt)("h3",{id:"list-pattern"},"List Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"List in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A list pattern matches a list value (the subject), provided that ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"2"),", \u2026\u200b,\n",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"n")," match the elements of that list in order. Special cases exist when one of the patterns\n",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"i")," is"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Pattern")," with a type that is identical to the element type of the subject list: the\nvariable is matched with the value at the corresponding position in the subject list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#multivariable"},"MultiVariable Pattern"),", with an optional element type that is identical to the element\ntype of the subject list: list matching is applied and the variable can match an arbitrary number of elements of the\nsubject list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"variable-pattern"),", where the variable has been declared with a list type, but not\ninitialized, outside the pattern: list matching is applied and the variable can match an arbitrary number of\nelements of the subject list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"variable-pattern"),", where the variable has been declared with a type equal to the element type of the\nsubject, but not initialized, outside the pattern: the variable is matched with the value at the corresponding\nposition in the subject list\n",(0,r.kt)("strong",{parentName:"p"},"Examples.")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A single variable")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if([10, int N, 30, 40, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeded, N = <N>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An untyped multi-variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if([10, *L, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeded, L = <L>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A typed multi-variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if([10, *int L, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeded, L = <L>");\n')),(0,r.kt)("p",null,"A list pattern may also be ",(0,r.kt)("em",{parentName:"p"},"non-linear"),", i.e., it may contain uses of variables that were bound earlier in the pattern\n(here, the second occurence of ",(0,r.kt)("inlineCode",{parentName:"p"},"L"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if([10, *L, 40, *L, 50] := [10, 20, 30, 40, 20, 30, 50])\n   println("Match succeeded, L = <L>");\n')),(0,r.kt)("p",null,"Here we see an example, where all pairs of equal elements in a list are printed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for([*L1, int N, *L2, N, *L3] := [ 5, 10, 20, 30, 40, 30, 15, 20, 10])\n    println("N = <N>");\n')),(0,r.kt)("p",null,"Here we print all ways in which a given list can be partitioned in two lists:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for([*L1, *L2] := [10, 20, 30, 40, 50])\n    println("<L1> and <L2>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Already declared list variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'list[int] L;\nif([10, L, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeded, L = <L>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Already declared element variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'int N;\nif([10, N, 30, 40, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeded, N = <N>");\n')),(0,r.kt)("h3",{id:"literal-pattern"},"Literal Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Literal in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A literal of one of the basic types ",(0,r.kt)("a",{parentName:"p",href:"#boolean"},"Boolean"),", ",(0,r.kt)("a",{parentName:"p",href:"#integer"},"Integer"),", ",(0,r.kt)("a",{parentName:"p",href:"#real"},"Real"),",\n",(0,r.kt)("a",{parentName:"p",href:"#number"},"Number"),", ",(0,r.kt)("a",{parentName:"p",href:"#string"},"String"),", ",(0,r.kt)("a",{parentName:"p",href:"#location"},"Location"),", or ",(0,r.kt)("a",{parentName:"p",href:"#datetime"},"DateTime")," can be\nused as abstract pattern. A literal pattern matches with a value that is identical to the literal."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"A literal pattern matches with a value that is equal to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'123 := 123\n"abc" := "abc"\n')),(0,r.kt)("p",null,"A literal pattern does not match with a value that is not equal to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'123 := 456\n"abc" := "def"\n')),(0,r.kt)("p",null,"If the type of the literal pattern is ",(0,r.kt)("strong",{parentName:"p"},"incomparable")," to the subject\u2019s type, a static type error is produced to\nannounce that the match is guaranteed to fail:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'123 := "abc";\n')),(0,r.kt)("p",null,"However, a literal pattern can be used to filter among other values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value x = "abc";\n123 := x;\nx = 123;\n123 := x;\n')),(0,r.kt)("h3",{id:"multivariable-pattern"},"MultiVariable Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Multi-variable (also known as Splice-variable) in abstract pattern."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"*Var"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"*Type Var")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A multi-variable is an abbreviation for a variable declaration pattern. It can occur in a list pattern or set pattern\nand can match zero or more list or set elements. Optionally the ",(0,r.kt)("strong",{parentName:"p"},"element type")," of the multi-variable may be specified."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\n")),(0,r.kt)("p",null,"Using lists:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if([10, *N, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeds, N == <N>");\n')),(0,r.kt)("p",null,"the above is equivalent with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if([10, *int N, 50] := [10, 20, 30, 40, 50])\n   println("Match succeeds, N == <N>");\n')),(0,r.kt)("p",null,"Using sets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if({10, *S, 50} := {50, 40, 30, 30, 10})\n   println("Match succeeds, S == <S>");\n')),(0,r.kt)("p",null,"the above is equivalent with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if({10, *int S, 50} := {50, 40, 30, 30, 10})\n   println("Match succeeds, S == <S>");\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"In older versions of Rascal the type of a multi-variable had to be a list or set type."),(0,r.kt)("h3",{id:"node-pattern"},"Node pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Node in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A node pattern matches a node value or a datatype value, provided that ",(0,r.kt)("em",{parentName:"p"},"Name")," matches with the constructor symbol of\nthat value and ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"2"),", \u2026\u200b, ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"n")," match the children of that value in order."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Match on node values (recall that the function symbol of a node has to be quoted, see ","[","Values/Node","]","):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nif("f"(A,13,B) := "f"("abc", 13, false))\n   println("A = <A>, B = <B>");\n')),(0,r.kt)("p",null,"Define a data type and use it to match:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'data Color = red(int N) | black(int N);\nif(red(K) := red(13))\n   println("K = <K>");\n')),(0,r.kt)("h3",{id:"regular-expression-pattern"},"Regular Expression Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Regular expression patterns."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Regular expressions are used to match a string value and to decompose it in parts and also to compose new strings.\nRegular expression patterns bind variables of type ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," when the match succeeds, otherwise they do not bind anything.\nThey can occur in cases of visit and switch statements, on the left-hand side of the match operator (",(0,r.kt)("inlineCode",{parentName:"p"},":=")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"!:="),") and\nas declarator in enumerators."),(0,r.kt)("p",null,"We use a regular expression language that slightly extends/modifies the Java Regex language:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Regular expression are delimited by ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"/")," optionally followed by modifiers (see below).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We allow ",(0,r.kt)("em",{parentName:"p"},"variable introductions"),", syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"<_Name_:_Regex_>"),", which introduce a variable of type ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," named ",(0,r.kt)("em",{parentName:"p"},"Name"),".\nA variable introduction corresponds to a group in a Java regexp. Each variable that is introduced should be unique,\nbut may be referenced more than once later in the regular expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Regular expressions may also contain ",(0,r.kt)("em",{parentName:"p"},"references to variables"),", syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"<_Name_>"),", the string value of variable\n",(0,r.kt)("inlineCode",{parentName:"p"},"Name")," is used at the position of the variable reference. This can be used to define so-called ",(0,r.kt)("em",{parentName:"p"},"non-linear"),"\npatterns.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Java regular expressions allow optional groups, which may introduce null bindings. Since uninitialized variables are\nnot allowed in Rascal, we limit the kinds of expressions one can write here by not allowing nesting of variable\nintroductions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"We allow variable references in a regular expression of the form: ",(0,r.kt)("inlineCode",{parentName:"p"},"<_Name_>")," which inserts the string value of\n",(0,r.kt)("em",{parentName:"p"},"Name")," in the pattern. $Name$ should have been introduced in the regular expression itself or in the context in\nwhich the regular expression occurs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In Perl matching options ",(0,r.kt)("em",{parentName:"p"},"follow")," the regular expression, but Java uses the notation ",(0,r.kt)("inlineCode",{parentName:"p"},"(?Option)")," at the ",(0,r.kt)("em",{parentName:"p"},"beginning"),"\nof the regular expression to set matching options. We support both styles. The following modifiers are supported:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"multi-line matching"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"(?m)")," at the start of the regular expression or the modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," at the end of the\nregular expression. The anchors ",(0,r.kt)("inlineCode",{parentName:"p"},"^")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," usually only match at the beginning and end of the subject string.\nWhen this option is set they also match any begin or end of line that is embedded in the subject string.\nExamples:")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"case-insensitive matching"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"(?i)")," or modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),". Match characters irrespective of their case.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"single-line mode"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"(?s)")," or modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},".")," expression does usually not match line terminators. When\nsingle-line mode is set, it will match any character including line terminators.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"unix lines"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"(?d)")," or modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"d"),". Usually newlines (",(0,r.kt)("inlineCode",{parentName:"p"},"\\n"),"), carriage return (",(0,r.kt)("inlineCode",{parentName:"p"},"\\r"),") and new line carriage\nreturn (",(0,r.kt)("inlineCode",{parentName:"p"},"\\n\\r"),") sequences are all considered line terminators. When this option is set, only newline is\nconsidered to be a line terminator."))))),(0,r.kt)("p",null,"For convenience, we summarize the most frequently used constructs in regular expressions in the following table."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},"The single character ",(0,r.kt)("inlineCode",{parentName:"td"},"x")," as long as it is not a punctuation character with a special meaning in the regular expression syntax")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\p")),(0,r.kt)("td",{parentName:"tr",align:null},"The punctuation character ",(0,r.kt)("inlineCode",{parentName:"td"},"p"),", this includes ",(0,r.kt)("inlineCode",{parentName:"td"},"!"),", ",(0,r.kt)("inlineCode",{parentName:"td"},'"'),", ",(0,r.kt)("inlineCode",{parentName:"td"},"#"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"$"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"%"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"'"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"("),", ",(0,r.kt)("inlineCode",{parentName:"td"},")"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"+"),", ",(0,r.kt)("inlineCode",{parentName:"td"},","),", ",(0,r.kt)("inlineCode",{parentName:"td"},"-"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"."),", ",(0,r.kt)("inlineCode",{parentName:"td"},"/"),", ",(0,r.kt)("inlineCode",{parentName:"td"},":"),", ",(0,r.kt)("inlineCode",{parentName:"td"},";"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"="),", ",(0,r.kt)("inlineCode",{parentName:"td"},">"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"?"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"@"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"["),", ",(0,r.kt)("inlineCode",{parentName:"td"},"\\"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"]"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"^"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"_"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"{"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"\\|"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"}"),", and ",(0,r.kt)("inlineCode",{parentName:"td"},"~"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\\\")),(0,r.kt)("td",{parentName:"tr",align:null},"The backslash character")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\n")),(0,r.kt)("td",{parentName:"tr",align:null},"Newline character")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\t")),(0,r.kt)("td",{parentName:"tr",align:null},"Tab character")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[\u2026\u200b]")),(0,r.kt)("td",{parentName:"tr",align:null},"One of the characters between the brackets (also known as ",(0,r.kt)("em",{parentName:"td"},"character class"),"). Character ranges and set operations on character classes may be used.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[^\u2026\u200b]")),(0,r.kt)("td",{parentName:"tr",align:null},"Any one character not between the brackets.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[a-z0-9]")),(0,r.kt)("td",{parentName:"tr",align:null},"Character range: character between ",(0,r.kt)("inlineCode",{parentName:"td"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"z")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"0")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"9"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},".")),(0,r.kt)("td",{parentName:"tr",align:null},"Any character except a line terminator. If single-line mode is set (using ",(0,r.kt)("inlineCode",{parentName:"td"},"(?s)")," or modifier ",(0,r.kt)("inlineCode",{parentName:"td"},"s"),"), then it matches any character including line terminators.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\d")),(0,r.kt)("td",{parentName:"tr",align:null},"Digit: ",(0,r.kt)("inlineCode",{parentName:"td"},"[0-9]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\D")),(0,r.kt)("td",{parentName:"tr",align:null},"Non-digit:","`"," ","[","^0-9","]","`")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\s")),(0,r.kt)("td",{parentName:"tr",align:null},"Whitespace")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\S")),(0,r.kt)("td",{parentName:"tr",align:null},"Anything but whitespace.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\w")),(0,r.kt)("td",{parentName:"tr",align:null},"A word: ",(0,r.kt)("inlineCode",{parentName:"td"},"[a-zA-Z0-9_]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\W")),(0,r.kt)("td",{parentName:"tr",align:null},"A non-word:","`"," ","[","^","\\","w","]","`")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"xy")),(0,r.kt)("td",{parentName:"tr",align:null},"Match ",(0,r.kt)("inlineCode",{parentName:"td"},"x")," followed by ",(0,r.kt)("inlineCode",{parentName:"td"},"y"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"`","x"),(0,r.kt)("td",{parentName:"tr",align:null},"y","`")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Match ",(0,r.kt)("inlineCode",{parentName:"td"},"x")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"y")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x?"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Optional occurrence of ",(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x*"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Zero or more occurrences of ",(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x+"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"One or more occurrences of ",(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x{n}"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Exactly ",(0,r.kt)("inlineCode",{parentName:"td"},"n")," occurrences of ",(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x{n,}"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"n")," or more occurrences of ",(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"x{n,m}"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"At least ",(0,r.kt)("inlineCode",{parentName:"td"},"n"),", at most ",(0,r.kt)("inlineCode",{parentName:"td"},"m")," occurrences of ",(0,r.kt)("inlineCode",{parentName:"td"},"x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The beginning of the subject string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"$"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The end of the input string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\b"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Word boundary: position between a word and a non-word character"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\\B"))))),(0,r.kt)("p",null,"Frequently used elements of Regular Expression Syntax"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here are some examples of regular expression patterns."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/\\brascal\\b/i\n")),(0,r.kt)("p",null,"does a case-insensitive match (",(0,r.kt)("inlineCode",{parentName:"p"},"i"),") of the word ",(0,r.kt)("inlineCode",{parentName:"p"},"rascal")," between word boundaries (",(0,r.kt)("inlineCode",{parentName:"p"},"\\b"),"). And"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/^.*?<word:\\w+><rest:.*$>/m\n")),(0,r.kt)("p",null,"does a multi-line match (",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"), matches the first consecutive word characters (",(0,r.kt)("inlineCode",{parentName:"p"},"\\w"),") and assigns them to the variable\n",(0,r.kt)("inlineCode",{parentName:"p"},"word"),". The remainder of the string is assigned to the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"rest"),"."),(0,r.kt)("p",null,"A variable reference used to make a non-linear pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/<x:[a-z]+>---<x>/\n")),(0,r.kt)("p",null,"matches strings like ",(0,r.kt)("inlineCode",{parentName:"p"},"abc---abc")," that consist of two identical sequences of letters separated by three dashes. Variables\nthat are referenced in a regular expression may also come from the context in which the regular expression occurs. For\ninstance,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/<x><n>/\n")),(0,r.kt)("p",null,"will use the current values of ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," as regular expression. For values ",(0,r.kt)("inlineCode",{parentName:"p"},'"abc"'),", respectively, ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," this would be\nequivalent to the regular expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/abc3/\n")),(0,r.kt)("p",null,"Observe that context variables may be of arbitrary type and that their value is first converted to a string before it is\ninserted in the regular expression. This can be used in many ways. For instance, regular expressions may contain\nrestrictions on the number of repetitions of an element: ",(0,r.kt)("inlineCode",{parentName:"p"},"/a{3}/")," will match exactly three letters a. Also minimum and\nmaximum number of occurrences can be defined. Here is how the repetition count can be inserted by a variable reference\n(where ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is assumed to have an integer value):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/a{<n>}/\n")),(0,r.kt)("p",null,"Taking this example one step further, we can even write"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/<x:a{<n>}>/\n")),(0,r.kt)("p",null,"in other words, we introduce variable ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and its defining regular expression contains a reference to a context\nvariable."),(0,r.kt)("p",null,"Multi-line matching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'/XX$/ := "lineoneXX\\nlinetwo";\n/XX$/m := "lineoneXX\\nlinetwo";\n/(?m)XX$/ := "lineoneXX\\nlinetwo";\n')),(0,r.kt)("p",null,"Case-insensitive matching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'/XX/ := "some xx";\n/XX/i := "some xx";\n/(?i)XX/ := "some xx";\n')),(0,r.kt)("p",null,"Single-line mode:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'/a.c/ := "abc";\n/a.c/ := "a\\nc";\n/a.c/s := "a\\nc";\n/(?s)a.c/ := "a\\nc";\n')),(0,r.kt)("p",null,"Here are examples, how to escape punctuation characters in regular expressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'/a\\/b/ := "a/b";\n/a\\+b/ := "a+b";\n')),(0,r.kt)("h3",{id:"set-pattern"},"Set Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Set in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A set pattern matches a set value (the subject), provided that ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"2"),", \u2026\u200b,\n",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"n")," match the elements of that set in ",(0,r.kt)("strong",{parentName:"p"},"any")," order (recall that the elements of a set are unordered and\ndo not contain duplicates). Completely analogous to list patterns, there are special cases when one of the patterns\n",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"i")," is"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#variabledeclaration"},"Variable Declaration Pattern")," with a type that is identical to the element type of\nthe subject set: the variable is matched with one value in the subject set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#multivariable"},"MultiVariable Pattern"),", with an optional element type that is identical to the element\ntype of the subject set: set matching is applied and the variable can match an arbitrary number (in arbitrary order)\nof elements of the subject set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Pattern"),", where the variable has been declared with a set type, but not initialized,\noutside the pattern: set matching is applied and the variable can match an arbitrary number (in arbitrary order) of\nelements of the subject set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable Pattern"),", where the variable has been declared with a type equal to the element type\nof the subject, but not initialized, outside the pattern: the variable is matched with one value in the subject set."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A single variable")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if({10, 30, 40, 50, int N} := {10, 20, 30, 40, 50})\n   println("Match succeeded, N = <N>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"An untyped multi-variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if({10, *S, 50} := {50, 40, 30, 20, 10})\n   println("Match succeeded, S = <S>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A typed multi-variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if({10, *int S, 50} := {50, 40, 30, 20, 10})\n   println("Match succeeded, S = <S>");\n')),(0,r.kt)("p",null,"Here we see an example, where all possible splits of a set in two subsets are printed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for({*S1, *S2} :={30, 20, 10})\n    println("<S1> and <S2>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Already declared set variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'set[int] S;\nif({10, *S, 50} := {10, 20, 30, 40, 50})\n   println("Match succeeded, S = <S>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Already declared element variable:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'int N;\nif({10, N, 30, 40, 50} := {50, 40, 30, 20, 10})\n   println("Match succeeded, N = <N>");\n')),(0,r.kt)("h3",{id:"tuple-pattern"},"Tuple Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Tuple in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A tuple pattern matches a tuple value, provided that ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"2"),", \u2026\u200b, ",(0,r.kt)("em",{parentName:"p"},"Pat"),(0,r.kt)("sub",null,"n")," match\nthe elements of that tuple in order."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nif(<A, B, C> := <13, false, "abc">)\n   println("A = <A>, B = <B>, C = <C>");\n')),(0,r.kt)("h3",{id:"type-constrained-pattern"},"Type Constrained Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Type constrained abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A type constrained pattern matches provided that the subject has type ",(0,r.kt)("em",{parentName:"p"},"Type")," and ",(0,r.kt)("em",{parentName:"p"},"Pat")," matches. This can be handy in\ncase of ambiguity (say more than one constructor with the same name), or in case the pattern is completely general. See\nan example below:"),(0,r.kt)("p",null,"Warning: This does not seem to work properly. There is a bug."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\n")),(0,r.kt)("p",null,"Some example data type which contains generic values as well as specific expressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'data Exp = val(value v) | add(Exp l, Exp r) | sub(Exp l, Exp r);\nex = add(add(val("hello"(1,2)),val("bye")), sub(val(1),val(2)));\n')),(0,r.kt)("p",null,"Here we constrain the match to find only Exps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'visit (ex) {\n  case [Exp] str name(_,_) : println("node name is <name>");\n}\n')),(0,r.kt)("p",null,"Here we do not constrain the same pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'visit (ex) {\n  case str name(_,_) : println("node name is <name>");\n}\n')),(0,r.kt)("h3",{id:"typed-and-labelled-pattern"},"Typed and Labelled Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Typed, labelled, abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A typed, labelled, pattern matches when the subject value has type ",(0,r.kt)("em",{parentName:"p"},"Type")," and ",(0,r.kt)("em",{parentName:"p"},"Pat")," matches. The matched value is\nassigned to ",(0,r.kt)("em",{parentName:"p"},"Var"),"."),(0,r.kt)("p",null,"This construct is used for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"binding the ",(0,r.kt)("em",{parentName:"p"},"whole pattern")," to a variable while also matching some stuff out of it: ",(0,r.kt)("inlineCode",{parentName:"p"},"MyType t :\nsomeComplexPattern(f(int a), int b))"),". This is similar to ",(0,r.kt)("a",{parentName:"p",href:"#labelled"},"Labelled Pattern"),"s but with an extra\ntype")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"to assert that the pattern has a certain type. This can be useful in disambiguating a constructor name, as in the\nexample below."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\ndata Lang = add(Lang l, Lang r) | number(int i);\ndata Exp = id(str n) | add(Exp l, Exp r) | subtract(Exp l, Exp r) | otherLang(Lang a);\nex = add(id("x"), add(id("y"), otherLang(add(number(1),number(2)))));\nvisit (ex) {\n  case Lang l:add(_,_) : println("I found a Lang <l>");\n  case Exp e:add(_,_)  : println("And I found an Exp <e>");\n}\n')),(0,r.kt)("h3",{id:"variable-pattern"},"Variable Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Variable in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Var")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A variable pattern can act in two roles:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Var")," has already a defined value then it matches with that value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Var")," has not been defined before (or it has been declared but not initialized) then it matches any value. That\nvalue is assigned to ",(0,r.kt)("em",{parentName:"p"},"Var"),". The scope of this variable is the outermost expression in which the pattern occurs or\nthe enclosing ",(0,r.kt)("a",{parentName:"p",href:"#if"},"If"),", ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", or ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," if the pattern occurs in the\ntest expression of those statements."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Initialize variable ",(0,r.kt)("inlineCode",{parentName:"p"},"N")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"N = 10;\n")),(0,r.kt)("p",null,"and use ",(0,r.kt)("inlineCode",{parentName:"p"},"N")," in a pattern; its value is used as value to match with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"N := 10;\nN := 20;\n")),(0,r.kt)("p",null,"Use a non-existing variable in a pattern, it is bound when the match succeeds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nif(M := 10)\n   println("Match succeeded, M == <M>");\n')),(0,r.kt)("h3",{id:"variable-declaration-pattern"},"Variable Declaration Pattern"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Variable declaration in abstract pattern."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A variable declaration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Type Var\n")),(0,r.kt)("p",null,"can be used as abstract pattern. A variable declaration introduces a new variable ",(0,r.kt)("em",{parentName:"p"},"Var")," that matches any value of the\ngiven type ",(0,r.kt)("em",{parentName:"p"},"Type"),". That value is assigned to ",(0,r.kt)("em",{parentName:"p"},"Var")," when the whole match succeeds."),(0,r.kt)("p",null,"The scope of this variable is the outermost expression in which the pattern occurs or the enclosing\n",(0,r.kt)("a",{parentName:"p",href:"#if"},"If"),", ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", or ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," if the pattern occurs in the test expression\nof those statements."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Let\u2019s first perform a match that succeeds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'str S := "abc";\n')),(0,r.kt)("p",null,"and now we attempt to inspect the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S;\n")),(0,r.kt)("p",null,"As mentioned above: ",(0,r.kt)("inlineCode",{parentName:"p"},"S")," is only bound in the scope of the match expression","!"," Let\u2019s explore how bindings work in an if\nstatement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nif(str S := "abc")\n   println("Match succeeds, S == \\"<S>\\"");\n')),(0,r.kt)("h2",{id:"expressions"},"Expressions"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The expressions available in Rascal."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The expression is the basic unit of evaluation and may consist of the ingredients shown in the figure."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An elementary ",(0,r.kt)("em",{parentName:"p"},"literal value"),", e.g. constants of the types ",(0,r.kt)("a",{parentName:"p",href:"#boolean"},"Boolean"),", ",(0,r.kt)("a",{parentName:"p",href:"#integer"},"Integer"),",\n",(0,r.kt)("a",{parentName:"p",href:"#real"},"Real"),", ",(0,r.kt)("a",{parentName:"p",href:"#number"},"Number"),", ",(0,r.kt)("a",{parentName:"p",href:"#string"},"String"),", ",(0,r.kt)("a",{parentName:"p",href:"#location"},"Location")," or\n",(0,r.kt)("a",{parentName:"p",href:"#datetime"},"DateTime"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("em",{parentName:"p"},"structured value")," for ",(0,r.kt)("a",{parentName:"p",href:"#list"},"List"),", ",(0,r.kt)("a",{parentName:"p",href:"#set"},"Set"),", ",(0,r.kt)("a",{parentName:"p",href:"#map"},"Map"),", ",(0,r.kt)("a",{parentName:"p",href:"#tuple"},"Tuple")," or\n",(0,r.kt)("a",{parentName:"p",href:"#relation"},"Relation"),". The elements are first evaluated before the structured value is built.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("em",{parentName:"p"},"variable")," that evaluates to its current value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A call to a function or constructor:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("em",{parentName:"p"},"function call"),". First the arguments are evaluated and the corresponding function is called. The value\nreturned by the function is used as value of the function call. See ",(0,r.kt)("a",{parentName:"p",href:"#call"},"Call"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("em",{parentName:"p"},"constructor"),". First the arguments are evaluated and then a data value is constructed for the corresponding\ntype. This data value is used as value of the constructor. Constructors are functions that can be used in all\ncontexts where functions can be used. See ",(0,r.kt)("a",{parentName:"p",href:"#constructor"},"Constructor"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An operator expression. The operator is applied to the arguments; the evaluation order of the arguments depends on\nthe operator. The result returned by the operator is used as value of the operator expression. See\n",(0,r.kt)("a",{parentName:"p",href:"#operators"},"Operators"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehensions"},"Comprehensions"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("a",{parentName:"p",href:"#any"},"Boolean Any")," expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An ",(0,r.kt)("a",{parentName:"p",href:"#all"},"Boolean All")," expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Some statements like ",(0,r.kt)("a",{parentName:"p",href:"#if"},"If"),", ",(0,r.kt)("a",{parentName:"p",href:"#for"},"For"),", ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While")," and\n",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," can also be used in expressions, see ",(0,r.kt)("a",{parentName:"p",href:"#statementasexpression"},"Statement as\nExpression"),"."))),(0,r.kt)("h3",{id:"values"},"Values"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The different types of values."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#boolean"},"Boolean"),": Boolean values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#all"},"Boolean All"),": All argument expressions are true.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#and"},"Boolean And"),": Boolean ",(0,r.kt)("em",{parentName:"p"},"and")," operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#any"},"Boolean Any"),": Any combination of argument values is true.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equivalence"},"Boolean Equivalence"),": The ",(0,r.kt)("em",{parentName:"p"},"equivalence")," operator on Boolean values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#ifdefinedelse"},"Boolean IfDefinedElse"),": Test whether expression has a defined value, otherwise provide\nalternative.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#implication"},"Boolean Implication"),": The ",(0,r.kt)("em",{parentName:"p"},"implication")," operator on Boolean values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#isdefined"},"Boolean IsDefined"),": Test whether the value of an expression is defined.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#match"},"Boolean Match"),": Match a pattern against an expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#negation"},"Boolean Negation"),": The ",(0,r.kt)("em",{parentName:"p"},"not")," operator on Boolean values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#nomatch"},"Boolean NoMatch"),": Negated ","[","Boolean Match","]"," operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#or"},"Boolean Or"),": The ",(0,r.kt)("em",{parentName:"p"},"or")," operator on Boolean values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#constructor"},"Constructor"),": Constructors create values for user-defined datatypes (Algebraic Datatypes).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#datetime"},"DateTime"),": Date and time values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"DateTime Equal"),": Equality on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"DateTime Field Selection"),": Select a field from a datetime value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"DateTime GreaterThan"),": Greater than operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"DateTime GreaterThanOrEqual"),": Greater than or equal operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"DateTime LessThan"),": Less than operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"DateTime LessThanOrEqual"),": Less than or equal operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"DateTime NotEqual"),": Not equal operator on datetime values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#integer"},"Integer"),": Integer values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#list"},"List"),": List values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#append"},"List Append"),": Append an element at the end of a list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"List Comprehension"),": A list comprehension generates a list value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"List Concatenation"),": Concatenate two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#difference"},"List Difference"),": The difference between two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"List Equal"),": Equality on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#insert"},"List Insert"),": add an element in front of a list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#intersection"},"List Intersection"),": Intersection of two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"List NotEqual"),": Not equal operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#product"},"List Product"),": Compute the product of two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"List Slice"),": Retrieve a slice of a list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#splice"},"List Splice"),": Splice the elements of a list in an enclosing list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsublist"},"List StrictSubList"),": The strict sublist operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsuperlist"},"List StrictSuperList"),": The strict super list operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#sublist"},"List SubList"),": The sublist operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"List Subscription"),": Retrieve a list element via its index.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#superlist"},"List SuperList"),": The super list operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#in"},"List in"),": Membership test on list elements.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notin"},"List notin"),": Negated membership test on lists.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#listrelation"},"ListRelation"),": ListRelation values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#cartesianproduct"},"ListRelation CartesianProduct"),": Cartesian product of two list relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#composition"},"ListRelation Composition"),": Composition of two list relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"ListRelation FieldSelection"),": Select a field (column) from a list relation value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#join"},"ListRelation Join"),": Join two list relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reflexivetransitiveclosure"},"ListRelation Reflexive Transitive Closure"),": The reflexive transitive\nclosure of a binary list relation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"ListRelation Subscription"),": Indexing of a list relation via tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#transitiveclosure"},"ListRelation Transitive Closure"),": Transitive closure on binary list relation\nvalues.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#location"},"Location"),": (Source code) location values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#addsegment"},"Location AddSegment"),": Locations can be concatenated with strings to add segments to the\npath component.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Location Equal"),": Equality operator on locations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"Location FieldSelection"),": Field selection on locations.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Location GreaterThan"),": The greater than operator on location values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Location GreaterThanOrEqual"),": The greater than or equal operator on location\nvalues.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Location LessThan"),": The less than operator on location values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Location LessThanOrEqual"),": The less than or equal operator on location values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"NotEqual"),": The not equal operator on location values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#map"},"Map"),": Map values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#composition"},"Map Composition"),": Composition of two map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Map Comprehension"),": A map comprehension generates a map value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#difference"},"Map Difference"),": The difference between two maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Map Equal"),": Equality operator on maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#intersection"},"Map Intersection"),": Intersection of two maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Map NotEqual"),": Not equal operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsubmap"},"Map StrictSubMap"),": Strict submap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsupermap"},"Map StrictSuperMap"),": Strict supermap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#submap"},"Map SubMap"),": Submap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Map Subscription"),": Retrieve a value by its key in map.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#supermap"},"Map SuperMap"),": Supermap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#union"},"Map Union"),": Union of two maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#in"},"Map in"),": Membership test on the keys of a map.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notin"},"Map notin"),": Negated membership test on the keys of a map.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#node"},"Node"),": Node values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Node Equal"),": Equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Node GreaterThan"),": Greater than operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Node GreaterThanOrEqual"),": Greater than or equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Node LessThan"),": Less than operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Node LessThanOrEqual"),": Less than or equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Node NotEqual"),": Not equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"Node Slice"),": Retrieve a slice of a node\u2019s argument list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Node Subscription"),": Retrieve an argument of a node via its index.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#number"},"Number"),": Numeric values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#addition"},"Number Addition"),": Addition on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#conditional"},"Number Conditional"),": Conditional expression for numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#division"},"Number Division"),": Division on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Number Equal"),": Equality operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Number GreaterThan"),": Greater than operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Number GreaterThanOrEqual"),": Greater than or equal operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Number LessThan"),": Less than operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Number LessThanOrEqual"),": Less than or equal operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#multiplication"},"Number Multiplication"),": Multiply two numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#negation"},"Number Negation"),": Negate a numeric value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Number NotEqual"),": Not equal operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#remainder"},"Number Remainder"),": Remainder of two integer values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subtraction"},"Number Subtraction"),": Subtract two numeric values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#range"},"Range"),": Numeric range of values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#real"},"Real"),": Real values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reifiedtypes"},"ReifiedTypes"),": Types can be represented by values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#relation"},"Relation"),": Relation values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#cartesianproduct"},"Relation CartesianProduct"),": Cartesian product of two relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#composition"},"Relation Composition"),": Composition of two relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"Relation FieldSelection"),": Select a field (column) from a relation value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#join"},"Relation Join"),": Join two relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reflexivetransitiveclosure"},"Relation ReflexiveTransitiveClosure"),": The reflexive transitive closure of\na binary relation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Relation Subscription"),": Indexing of a relation via tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#transitiveclosure"},"Relation TransitiveClosure"),": Transitive closure on binary relation values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#set"},"Set"),": Set values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Set Comprehension"),": A set comprehension generates a set value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#difference"},"Set Difference"),": The difference between two sets.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Set Equal"),": Equal operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#insert"},"Set Insert"),": Add an element to a set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#intersection"},"Set Intersection"),": Intersection of two sets.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Set NotEqual"),": Not equal operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#product"},"Set Product"),": The product of two set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#splice"},"Set Splice"),": Splice the elements of a set in an enclosing set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsubset"},"Set StrictSubSet"),": Strict subset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsuperset"},"Set StrictSuperSet"),": Strict superset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subset"},"Set SubSet"),": Subset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#superset"},"Set SuperSet"),": Superset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#union"},"Set Union"),": Union of two set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#in"},"Set in"),": Membership test on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notin"},"Set notin"),": Negated membership test on set values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#string"},"String"),": String values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"String Concatenation"),": Concatenate two strings.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"String Equal"),": Equality operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"String GreaterThan"),": Greater than operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"String GreaterThanOrEqual"),": Greater than or equal operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"String LessThan"),": Less than operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"String LessThanOrEqual"),": Less than or equal operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"String NotEqual"),": Not equal operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"String Slice"),": Retrieve a slice of a string.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"String Subscription"),": Retrieve a substring via its index.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#tuple"},"Tuple"),": Tuple values."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"Tuple Concatenation"),": Concatenate two tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Tuple Equal"),": Equality operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"Tuple FieldSelection"),": Select a field from a tuple by its field name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Tuple GreaterThan"),": Greater than operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Tuple GreaterThanOrEqual"),": Greater than or equal operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Tuple LessThan"),": Less than operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Tuple LessThanOrEqual"),": Less than or equal operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Tuple NotEqual"),": Not equal operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Tuple Subscription"),": Retrieve a tuple field by its index position.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#value"},"Value"),": Values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),"."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#conditional"},"Value Conditional"),": Conditional expression on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Value Equal"),": Equal operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Value GreaterThan"),": Greater than operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Value GreaterThanOrEqual"),": Greater than or equal operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Value LessThan"),": Less than operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Value LessThanOrEqual"),": Less than or equal operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Value NotEqual"),": Not equal operator on values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#void"},"Void"),": Values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"void"),"."))),(0,r.kt)("h3",{id:"boolean"},"Boolean"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Boolean values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"false")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bool")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The Booleans are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," which has two values: ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,"The Boolean operators (to be more precise: operators with a value of type Boolean as result) have ",(0,r.kt)("em",{parentName:"p"},"short-circuit"),"\nsemantics. This means that the operands are evaluated until the outcome of the operator is known."),(0,r.kt)("p",null,"Most operators are self-explanatory except the match (:=) and no match (","!",":=) operators that are also the main reason to\ntreat Boolean operator expressions separately. Although we describe patterns in full detail in\n",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns"),", a preview is useful here. A pattern can"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"match (or not match) any arbitrary value (that we will call the ",(0,r.kt)("em",{parentName:"p"},"subject value"),");")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"during the match variables may be bound to subvalues of the subject value."))),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"match")," operator"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Pat := Exp\n")),(0,r.kt)("p",null,"is evaluated as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp")," is evaluated, the result is a subject value;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the subject value is matched against the pattern ",(0,r.kt)("em",{parentName:"p"},"Pat"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"if the match succeeds, any variables in the pattern are bound to subvalues of the subject value and the match\nexpression yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"if the match fails, no variables are bound and the match expression yields ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."))),(0,r.kt)("p",null,"This looks and ",(0,r.kt)("em",{parentName:"p"},"is")," nice and dandy, so why all this fuss about Boolean operators? The catch is that\u2014\u200bas we will see in\n",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns"),"--a match need not be unique. This means that there may be more than one way of matching the\nsubject value resulting in different variable bindings."),(0,r.kt)("p",null,"This behaviour is applicable in the context of all Rascal constructs where a pattern match determines the flow of\ncontrol of the program, in particular:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Boolean expressions: when a pattern match fails that is part of a Boolean expression, further solutions are tried in\norder to try to make the Boolean expression true.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Tests in ",(0,r.kt)("a",{parentName:"p",href:"#for"},"For"),", ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," statements.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Tests in ",(0,r.kt)("a",{parentName:"p",href:"#any"},"Boolean Any")," and ",(0,r.kt)("a",{parentName:"p",href:"#all"},"Boolean All")," expressions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Tests and ",(0,r.kt)("a",{parentName:"p",href:"#enumerator"},"Enumerator"),"s in comprehensions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Pattern matches in cases of a ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Pattern matches in cases of a ",(0,r.kt)("a",{parentName:"p",href:"#switch"},"Switch"),"."))),(0,r.kt)("p",null,"The following operators are provided for Boolean:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#all"},"Boolean All"),": All argument expressions are true.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#and"},"Boolean And"),": Boolean ",(0,r.kt)("em",{parentName:"p"},"and")," operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#any"},"Boolean Any"),": Any combination of argument values is true.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equivalence"},"Boolean Equivalence"),": The ",(0,r.kt)("em",{parentName:"p"},"equivalence")," operator on Boolean values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#ifdefinedelse"},"Boolean IfDefinedElse"),": Test whether expression has a defined value, otherwise provide\nalternative.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#implication"},"Boolean Implication"),": The ",(0,r.kt)("em",{parentName:"p"},"implication")," operator on Boolean values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#isdefined"},"Boolean IsDefined"),": Test whether the value of an expression is defined.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#match"},"Boolean Match"),": Match a pattern against an expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#negation"},"Boolean Negation"),": The ",(0,r.kt)("em",{parentName:"p"},"not")," operator on Boolean values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#nomatch"},"Boolean NoMatch"),": Negated ","[","Boolean Match","]"," operator.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#or"},"Boolean Or"),": The ",(0,r.kt)("em",{parentName:"p"},"or")," operator on Boolean values."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#boolean"},"library functions")," available for Booleans."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the following match of a list"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, *int L, 2, *int M] := [1,2,3,2,4]\n")),(0,r.kt)("p",null,"By definition ",(0,r.kt)("inlineCode",{parentName:"p"},"list[int] L")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"list[int] M")," match list elements that are part of the enclosing list in which they\noccur. If they should match a nested list each should be enclosed in list brackets."),(0,r.kt)("p",null,"There are two solutions for the above match:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"L")," = ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," =","`"," ","[","2, 3, 2, 4","]","`","; and")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"L")," = ",(0,r.kt)("inlineCode",{parentName:"p"},"[2,3]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," =","`"," ","[","4","]","`","."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nfor ([1, *int L, 2, *int M] := [1,2,3,2,4])\n  println("L: <L>, M: <M>");\n')),(0,r.kt)("p",null,"Depending on the context, only the first solution of a match expression is used, respectively all solutions are used. If\na match expression occurs in a larger Boolean expression, a subsequent subexpression may yield false and\u2009\u2014\u2009depending on\nthe actual operator\u2009\u2014\u2009evaluation backtracks to a previously evaluated match operator to try a next solution. Let\u2019s\nillustrate this by extending the above example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"[1, *int L, 2, *int M] := [1,2,3,2,4] && size(L) > 0\n")),(0,r.kt)("p",null,"where we are looking for a solution in which L has a non-empty list as value. Evaluation proceeds as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The left argument of the ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," operator is evaluated: the match expression is evaluated resulting in the bindings ",(0,r.kt)("inlineCode",{parentName:"p"},"L\n= []")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"M = [2, 3, 2, 4]"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The right argument of the ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," operator is evaluated: ",(0,r.kt)("inlineCode",{parentName:"p"},"size(L) > 0")," yields ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Backtrack to the left argument of the ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," operator to check for more solutions: indeed there are more solutions\nresulting in the bindings ",(0,r.kt)("inlineCode",{parentName:"p"},"L = [2,3]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"M = [4]"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Proceed to the right operator of ",(0,r.kt)("inlineCode",{parentName:"p"},"&&"),": this time ",(0,r.kt)("inlineCode",{parentName:"p"},"size(L) > 0")," yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The result of evaluating the complete expression is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\nimport List;\n")),(0,r.kt)("p",null,"for prints them all:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'for ([1, *int L, 2, *int M] := [1,2,3,2,4] && size(L) > 0)\n  println("L: <L>, M: <M>");\n')),(0,r.kt)("p",null,"if prints the first"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'if ([1, *int L, 2, *int M] := [1,2,3,2,4] && size(L) > 0)\n  println("L: <L>, M: <M>");\n')),(0,r.kt)("h5",{id:"boolean-all"},"Boolean All"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"All argument expressions are true."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"all ( Exp1, Exp2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"all ( Exp1, Exp2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," when all combinations of values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"i")," are true."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Are all integers 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 even?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"all(int n <- [1 .. 10], n % 2 == 0);\n")),(0,r.kt)("p",null,"Are all integers 0, 2, 4, 6, 8, 10 even?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"all(int n <- [0, 2 .. 10], n % 2 == 0);\n")),(0,r.kt)("p",null,"When one of the ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"i")," enumerates the elements of an empty list, ",(0,r.kt)("inlineCode",{parentName:"p"},"all")," always returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"all(int n <- [], n > 0);\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Warning")),(0,r.kt)("p",{parentName:"blockquote"},"The Rascal interpreter and compiler give different results on an empty list. The interpreter returns ",(0,r.kt)("inlineCode",{parentName:"p"},"fals")," for the\nabo eexample.")),(0,r.kt)("h5",{id:"boolean-and"},"Boolean And"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Boolean ",(0,r.kt)("em",{parentName:"p"},"and")," operator."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 && Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 && Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"and")," operator on Boolean values defined as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 && Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))))),(0,r.kt)("p",null,"Boolean operators have ",(0,r.kt)("em",{parentName:"p"},"short circuit")," semantics: only those operands are evaluated that are needed to compute the\nresult. In the case of the ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," operator, the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp1")," evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp2")," is\nevaluated to determine the result."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," backtracks over its argument expressions until it can find an evaluation that yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," unless there\nis none. This may happen if the left or right expression is a non-deterministic pattern match or a value generator."),(0,r.kt)("p",null,"Variable assignments as a result of matching or generator expressions under a ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," are visible outside the context of\nthe operator, but only if the context is conditional, such as an if-then-else or a for loop. Note that if one of the\nargument expressions evaluates to false, then no binding is done either."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'true && false;\ni <- [1,2,3] && (i % 2 == 0)\nimport IO;\nif (i <- [1,2,3] && (i % 2 == 0))\n  println("<i> % 2 == 0");\nfor (i <- [1,2,3,4] && (i % 2 == 0))\n  println("<i> % 2 == 0");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The backtracking ",(0,r.kt)("inlineCode",{parentName:"li"},"&&")," allows one to express searching for a computational solution in concise manner.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Side effects to global variables or IO in the context of a backtracking ",(0,r.kt)("inlineCode",{parentName:"li"},"&&")," can lead to more effects than you\nbargained for.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nint i = 0;\nbool incr() { i += 1; return true; }\nfor (int j <- [1,2,3] && incr() && (i % 2 == 0))\n  println("once true for <j>");\ni;\n')),(0,r.kt)("h5",{id:"boolean-any"},"Boolean Any"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Any combination of argument values is true."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"any ( Exp1, Exp2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"any ( Exp1, Exp2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," when at least one combination of values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"i")," is true."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"any(int n <- [1 .. 10], n % 2 == 0);\n")),(0,r.kt)("h5",{id:"boolean-equivalence"},"Boolean Equivalence"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"equivalence")," operator on Boolean values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0\u21d2 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0\u21d2 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"equivalence")," operator on Boolean values defined as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0\u21d2 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))))),(0,r.kt)("p",null,"Boolean operators have ",(0,r.kt)("em",{parentName:"p"},"short circuit")," semantics: only those operands are evaluated that are needed to compute the\nresult. However, in the case of the ",(0,r.kt)("inlineCode",{parentName:"p"},"\u21d0\u21d2")," operator both operands have to be evaluated to determine the result."),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"\u21d0\u21d2")," operator backtracks over its arguments until it finds an evaluation that is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", unless there is\nnone. Variable bindings that are the effect of matching operators in its arguments are not visible outside the scope of\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"\u21d0\u21d2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\nfalse <==> false;\nfalse <==> true;\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"We should add a more meaningful example of backtracking over \u21d0\u21d2 than this old one: (i \u2190 ","[","1,2","]",") \u21d0\u21d2 (j \u2190 ","[","1,2,3","]",");\nfor i \u2190 ","[","1,2","]",") \u21d0\u21d2 (j \u2190 ","[","1,2,3","]","i \u2190 ","[","1,2","]",") \u21d0\u21d2 (j \u2190 ","[","1,2,3","]",' println("true',"!",'"); (i \u2190 ',"[","1,2","]"," && (i % 2 == 0)) \u21d0\u21d2\n(j \u2190 ","[","1,2,3","]"," && (j % 3 == 0)) for i \u2190 ","[","1,2","]"," && (i % 2 == 0i \u2190 ","[","1,2","]"," && (i % 2 == 0 \u21d0\u21d2 (j \u2190 ","[","1,2,3","]",' && (j % 3\n== 0))) println("true',"!",'");')),(0,r.kt)("h5",{id:"boolean-ifdefinedelse"},"Boolean IfDefinedElse"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Test whether expression has a defined value, otherwise provide alternative."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 ? Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 ? Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2 <: T1"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"If no exception is generated during the evaluation of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 ? Exp2")," is the value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". Otherwise, it is the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,"Also see ",(0,r.kt)("a",{parentName:"p",href:"#boolean-isDefined"},"???")," and ",(0,r.kt)("a",{parentName:"p",href:"#assignment"},"Assignment"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"This test can, for instance, be used to handle the case that a certain key value is not in a map:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T = ("a" : 1, "b" : 2);\n')),(0,r.kt)("p",null,"Trying to access the key ",(0,r.kt)("inlineCode",{parentName:"p"},'"c"')," will result in an error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T["c"];\n')),(0,r.kt)("p",null,"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," operator, we can write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T["c"] ? 0;\n')),(0,r.kt)("p",null,"This is very useful, if we want to modify the associated value, but are not sure whether it exists:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T["c"] ? 0 += 1;\n')),(0,r.kt)("p",null,"Another example using a list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [10, 20, 30];\nL[4] ? 0;\n")),(0,r.kt)("p",null,"It is, however, not possible to assign to index positions outside the list."),(0,r.kt)("h5",{id:"boolean-implication"},"Boolean Implication"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"implication")," operator on Boolean values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 =\u21d2 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 =\u21d2 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"implication")," operator on Boolean values defined as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 =\u21d2 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))))),(0,r.kt)("p",null,"Boolean operators have ",(0,r.kt)("em",{parentName:"p"},"short circuit")," semantics: only those operands are evaluated that are needed to compute the\nresult. In the case of the ",(0,r.kt)("inlineCode",{parentName:"p"},"=\u21d2")," operator, the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp1")," evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp2")," is\nevaluated to determine the result."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"false ==> true;\n")),(0,r.kt)("h5",{id:"boolean-isdefined"},"Boolean IsDefined"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Test whether the value of an expression is defined."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp ?")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp ?")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"If no exception is generated during the evaluation of ",(0,r.kt)("em",{parentName:"p"},"Exp"),", the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),". Otherwise, it is ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T = ("a" : 1, "b" : 2);\nT["b"]?\nT["c"]?\nL = [10, 20, 30];\nL[1]?\nL[5]?\n')),(0,r.kt)("h5",{id:"boolean-match"},"Boolean Match"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Match a pattern against an expression."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Pat := Exp")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Pat")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Pat := Exp")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#patterns"},"Patterns")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#pattern-Matching"},"???")," for an introduction to pattern matching and ",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns")," for a complete\ndescription."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"123 := 456;\n[10, *n, 50] := [10, 20, 30, 40, 50];\n{10, *int n, 50} := {50, 40, 30, 30, 10};\n")),(0,r.kt)("h5",{id:"boolean-negation"},"Boolean Negation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"not")," operator on Boolean values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"! Exp")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"! Exp")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"not")," operator on Boolean values defined as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"! Exp")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"!true;\n")),(0,r.kt)("h5",{id:"boolean-nomatch"},"Boolean NoMatch"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Negated ","[","Boolean Match","]"," operator."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Pat !:= Exp")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Pat")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Pat !:= Exp")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"[","Patterns","]"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#pattern-Matching"},"???")," for an introduction to pattern matching and ",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns")," for a complete\ndescription."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"123 !:= 456;\n[10, *n, 50] !:= [10, 20, 30, 40];\n{10, *n, 50} !:= {40, 30, 30, 10};\n")),(0,r.kt)("h5",{id:"boolean-or"},"Boolean Or"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"or")," operator on Boolean values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 || Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \\|\\| Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"or")," operator on Boolean values defined as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \\|\\| Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false"))))),(0,r.kt)("p",null,"Boolean operators have ",(0,r.kt)("em",{parentName:"p"},"short circuit")," semantics: only those operands are evaluated that are needed to compute the\nresult. In the case of the ",(0,r.kt)("inlineCode",{parentName:"p"},"||")," operator, the result is ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp1")," evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp2")," is\nevaluated to determine the result."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"||")," will backtrack over its argument expressions until it can find an evaluation that is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", unless there\nis none."),(0,r.kt)("p",null,"Variable assignments as a result of matching or generator expressions under a ",(0,r.kt)("inlineCode",{parentName:"p"},"||")," are visible outside the context of\nthe operator, but only if the context is conditional, such as an if-then-else or a for loop. Note that it is statically\nrequired that both sides of an ",(0,r.kt)("inlineCode",{parentName:"p"},"||")," introduce the same variable names of the same type."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nfalse || true;\n(i <- [1,2,3,4] && i % 2 == 0) || false\nfor ((i <- [1,2,3,4] && i % 2 == 0) || false)\n  println("true for <i>");\n')),(0,r.kt)("h3",{id:"constructor"},"Constructor"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Constructors create values for user-defined datatypes (Algebraic Datatypes)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Name ( Exp1, Exp2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Name ( Exp1, Exp2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on ADT declaration")))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"In ordinary programming languages record types or classes exist to introduce a new type name for a collection of\nrelated, named, values and to provide access to the elements of such a collection through their name."),(0,r.kt)("p",null,"In Rascal, algebraic data types provide this facility. They have to be declared, see ",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data\nType"),", and then values can be created using calls to the declared constructor\nfunctions. The constructor ",(0,r.kt)("em",{parentName:"p"},"Name")," should correspond (regarding name, arity and argument types) to one of the\nalternatives in the ADT declaration."),(0,r.kt)("p",null,"First, the actual parameter expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"i")," are evaluated resulting in values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"i"),". Next, a\ndata value is constructed in accordance with the declared data type using the values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"i")," as arguments for\nthe constructor. This data value is used as value of the constructor. Constructors are functions that can be used in all\ncontexts where functions can be used."),(0,r.kt)("p",null,"Observe that the syntax of a constructor is identical to the syntax of an function ",(0,r.kt)("a",{parentName:"p",href:"#call"},"Call"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"First, define a datatype ",(0,r.kt)("inlineCode",{parentName:"p"},"WF")," for word frequencies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"data WF = wf(str word, int freq);\n")),(0,r.kt)("p",null,"Then construct a new ",(0,r.kt)("inlineCode",{parentName:"p"},"WF")," value by calling the constructor ",(0,r.kt)("inlineCode",{parentName:"p"},"wf")," with appropriate arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'wf("Rascal", 10000);\n')),(0,r.kt)("h3",{id:"datetime"},"DateTime"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Date and time values."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"$")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," ",(0,r.kt)("inlineCode",{parentName:"p"},"$"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"$")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Time")," ",(0,r.kt)("inlineCode",{parentName:"p"},"$"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"$")," ",(0,r.kt)("inlineCode",{parentName:"p"},"DateTime")," ",(0,r.kt)("inlineCode",{parentName:"p"},"$")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"datetime")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Date, time, and datetime values are represented by the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," type. ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," literals start with a ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," and are\nmade up of either a date, given in year, month, day of month order; a time, preceded by ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and given in hour, minute,\nsecond, millisecond, (optional) timezone offset order; or a datetime, which is a date and a time, in the orders given\nabove, and separated by a ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,r.kt)("p",null,"The following fields provide access to information about the value, but cannot be set:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"isDate"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value is a date value, ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if the value is a datetime or time value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"isTime"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value is a time value, ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if the value is a date or datetime value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"isDateTime"),": returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value is a datetime value, ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if the value is a date or time value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"justTime"),": returns the date component of a date or datetime value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"justDate"),": returns the time component of a time or datetime value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"century"),": returns the century component of a year for date or datetime values."))),(0,r.kt)("p",null,"The following fields provide access to the individual components of date, time and datetime values, and can be accessed\nusing ",(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"DateTime Field Selection")," and be assigned using ",(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"DateTime Field\nSelection"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"year"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"month"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"day"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"hour"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"minute"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"second"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"millisecond"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"timezoneOffsetHours"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"timezoneOffsetMinutes")))),(0,r.kt)("p",null,"Not all fields are available on all values as indicated by the following table:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"date")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"datetime")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"time")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"year")),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"month")),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"day")),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"hour")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"minute")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"second")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"millisecond")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timezoneOffsetHours")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"timezoneOffsetMinutes")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"x"),(0,r.kt)("td",{parentName:"tr",align:null},"x")))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"isDate"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"isTime"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"isDateTime")," fields can be checked in advance to determine what kind of value is stored in a\nvariable of type ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime"),"."),(0,r.kt)("p",null,"The following operators are defined for DateTime:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"DateTime Equal"),": Equality on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"DateTime Field Selection"),": Select a field from a datetime value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"DateTime GreaterThan"),": Greater than operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"DateTime GreaterThanOrEqual"),": Greater than or equal operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"DateTime LessThan"),": Less than operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"DateTime LessThanOrEqual"),": Less than or equal operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"DateTime NotEqual"),": Not equal operator on datetime values."))),(0,r.kt)("p",null,"The following functions are defined for DateTime:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"DateTime Equal"),": Equality on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"DateTime Field Selection"),": Select a field from a datetime value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"DateTime GreaterThan"),": Greater than operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"DateTime GreaterThanOrEqual"),": Greater than or equal operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"DateTime LessThan"),": Less than operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"DateTime LessThanOrEqual"),": Less than or equal operator on datetime values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"DateTime NotEqual"),": Not equal operator on datetime values."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#datetime"},"library functions")," available for DateTime."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Examples of ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," values are:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2010-07-15$\n$T07:15:23.123+0100$;\n")),(0,r.kt)("p",null,"Now introduce a ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value and assign it to ",(0,r.kt)("inlineCode",{parentName:"p"},"DT"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"DT = $2010-07-15T09:15:23.123+03:00$;\n")),(0,r.kt)("p",null,"Here are examples of some ",(0,r.kt)("inlineCode",{parentName:"p"},"datatime")," fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"DT.isDateTime;\nDT.justDate;\nDT.justTime;\nDT.century;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"In normal parlance, the year 2010 is in the 21th century. The ",(0,r.kt)("inlineCode",{parentName:"p"},"century")," field, however, just returns the century\ncomponent of a given year, e.g., for 2010 this is 20."),(0,r.kt)("h5",{id:"datetime-equal"},"DateTime Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality on datetime values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are identical ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," values and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2010-07-15$ == $2010-07-15$;\n$2010-07-15$ == $2010-07-14$;\n")),(0,r.kt)("h5",{id:"datetime-field-selection"},"DateTime Field Selection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Select a field from a datetime value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp . Name")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp . Name")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"depends on field")))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Field selection applies to ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," values. ",(0,r.kt)("em",{parentName:"p"},"Name")," should be one of the supported fields listed in\n",(0,r.kt)("a",{parentName:"p",href:"#datetime"},"DateTime")," and returns the value of that field. Name stands for itself and is not evaluated."),(0,r.kt)("h5",{id:"datetime-greaterthan"},"DateTime GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than operator on datetime values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is later in time than the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2010-07-15$ > $2010-07-14$;\n$2011-07-15$ > $2010-07-15$;\n")),(0,r.kt)("h5",{id:"datetime-greaterthanorequal"},"DateTime GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than or equal operator on datetime values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is later in time than the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," or if both values are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2011-07-15$ >= $2010-07-15$;\n$2010-07-15$ >= $2010-07-14$;\n")),(0,r.kt)("h5",{id:"datetime-lessthan"},"DateTime LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than operator on datetime values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is earlier in time than the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of\n",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2010-07-14$ < $2010-07-15$;\n$2011-07-15$ < $2010-07-14$;\n")),(0,r.kt)("h5",{id:"datetime-lessthanorequal"},"DateTime LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than or equal operator on datetime values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is earlier in time than the ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," or if the values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2010-07-15$ <= $2010-07-15$;\n$2011-07-15$ <= $2010-07-14$;\n")),(0,r.kt)("h5",{id:"datetime-notequal"},"DateTime NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on datetime values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datetime")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are different ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime")," values and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"$2010-07-15$ != $2010-07-14$;\n$2010-07-15$ != $2010-07-15$;\n")),(0,r.kt)("h3",{id:"integer"},"Integer"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Integer values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,"sequence of digits of arbitrary length."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"int")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The integer values are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," and are written as usual. They can be ",(0,r.kt)("em",{parentName:"p"},"arbitrarily large"),"."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#number"},"Number")," for all operations and functions on integers, reals and numbers."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"12"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"0"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"-123456789")))),(0,r.kt)("h3",{id:"list"},"List"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"List values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[ Exp1, Exp2, \u2026\u200b ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"[ Exp1, Exp2, \u2026\u200b ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1, T2, \u2026\u200b )]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A list is an ordered sequence of values and has the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All elements have the same static type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The order of the elements matters.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A list may contain an element more than once."))),(0,r.kt)("p",null,"The type of a list has the form ",(0,r.kt)("inlineCode",{parentName:"p"},"list[T]"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an arbitrary type."),(0,r.kt)("p",null,"When a value or variable of type list occurs inside a list, that list value is inserted as list element. To achieve\n",(0,r.kt)("em",{parentName:"p"},"splicing")," of these elements, i.e., the insertion of the elements of the list value rather than the whole list, it has\nto be prefixed by the splice operator ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),"."),(0,r.kt)("p",null,"The following operators are provided on list:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#append"},"List Append"),": Append an element at the end of a list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"List Comprehension"),": A list comprehension generates a list value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"List Concatenation"),": Concatenate two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#difference"},"List Difference"),": The difference between two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"List Equal"),": Equality on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#insert"},"List Insert"),": add an element in front of a list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#intersection"},"List Intersection"),": Intersection of two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"List NotEqual"),": Not equal operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#product"},"List Product"),": Compute the product of two lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"List Slice"),": Retrieve a slice of a list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#splice"},"List Splice"),": Splice the elements of a list in an enclosing list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsublist"},"List StrictSubList"),": The strict sublist operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsuperlist"},"List StrictSuperList"),": The strict super list operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#sublist"},"List SubList"),": The sublist operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"List Subscription"),": Retrieve a list element via its index.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#superlist"},"List SuperList"),": The super list operator on lists.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#in"},"List in"),": Membership test on list elements.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notin"},"List notin"),": Negated membership test on lists."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#list"},"library functions")," available for List."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'[1, 2, 3];\n[<1,10>, <2,20>, <3,30>];\n[1, "b", 3];\n[<"a",10>, <"b",20>, <"c",30>];\n[["a", "b"], ["c", "d", "e"]];\n')),(0,r.kt)("p",null,"List splicing works as follows: by prefixing ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," by the splice operator, its elements are included as elements in the\nenclosing list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [1, 2, 3];\n[10, L, 20];\n[10, *L, 20];\n")),(0,r.kt)("h5",{id:"list-append"},"List Append"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Append an element at the end of a list"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The operator ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," appends an element at the end of a list. The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," is one of those ",(0,r.kt)("a",{parentName:"p",href:"#operators"},"Operators"),"\nwhich are overloaded. It can also mean ",(0,r.kt)("a",{parentName:"p",href:"#insert"},"List Insert")," or ",(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"List Concatenation")," for\nexample."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[] + 1;\n[1] + 2;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If both operands of ",(0,r.kt)("inlineCode",{parentName:"li"},"+")," are a list, then it acts as ",(0,r.kt)("a",{parentName:"li",href:"#concatenation"},"List Concatenation"))),(0,r.kt)("p",null,"This is concatenation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1] + [2]\n")),(0,r.kt)("p",null,"To append a list to a list, use extra brackets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1] + [[2]]\n")),(0,r.kt)("h5",{id:"list-comprehension"},"List Comprehension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A list comprehension generates a list value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[ Exp1, Exp2, \u2026\u200b | Gen1, Gen2, \u2026\u200b ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"[ Exp1, Exp2, \u2026\u200b \\| Gen1, Gen2, \u2026\u200b ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[ lub( T1, T2, \u2026\u200b ) ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A list comprehension consists of a number of contributing expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", \u2026\u200b and a\nnumber of generators ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"3"),", \u2026\u200b that are evaluated as described in\n",(0,r.kt)("a",{parentName:"p",href:"#comprehensions"},"Comprehensions"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Computing a list of squares of the numbers from 0 to 10 that are divisible by 3:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[n * n | int n <- [0 .. 10], n % 3 == 0];\n")),(0,r.kt)("p",null,"But we can also include the relevant ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," in the resulting list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[n, n * n | int n <- [0 .. 10], n % 3 == 0];\n")),(0,r.kt)("h5",{id:"list-concatenation"},"List Concatenation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Concatenate two lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 + Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator concatenates the elements of the two lists in order of appearance."),(0,r.kt)("p",null,"Note that the same operator is overloaded for ",(0,r.kt)("a",{parentName:"p",href:"#insert"},"List Insert")," and ",(0,r.kt)("a",{parentName:"p",href:"#append"},"List Append"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] + [4, 5, 6];\n[] + [1]\n[1] + []\n[1] + [2] + [3]\n")),(0,r.kt)("p",null,"And overloaded usage for insert and append looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"1 + []\n[] + 1\n")),(0,r.kt)("h5",{id:"list-difference"},"List Difference"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The difference between two lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 - Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 - Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1,T2)]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"If both ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," have a list as value, the result is the difference of these two list\nvalues. If ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," does not have a list as value, it is first converted to a list before the difference is\ncomputed. The difference is computed by taking the successive elements of the second list and removing the first\noccurrence of that element in the first list."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3, 4] - [1, 2, 3];\n[1, 2, 3, 4] - [3];\n[1, 2, 3, 4] - 3;\n[1, 2, 3, 4] - [5, 6, 7];\n[1, 2, 3, 1, 2, 3] - [1];\n[1, 2, 3, 1, 2, 3] - [1, 2];\n")),(0,r.kt)("h5",{id:"list-equal"},"List Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are equal lists and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] == [1, 2, 3];\n[1, 2, 3] == [3, 2, 1];\n")),(0,r.kt)("h5",{id:"list-insert"},"List Insert"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"add an element in front of a list"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator can insert an element in front of a list. Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," is one of the\n",(0,r.kt)("a",{parentName:"p",href:"#operators"},"Operators")," that is overloaded, it is also ",(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"List Concatenation")," and ",(0,r.kt)("a",{parentName:"p",href:"#append"},"List\nAppend")," for example."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"1 + []\n1 + [2]\n1 + [2,3]\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If the first operand before the ",(0,r.kt)("inlineCode",{parentName:"li"},"+")," is a list, ",(0,r.kt)("inlineCode",{parentName:"li"},"+")," acts as ",(0,r.kt)("a",{parentName:"li",href:"#concatenation"},"List Concatenation")," and not as\n",(0,r.kt)("a",{parentName:"li",href:"#insert"},"List Insert"))),(0,r.kt)("p",null,"This is concatenation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1] + [2]\n")),(0,r.kt)("p",null,"To insert a list as an element, use extra brackets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[[1]] + [2]\n")),(0,r.kt)("h5",{id:"list-intersection"},"List Intersection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Intersection of two lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 & Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 & Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the intersection of the two list values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", i.e., the list value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," with all elements removed that do not occur in the list value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3, 4, 5] & [4, 5, 6];\n")),(0,r.kt)("h5",{id:"list-notequal"},"List NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are unequal lists and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] != [3, 2, 1];\n[1, 2, 3] != [1, 2, 3];\n")),(0,r.kt)("h5",{id:"list-product"},"List Product"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Compute the product of two lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 * Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 * Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[tuple[T1,T2]]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields a list of tuples resulting from the product of the values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),". It contains\na tuple for each combination of values from both arguments."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] * [4, 5, 6];\n")),(0,r.kt)("p",null,"Here is a concise way to create a deck of cards:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'["clubs", "hearts", "diamonds", "spades"] * [1 .. 13];\n')),(0,r.kt)("h5",{id:"list-slice"},"List Slice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a slice of a list."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 .. Exp4]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 , Exp3 .. Exp4]")))),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," are optional."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp3")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp4")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 [ Exp2 .. Exp4 ]")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 [ Exp2 , Exp3 .. Exp4]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"List slicing uses the integer values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," to determine the ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," (",(0,r.kt)("strong",{parentName:"p"},"inclusive"),")\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," (",(0,r.kt)("strong",{parentName:"p"},"exclusive"),") of a slice from the list value ",(0,r.kt)("em",{parentName:"p"},"L")," of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". Negative indices count from the end\nof the list backwards. Using the second form, an extra index ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"3")," is given that determines the index of the\nsecond element in the slice and establishes the ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," between successive elements in the slice. The default ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," is"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"end")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"li"},"begin"),", the slice is constructed backwards.")),(0,r.kt)("p",null,"Let ",(0,r.kt)("inlineCode",{parentName:"p"},"Len")," be the length of ",(0,r.kt)("em",{parentName:"p"},"L")," and let ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"3")," and ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"4")," be the respective values of\nthe expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," when they are present."),(0,r.kt)("p",null,"The slice parameters ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," are determined as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2"))," is absent, then ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = 0"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("em",{parentName:"p"},"N",(0,r.kt)("sub",null,"2"))," ",">","= 0 then ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = N2")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = N2 + Len"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4"))," is absent, then ",(0,r.kt)("inlineCode",{parentName:"p"},"end = Len"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("em",{parentName:"p"},"N",(0,r.kt)("sub",null,"4"))," ",">","= 0, then ",(0,r.kt)("inlineCode",{parentName:"p"},"end = N4")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"end = N4 + Len"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"3")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"3"))," is absent, then if ",(0,r.kt)("inlineCode",{parentName:"p"},"begin < end")," then ",(0,r.kt)("inlineCode",{parentName:"p"},"step = 1")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"step = -1"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("inlineCode",{parentName:"p"},"begin < end"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"step = N3 - begin")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"step = begin - N3"),"."))))),(0,r.kt)("p",null,"Now, the constraints ",(0,r.kt)("inlineCode",{parentName:"p"},"0 \u21d0 begin < Len")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"0 < end < Len")," should hold, otherwise the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBounds")," is\nthrown."),(0,r.kt)("p",null,"The slice consists of the elements ",(0,r.kt)("inlineCode",{parentName:"p"},"L[begin]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"L[begin+step]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"L[end - step]"),". When ",(0,r.kt)("inlineCode",{parentName:"p"},"begin >= end"),", the elements are\nlisted in reverse order."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the list ",(0,r.kt)("inlineCode",{parentName:"p"},"L = [0, 10, 20, 30, 40, 50, 60, 70, 80];")," as running example."),(0,r.kt)("p",null,"Here is a view on ",(0,r.kt)("em",{parentName:"p"},"L")," that will help to correlate positive and negative indices:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"i")),(0,r.kt)("th",{parentName:"tr",align:null},"0"),(0,r.kt)("th",{parentName:"tr",align:null},"1"),(0,r.kt)("th",{parentName:"tr",align:null},"2"),(0,r.kt)("th",{parentName:"tr",align:null},"3"),(0,r.kt)("th",{parentName:"tr",align:null},"4"),(0,r.kt)("th",{parentName:"tr",align:null},"5"),(0,r.kt)("th",{parentName:"tr",align:null},"6"),(0,r.kt)("th",{parentName:"tr",align:null},"7"),(0,r.kt)("th",{parentName:"tr",align:null},"8"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[i]")),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"20"),(0,r.kt)("td",{parentName:"tr",align:null},"30"),(0,r.kt)("td",{parentName:"tr",align:null},"40"),(0,r.kt)("td",{parentName:"tr",align:null},"50"),(0,r.kt)("td",{parentName:"tr",align:null},"60"),(0,r.kt)("td",{parentName:"tr",align:null},"70"),(0,r.kt)("td",{parentName:"tr",align:null},"80")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-i")),(0,r.kt)("td",{parentName:"tr",align:null},"-","9"),(0,r.kt)("td",{parentName:"tr",align:null},"-","8"),(0,r.kt)("td",{parentName:"tr",align:null},"-","7"),(0,r.kt)("td",{parentName:"tr",align:null},"-","6"),(0,r.kt)("td",{parentName:"tr",align:null},"-","5"),(0,r.kt)("td",{parentName:"tr",align:null},"-","4"),(0,r.kt)("td",{parentName:"tr",align:null},"-","3"),(0,r.kt)("td",{parentName:"tr",align:null},"-","2"),(0,r.kt)("td",{parentName:"tr",align:null},"-","1")))),(0,r.kt)("p",null,"Some common use cases (with ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," \u21d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),"):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Slice"),(0,r.kt)("th",{parentName:"tr",align:null},"Means:"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[begin..end]")),(0,r.kt)("td",{parentName:"tr",align:null},"elements with indices ",(0,r.kt)("inlineCode",{parentName:"td"},"begin")," through ",(0,r.kt)("inlineCode",{parentName:"td"},"end-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[begin..]")),(0,r.kt)("td",{parentName:"tr",align:null},"elements with indices ",(0,r.kt)("inlineCode",{parentName:"td"},"begin")," through the rest of the list")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[..end]")),(0,r.kt)("td",{parentName:"tr",align:null},"elements with indices from the beginning through ",(0,r.kt)("inlineCode",{parentName:"td"},"end-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[..]")),(0,r.kt)("td",{parentName:"tr",align:null},"the whole list")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[-1]")),(0,r.kt)("td",{parentName:"tr",align:null},"last element of the list")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[-2..]")),(0,r.kt)("td",{parentName:"tr",align:null},"the last two elements of the list")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"L[..-2]")),(0,r.kt)("td",{parentName:"tr",align:null},"all elements except the last two.")))),(0,r.kt)("p",null,"Let\u2019s put this into practice now."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [0, 10, 20, 30, 40, 50, 60, 70, 80];\n")),(0,r.kt)("p",null,"Slices with begin \\< end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[1..3];\nL[1..];       // empty end => end of list\nL[..3];       // empty begin => first element of list\nL[..];        // both empty => whole list\n")),(0,r.kt)("p",null,"Slices with begin ",">","= end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[3..1];      // slice contains elements with indices 3 and 2 (in that order)\nL[3..3];      // empty slice when begin == end\n")),(0,r.kt)("p",null,"Slices with negative begin or end:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[2..-2];     // equivalent to L[2..7]\nL[2..7];\nL[-4..-2];    // equivalent to L[5..7]\nL[5..7];\n")),(0,r.kt)("p",null,"Slices with an explicit second index:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[1,3..6];\nL[5,3..];\n")),(0,r.kt)("p",null,"Explore error cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[..10];\nL[1..20];\n")),(0,r.kt)("h5",{id:"list-splice"},"List Splice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Splice the elements of a list in an enclosing list."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Expn")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"[Exp1, \u2026\u200b, Exp, \u2026\u200b, Expn]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Tn")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[lub(T1, \u2026\u200b, T, \u2026\u200b,Tn)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The operator ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," splices the elements of a list in an enclosing list."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the following list in which the list ",(0,r.kt)("inlineCode",{parentName:"p"},"[10, 20, 30]")," occurs as list element. It has as type ",(0,r.kt)("inlineCode",{parentName:"p"},"list[value]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, [10, 20, 30], 3, 4];\n")),(0,r.kt)("p",null,"The effect of splicing the same list element in the enclosing list gives a flat list of type ",(0,r.kt)("inlineCode",{parentName:"p"},"list[int]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, *[10, 20, 30], 3, 4];\n")),(0,r.kt)("p",null,"The same example can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [10, 20, 30];\n[1, 2, *L, 3, 4];\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Benefits.")),(0,r.kt)("p",null,"in which nested lists are handled."),(0,r.kt)("h5",{id:"list-strictsublist"},"List StrictSubList"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The strict sublist operator on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is a strict sublist of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] < [1, 2, 3, 4];\n[1, 2, 3, 4] < [1, 2, 3, 4];\n[1, 3, 5] < [1, 2, 3, 4, 5]\n")),(0,r.kt)("h5",{id:"list-strictsuperlist"},"List StrictSuperList"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The strict super list operator on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is a strict sublist of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3, 4] > [1, 2, 3];\n[1, 2, 3, 4] > [1, 2, 3, 4];\n[1, 2, 3, 4] > [1, 2, 3];\n[1, 2, 3, 4, 5] > [1, 3, 5]\n")),(0,r.kt)("h5",{id:"list-sublist"},"List SubList"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The sublist operator on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is equal to or a sublist of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] <= [1, 2, 3, 4];\n[1, 2, 3] <= [1, 2, 3];\n[1, 3, 5] <= [1, 2, 3, 4, 5];\n")),(0,r.kt)("h5",{id:"list-subscription"},"List Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a list element via its index."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"List subscription uses the integer value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," as index in the list value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". The value\nof ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," should be greater or equal 0 and less than the number of elements in the list. If this is not the\ncase, the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBounds")," is thrown."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce a list, assign it to L and retrieve the element with index 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [10, 20, 30];\nL[1];\n")),(0,r.kt)("p",null,"Explore an error case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[5];\n")),(0,r.kt)("h5",{id:"list-superlist"},"List SuperList"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The super list operator on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is equal to or a sublist of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3, 4] >= [1, 2, 3];\n[1, 2, 3, 4] >= [1, 2, 3, 4];\n[1, 2, 3, 4] >= [1, 2, 3];\n[1, 2, 3, 4, 5] >= [1, 3, 5]\n")),(0,r.kt)("h5",{id:"list-in"},"List in"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Membership test on list elements."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 in Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 in Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")," \\<: ",(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," occurs as element in the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise. The type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should be compatible with the element type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"2 in [1, 2, 3];\n4 in [1, 2, 3];\n")),(0,r.kt)("h5",{id:"list-notin"},"List notin"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Negated membership test on lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 notin Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 notin Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")," \\<: ",(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," does not occur as element in the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise. The type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should be compatible with the element type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"4 notin [1, 2, 3];\n2 notin [1, 2, 3];\n")),(0,r.kt)("h3",{id:"listrelation"},"ListRelation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"ListRelation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[ < Exp11, Exp12, \u2026\u200b > , < Exp21, Exp22, \u2026\u200b > , \u2026\u200b ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp11")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp12")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"{ < Exp11, Exp12, \u2026\u200b > , \u2026\u200b }")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A list relation is a list of elements with the following property:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All elements have the same static tuple type.")),(0,r.kt)("p",null,"ListRelations are thus nothing more than lists of tuples, but since they are used so often we provide a shorthand\nnotation for them. ListRelations are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"lrel[T1 L1, T2 L2, \u2026\u200b ]"),", where ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1"),",\n",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2"),", \u2026\u200b are arbitrary types and ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"2"),", \u2026\u200b are optional labels. It is a shorthand\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"list[tuple[T1 L1, T2 L2, \u2026\u200b ]]"),"."),(0,r.kt)("p",null,"An n-ary list relation with m tuples is denoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"[< E11, E12, \u2026\u200b, E1n>,< E21, E22, \u2026\u200b, E2n>, \u2026\u200b, < Em1, Em2, \u2026\u200b,\nEmn>]"),", where the ",(0,r.kt)("em",{parentName:"p"},"E"),(0,r.kt)("sub",null,"ij")," are expressions that yield the desired element type ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"i"),"."),(0,r.kt)("p",null,"Since list relations are a form of list all operations (see ",(0,r.kt)("a",{parentName:"p",href:"#list"},"List"),") and functions (see\n",(0,r.kt)("a",{parentName:"p",href:"#list"},"???"),") are also applicable to relations."),(0,r.kt)("p",null,"The following additional operators are provided for list relations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#cartesianproduct"},"ListRelation CartesianProduct"),": Cartesian product of two list relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#composition"},"ListRelation Composition"),": Composition of two list relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"ListRelation FieldSelection"),": Select a field (column) from a list relation value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#join"},"ListRelation Join"),": Join two list relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reflexivetransitiveclosure"},"ListRelation Reflexive Transitive Closure"),": The reflexive transitive\nclosure of a binary list relation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"ListRelation Subscription"),": Indexing of a list relation via tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#transitiveclosure"},"ListRelation Transitive Closure"),": Transitive closure on binary list relation\nvalues."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#listrelation"},"library functions")," available for ListRelation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[<1,10>, <2,20>, <3,30>]\n")),(0,r.kt)("p",null,"instead of lrel","[","int,int","]"," we can also give ",(0,r.kt)("inlineCode",{parentName:"p"},"list[tuple[int,int]]")," as type of the above expression remember that these\ntypes are interchangeable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'[<"a",10>, <"b",20>, <"c",30>]\n[<"a", 1, "b">, <"c", 2, "d">]\n')),(0,r.kt)("h5",{id:"listrelation-cartesianproduct"},"ListRelation CartesianProduct"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Cartesian product of two list relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 * Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 * Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns a binary relation that is the ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Cartesian_product"},"Cartesian product")," of two lists."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 2, 3] * [9];\n[1, 2, 3] * [10, 11];\n")),(0,r.kt)("h5",{id:"listrelation-composition"},"ListRelation Composition"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Composition of two list relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 o Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 o Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T2, T3]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T3]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the composition of two binary list relations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[<1,10>, <2,20>, <3,15>] o [<10,100>, <20,200>];\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"We use the letter ",(0,r.kt)("inlineCode",{parentName:"p"},"o")," as operator and this may conflict other defined names."),(0,r.kt)("h5",{id:"listrelation-fieldselection"},"ListRelation FieldSelection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Select a field (column) from a list relation value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp . Name")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp . Name"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1 L1, T2 L2, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Exp")," should evaluate to a list relation that has an ",(0,r.kt)("em",{parentName:"p"},"i"),"-th field label ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"i")," that is identical to ",(0,r.kt)("em",{parentName:"p"},"Name"),".\nReturn a list with all values of that field. ",(0,r.kt)("em",{parentName:"p"},"Name")," stands for itself and is not evaluated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'lrel[str street, int nm] R = [<"abc", 1>, <"abc", 2>, <"def", 4>, <"def", 5>];\nR.street;\n')),(0,r.kt)("h5",{id:"listrelation-join"},"ListRelation Join"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Join two list relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 join Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 join Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[ T11, T12, T13, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[ T21, T22, T23, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[ T11, T12, T13, \u2026\u200b, T21, T22, T23, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"ListRelation resulting from the natural join of the list relation values of the two arguments. This list relation\ncontains tuples that are the result from concatenating the elements from both arguments."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[<1,2>, <10,20>] join [<2,3>];\n[<1,2>] join [3, 4];\n[<1,2>, <10,20>] join [<2,3>, <20,30>];\n")),(0,r.kt)("h5",{id:"listrelation-reflexive-transitive-closure"},"ListRelation Reflexive Transitive Closure"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The reflexive transitive closure of a binary list relation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp *")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp *")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Reflexive transitive closure is defined by repeated composition of a list relation. If we define for a given list\nrelation R:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"0")," = identity relation = ",(0,r.kt)("inlineCode",{parentName:"p"},"[<a, a>, <b, b> | <a, b> \u2190 R]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"1")," = R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"2")," = R o R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"3")," = R o R",(0,r.kt)("sup",null,"2"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2026\u200b"))),(0,r.kt)("p",null,"then the reflexive transitive closure R","*"," can be defined in two ways: (also see ",(0,r.kt)("a",{parentName:"p",href:"#transitiveclosure"},"ListRelation Transitive\nClosure"),"):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R","*"," = R",(0,r.kt)("sup",null,"0")," + R",(0,r.kt)("sup",null,"1")," + R",(0,r.kt)("sup",null,"2")," + R",(0,r.kt)("sup",null,"3")," + \u2026\u200b")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R","*"," = R",(0,r.kt)("sup",null,"0")," + R+"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[<1,2>, <2,3>, <3,4>]*;\n")),(0,r.kt)("h5",{id:"listrelation-subscription"},"ListRelation Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Indexing of a list relation via tuple values."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Exp0 [ Exp1, Exp2, \u2026\u200b Expn]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Exp0 [ Exp1]")))),(0,r.kt)("h6",{id:"variant-1-1"},"Variant 1"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp0")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp0 [ Exp1, Exp2, \u2026\u200b ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2, \u2026\u200b Tm]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[Tn, Tn+1, \u2026\u200b Tm]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("h6",{id:"variant-2-1"},"Variant 2"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp0")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp0 [ Exp1 ]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2, \u2026\u200b Tm]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[T1]"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"ListRelation resulting from subscription of a ListRelation ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"0"),"."),(0,r.kt)("h6",{id:"variant-1-2"},"Variant 1"),(0,r.kt)("p",null,"Subscription with the index values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", \u2026\u200b. The result is a ListRelation with all\ntuples that have these index values as first elements with the index values removed from the tuple. If the resulting\ntuple has only a single element, a list is returned instead of a relation. A wildcard ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," as index value matches all\npossible values at that index position."),(0,r.kt)("h6",{id:"variant-2-2"},"Variant 2"),(0,r.kt)("p",null,"Subscription with a set of the index values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". The result is a ListRelation with all tuples that have\nthese index values as first element with the index values removed from the tuple."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"R = [<1,10>, <2,20>, <1,11>, <3,30>, <2,21>];\nR[1];\nR[{1}];\nR[{1, 2}];\nRR = [<1,10,100>,<1,11,101>,<2,20,200>,<2,22,202>,\n              <3,30,300>];\nRR[1];\nRR[1,_];\n")),(0,r.kt)("p",null,"Introduce a relation with economic data and assign it to ",(0,r.kt)("inlineCode",{parentName:"p"},"GDP"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'lrel[str country, int year, int amount] GDP =\n[<"US", 2008, 14264600>, <"EU", 2008, 18394115>,\n <"Japan", 2008, 4923761>, <"US", 2007, 13811200>,\n <"EU", 2007, 13811200>, <"Japan", 2007, 4376705>];\n')),(0,r.kt)("p",null,"and then retrieve the information for the index ",(0,r.kt)("inlineCode",{parentName:"p"},'"Japan"'),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'GDP["Japan"];\n')),(0,r.kt)("p",null,"or rather for the indices ",(0,r.kt)("inlineCode",{parentName:"p"},'"Japan"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},"2008"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'GDP["Japan", 2008];\n')),(0,r.kt)("h5",{id:"listrelation-transitive-closure"},"ListRelation Transitive Closure"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Transitive closure on binary list relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp +")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp +")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lrel[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the transitive closure of a binary listrelation. Transitive closure is defined by repeated composition of a\nrelation. If we define for a given relation R:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"1")," = R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"2")," = R o R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"3")," = R o R",(0,r.kt)("sup",null,"2"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2026\u200b"))),(0,r.kt)("p",null,"then the transitive closure R+ can be defined as"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"R+ = R",(0,r.kt)("sup",null,"1")," + R",(0,r.kt)("sup",null,"2")," + R",(0,r.kt)("sup",null,"3")," + \u2026\u200b")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[<1,2>, <2,3>, <3,4>]+;\n")),(0,r.kt)("h3",{id:"location"},"Location"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"(Source code) location values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"| Uri | ( O, L, < BL, BC > , < EL,EC > )")," where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Uri")," is an arbitrary Uniform Resource Identifier (URI).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"O")," and ",(0,r.kt)("em",{parentName:"p"},"L")," are integer expressions giving the offset of this location to the begin of file, respectively, its\nlength.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"BL")," and ",(0,r.kt)("em",{parentName:"p"},"BC")," are integers expressions giving the begin line and begin column.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"EL")," and ",(0,r.kt)("em",{parentName:"p"},"EC")," are integers expressions giving the end line and end column."))),(0,r.kt)("p",null,"The part following the second pipe symbol (",(0,r.kt)("inlineCode",{parentName:"p"},"|"),") is optional."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"loc")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Location values are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"loc")," and serve the following purposes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Providing a uniform mechanism for accessing local or remote files. This is used in all IO-related library functions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the optional part is present they serve as text coordinates in a specific local or remote source file. This is\nvery handy to associate a source code location which extracted facts."))),(0,r.kt)("p",null,"URIs are explained in ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Uniform_Resource_Identifier"},"Uniform Resource Identifier"),". From\ntheir original definition in RFC3986 we cite the following useful overview of an URI:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"         foo://example.com:8042/over/there?name=ferret#nose\n         \\_/   \\______________/\\_________/ \\_________/ \\__/\n          |           |            |            |        |\n       scheme     authority       path        query   fragment\n          |   _____________________|__\n         / \\ /                        \\\n         urn:example:animal:ferret:nose\n")),(0,r.kt)("p",null,"The elements of a location value can be accessed and modified using the standard mechanism of field selection and field\nassignment. The corresponding field names are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"top"),": the URI of the location without precise positioning information (offset, length, begin, end).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"uri"),": the URI of the location as a string. Also subfields of the URI can be accessed:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scheme"),": the scheme (or protocol) to be used;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"authority"),": the domain where the data are located, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"host"),": the host where the URI is hosted (part of authority), as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"port"),": port on host (part of authority), as a ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"path"),": path name of file on host, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"extension"),": file name extension, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"query"),": query data, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"fragment"),": the fragment name following the path name and query data, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"user"),": user info (only present in schemes like mailto), as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"parent")," : removes the last segment from the path component, if any, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"loc"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"file")," : the last segment of the path, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ls")," : the contents of a directory, if the loc is a directory, as a ",(0,r.kt)("inlineCode",{parentName:"p"},"list[loc]"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"offset"),": start of text area.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"length"),": length of text area.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"begin.line"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"begin.column"),": begin line and column of text area.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"end.line"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"end.column")," end line and column of text area."))),(0,r.kt)("p",null,"Supported protocols are:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Scheme name and pattern"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"http://host:_port_/path?query#fragment")),(0,r.kt)("td",{parentName:"tr",align:null},"access a remote file via the web.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"file:///path")),(0,r.kt)("td",{parentName:"tr",align:null},"access a local file on the file system.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"cwd:///path")),(0,r.kt)("td",{parentName:"tr",align:null},"access the current working directory (the directory from which Rascal was started).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"home:///path")),(0,r.kt)("td",{parentName:"tr",align:null},"access the home directory of the user.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"std:///path")),(0,r.kt)("td",{parentName:"tr",align:null},"access the Rascal standard library.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tmp:///path")),(0,r.kt)("td",{parentName:"tr",align:null},"access the temporay file directory.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"jar:_url_!/[entry]")),(0,r.kt)("td",{parentName:"tr",align:null},"access any entry in a zip file (or a jar)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rascal://qualifiedModulename")),(0,r.kt)("td",{parentName:"tr",align:null},"access the source code of a Rascal module name")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"project://projectName/projectRelativePath")),(0,r.kt)("td",{parentName:"tr",align:null},"access a project in the current instance of Eclipse.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bundleresource://bundleId/bundleRelativePath")),(0,r.kt)("td",{parentName:"tr",align:null},"access OSGI bundles. Only active in Eclipse context")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Locations with specific position information should always be generated automatically but for the curious here is an\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"|file:///home/paulk/pico.trm|(0,1,<2,3>,<4,5>)\n")),(0,r.kt)("p",null,"Note that this is equivalent to using the ",(0,r.kt)("inlineCode",{parentName:"p"},"home")," scheme:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"|home://pico.trm|(0,1,<2,3>,<4,5>)\n")),(0,r.kt)("p",null,"You could read a webpage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\nprintln(readFile(|http://www.example.org|))\n")),(0,r.kt)("p",null,"Addition on locations creates longer paths:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'x = |tmp://myTempDirectory|;\nx += "myTempFile.txt";\n')),(0,r.kt)("h5",{id:"location-addsegment"},"Location AddSegment"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Locations can be concatenated with strings to add segments to the path component"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Loc + Str")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Loc")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Str")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Loc + Str")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Adds a segment to the path component of a location. This concatenation introduces a path separator (",(0,r.kt)("inlineCode",{parentName:"p"},"/"),") automatically."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'|tmp:///myDir| + "myFile";\n')),(0,r.kt)("p",null,"To get the original back, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"parent")," field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'(|tmp:///myDir| + "myFile").parent\n')),(0,r.kt)("h5",{id:"location-equal"},"Location Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality operator on locations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("h5",{id:"location-fieldselection"},"Location FieldSelection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Field selection on locations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp . Name")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp . Name")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Depends on field")))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Field selection applies to locations. ",(0,r.kt)("em",{parentName:"p"},"Name")," should be one of the supported fields listed in\n",(0,r.kt)("a",{parentName:"p",href:"#location"},"Location")," and returns the value of that field. Name stands for itself and is not evaluated."),(0,r.kt)("h5",{id:"location-greaterthan"},"Location GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The greater than operator on location values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the location value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," strictly textually encloses the location value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("h5",{id:"location-greaterthanorequal"},"Location GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The greater than or equal operator on location values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the location value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," textually encloses the location value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and\n",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("h5",{id:"location-lessthan"},"Location LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The less than operator on location values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the location value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is strictly textually contained in the location value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("h5",{id:"location-lessthanorequal"},"Location LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The less than or equal operator on location values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the location value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is textually contained in the location value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("h5",{id:"notequal"},"NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The not equal operator on location values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"loc")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are not identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("h3",{id:"map"},"Map"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"( KeyExp1 : ValExp1, KeyExp2 : ValExp2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"KeyExp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"ValExp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"KeyExp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"ValExp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"( KeyExp1 : ValExp1, KeyExp2 : ValExp2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"TK1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"TV1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"TK2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"TV2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[lub(TK1, TK2, \u2026\u200b ) , lub(TV1, TV2, \u2026\u200b )]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A map is a set of key/value pairs and has the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Key and value may have different static types.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A key can only occur once."))),(0,r.kt)("p",null,"Maps resemble functions rather than relations in the sense that only a single value can be associated with each key."),(0,r.kt)("p",null,"The following functions are provided for maps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#composition"},"Map Composition"),": Composition of two map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Map Comprehension"),": A map comprehension generates a map value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#difference"},"Map Difference"),": The difference between two maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Map Equal"),": Equality operator on maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#intersection"},"Map Intersection"),": Intersection of two maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Map NotEqual"),": Not equal operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsubmap"},"Map StrictSubMap"),": Strict submap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsupermap"},"Map StrictSuperMap"),": Strict supermap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#submap"},"Map SubMap"),": Submap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Map Subscription"),": Retrieve a value by its key in map.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#supermap"},"Map SuperMap"),": Supermap operator on map values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#union"},"Map Union"),": Union of two maps.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#in"},"Map in"),": Membership test on the keys of a map.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notin"},"Map notin"),": Negated membership test on the keys of a map."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("pear" : 1, "apple" : 3, "banana" : 0);\n')),(0,r.kt)("h5",{id:"map-composition"},"Map Composition"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Composition of two map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 o Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 o Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[T2, T3]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[T1, T3]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the composition of two maps."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import Map;\n("one" : 1, "two" : 2) o (1 : 10, 2 : 20);\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"We use the letter ",(0,r.kt)("inlineCode",{parentName:"p"},"o")," as operator and this may conflict other defined names."),(0,r.kt)("h5",{id:"map-comprehension"},"Map Comprehension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A map comprehension generates a map value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"( Exp1 : Exp2 | Gen1, Gen2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"( Exp1 : Exp2 \\| Gen1, Gen2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A map comprehension consists of a number of two contributing expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," (for key values), and\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," (the values associated with those key values) and a number of generators ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"1"),",\n",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"3"),", \u2026\u200b that are evaluated as described in\n",(0,r.kt)("a",{parentName:"p",href:"#comprehensions"},"Comprehensions"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Introduce a map of ",(0,r.kt)("inlineCode",{parentName:"p"},"fruits"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'fruits = ("pear" : 1, "apple" : 3, "banana" : 0, "berry" : 25, "orange": 35);\nimport String;\n')),(0,r.kt)("p",null,"Use a map comprehension to filter fruits with a name of at most 5 characters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(fruit : fruits[fruit] | fruit <- fruits, size(fruit) <= 5);\n")),(0,r.kt)("p",null,"Use a map comprehension to filter fruits with an associated value larger than 10:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(fruit : fruits[fruit] | fruit <- fruits, fruits[fruit] > 10);\n")),(0,r.kt)("h5",{id:"map-difference"},"Map Difference"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The difference between two maps."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 - Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 - Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1, TV1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[lub(TK1,TK2),lub(TK1,TK2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The result is the difference of the two map values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", i.e. a map with all pairs\nin ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," that do have a key that does not occur in ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) - ("banana": 3, "apple": 4);\n')),(0,r.kt)("h5",{id:"map-equal"},"Map Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality operator on maps."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1,TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments contain the same key/value pairs, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) == ("pear": 2, "apple": 1);\n("apple": 1, "pear": 2) == ("apple": 1, "banana": 3)\n')),(0,r.kt)("h5",{id:"map-intersection"},"Map Intersection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Intersection of two maps."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 & Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 & Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[T11, T12]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the intersection of the two map values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", i.e., a map that contains the\nkey/value pairs that occur in both maps."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) & ("banana": 3, "apple": 1);\n("apple": 1, "pear": 2) & ("banana": 3, "apple": 4);\n')),(0,r.kt)("h5",{id:"map-notequal"},"Map NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1,TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments contain different key/value pairs, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) != ("apple": 1, "banana": 3);\n("apple": 1, "pear": 2) != ("pear": 2, "apple": 1);\n')),(0,r.kt)("h5",{id:"map-strictsubmap"},"Map StrictSubMap"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Strict submap operator on map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1,TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if all key/value pairs in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," occur in the map value ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and\nthe values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"EXp"),(0,r.kt)("sub",null,"2")," are not equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) < ("pear": 2, "apple": 1, "banana" : 3);\n("apple": 1, "pear": 2) < ("apple": 1, "banana" : 3);\n')),(0,r.kt)("h5",{id:"map-strictsupermap"},"Map StrictSuperMap"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Strict supermap operator on map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1,TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if all key/value pairs in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," occur in the map value ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and\nthe values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"EXp"),(0,r.kt)("sub",null,"2")," are not equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("pear": 2, "apple": 1, "banana" : 3) > ("apple": 1, "pear": 2);\n("apple": 1, "banana" : 3) > ("apple": 1, "pear": 2);\n')),(0,r.kt)("h5",{id:"map-submap"},"Map SubMap"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Submap operator on map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1,TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if all key/value pairs in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," occur in the map value ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," or\nthe values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) <= ("pear": 2, "apple": 1);\n("apple": 1, "pear": 2) <= ("pear": 2, "apple": 1, "banana" : 3);\n("apple": 1, "pear": 2) <= ("apple": 1, "banana" : 3);\n')),(0,r.kt)("h5",{id:"map-subscription"},"Map Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a value by its key in map."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Map subscription uses the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," as key in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and returns the\nassociated value. If this key does not occur in the map, the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"NoSuchKey")," is thrown."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Introduce a map, assign it to ",(0,r.kt)("inlineCode",{parentName:"p"},"colors"),", and retrieve the element with index ",(0,r.kt)("inlineCode",{parentName:"p"},'"trumps"'),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'colors = ("hearts":"red", "clover":"black",\n          "trumps":"black", "clubs":"red");\ncolors["trumps"];\n')),(0,r.kt)("p",null,"Explore some erroneous subscription expressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'colors[0];\ncolors["square"];\n')),(0,r.kt)("h5",{id:"map-supermap"},"Map SuperMap"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Supermap operator on map values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1,TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if all key/value pairs in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," occur in the map value ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," or\nthe values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("pear": 2, "apple": 1) >= ("apple": 1, "pear": 2);\n("pear": 2, "apple": 1, "banana" : 3) >= ("apple": 1, "pear": 2);\n("apple": 1, "banana" : 3) >= ("apple": 1, "pear": 2);\n')),(0,r.kt)("h5",{id:"map-union"},"Map Union"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Union of two maps."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 + Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK1, TV1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK2, TV2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[lub(TK1,TK2),lub(TK1,TK2) ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The result is the union of the two map values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),". If they have a pair with the\nsame key in common, that key will be associated in the union with the value associated with that key in\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'("apple": 1, "pear": 2) + ("banana": 3, "kiwi": 4);\n("apple": 1, "pear": 2) + ("banana": 3, "apple": 4);\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Benefits.")),(0,r.kt)("p",null,"Map union is very suited for representing environment composition in interpreters."),(0,r.kt)("h5",{id:"map-in"},"Map in"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Membership test on the keys of a map."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 in Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 in Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")," \\<: ",(0,r.kt)("inlineCode",{parentName:"td"},"TK")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK, TV]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," occurs as key in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise. The type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should be compatible with the key type ",(0,r.kt)("em",{parentName:"p"},"TK")," of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"pear" in ("apple": 1, "pear": 2);\n"pineapple" in ("apple": 1, "pear": 2);\n')),(0,r.kt)("h5",{id:"map-notin"},"Map notin"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Negated membership test on the keys of a map."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 notin Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 notin Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")," \\<: ",(0,r.kt)("inlineCode",{parentName:"td"},"TK")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"map[TK, TV]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," does not occur as key in the map value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise. The type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should be compatible with the key type ",(0,r.kt)("em",{parentName:"p"},"TK")," of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"pineapple" notin ("apple": 1, "pear": 2);\n"pear" notin ("apple": 1, "pear": 2);\n')),(0,r.kt)("h3",{id:"node"},"Node"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp0 ( Exp1, Exp2, \u2026\u200b, FieldName1 = Expr~1, FieldName2 = _Expr~2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp0")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp0 ( Exp1, Exp2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"node")," represent untyped trees and are constructed as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the string value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"0"))," is the node name;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"zero or more expressions of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," are the node's children.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"optionally, unordered named fields can be added as well."))),(0,r.kt)("p",null,"The following are provided for nodes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Node Equal"),": Equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Node GreaterThan"),": Greater than operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Node GreaterThanOrEqual"),": Greater than or equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Node LessThan"),": Less than operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Node LessThanOrEqual"),": Less than or equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Node NotEqual"),": Not equal operator on node values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"Node Slice"),": Retrieve a slice of a node\u2019s argument list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Node Subscription"),": Retrieve an argument of a node via its index."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,'A node with name "my',"_",'node" and three arguments:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"my_node"(1, true, "abc");\n')),(0,r.kt)("p",null,"A nested node structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"my_node1"(1, "my_node2"(3.5, ["a", "b", "c"]), true);\n')),(0,r.kt)("p",null,"A node with named fields:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"my_node2"(1,2,size=2,age=24);\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"nodes are untyped and can be used to quickly import untyped data into Rascal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"pattern matching on nodes is quite expressive"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the lack of types at run-time makes pattern matching on node possibly inaccurate (you might match more than you\nthink)")),(0,r.kt)("h5",{id:"node-equal"},"Node Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equal operator on node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the node names of the values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," are equal and the children of\neach node are pairwise equal, otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"f"(1, "abc", true) == "f"(1, "abc", true);\n"f"(1, "abc", true) == "f"(1, "def", true);\n')),(0,r.kt)("h5",{id:"node-greaterthan"},"Node GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than operator on node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Comparison on nodes is defined by a lexicographic ordering. Node ",(0,r.kt)("inlineCode",{parentName:"p"},"N = F(N1, \u2026\u200b, Nn)")," is greater than node ",(0,r.kt)("inlineCode",{parentName:"p"},"N = G(M1, \u2026\u200b,\nMm)")," when: ","*"," ",(0,r.kt)("em",{parentName:"p"},"N")," is not equal to ",(0,r.kt)("em",{parentName:"p"},"M"),", and ","*"," ",(0,r.kt)("em",{parentName:"p"},"F")," is lexicographically greater than ",(0,r.kt)("em",{parentName:"p"},"G"),", or ",(0,r.kt)("em",{parentName:"p"},"F")," is equal to ",(0,r.kt)("em",{parentName:"p"},"G")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n >\nm"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"g"(3) > "f"(10, "abc");\n"f"(10, "abc") > "f"(10);\n')),(0,r.kt)("h5",{id:"node-greaterthanorequal"},"Node GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than or equal operator on node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Comparison on nodes is defined by a lexicographic ordering. Node ",(0,r.kt)("inlineCode",{parentName:"p"},"N = F(N1, \u2026\u200b, Nn)")," is greater than or equal node ",(0,r.kt)("inlineCode",{parentName:"p"},"N =\nG(M1, \u2026\u200b, Mm)")," when: ","*"," ",(0,r.kt)("em",{parentName:"p"},"N")," is equal to ",(0,r.kt)("em",{parentName:"p"},"M"),", or ","*"," ",(0,r.kt)("em",{parentName:"p"},"F")," is lexicographically greater than ",(0,r.kt)("em",{parentName:"p"},"G"),", or ",(0,r.kt)("em",{parentName:"p"},"F")," is equal to ",(0,r.kt)("em",{parentName:"p"},"G")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"n > m"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"g"(3) >= "f"(10, "abc");\n"f"(10, "abc") >= "f"(10);\n"f"(10, "abc") >= "f"(10, "abc");\n')),(0,r.kt)("h5",{id:"node-lessthan"},"Node LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than operator on node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Comparison on nodes is defined by a lexicographic ordering. Node ",(0,r.kt)("inlineCode",{parentName:"p"},"N = F(N1, \u2026\u200b, Nn)")," is less than node ",(0,r.kt)("inlineCode",{parentName:"p"},"N = G(M1, \u2026\u200b,\nMm)")," when: ","*"," ",(0,r.kt)("em",{parentName:"p"},"N")," is not equal to ",(0,r.kt)("em",{parentName:"p"},"M"),", and ","*"," ",(0,r.kt)("em",{parentName:"p"},"F")," is lexicographically less than ",(0,r.kt)("em",{parentName:"p"},"G"),", or ",(0,r.kt)("em",{parentName:"p"},"F")," is equal to ",(0,r.kt)("em",{parentName:"p"},"G")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n <\nm"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"f"(10, "abc") < "g"(3);\n"f"(10) < "f"(10, "abc");\n')),(0,r.kt)("h5",{id:"node-lessthanorequal"},"Node LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than or equal operator on node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Comparison on nodes is defined by a lexicographic ordering. Node ",(0,r.kt)("inlineCode",{parentName:"p"},"N = F(N1, \u2026\u200b, Nn)")," is less than or equal node ",(0,r.kt)("inlineCode",{parentName:"p"},"N =\nG(M1, \u2026\u200b, Mm)")," when: ","*"," ",(0,r.kt)("em",{parentName:"p"},"N")," is equal to ",(0,r.kt)("em",{parentName:"p"},"M"),", or ","*"," ",(0,r.kt)("em",{parentName:"p"},"F")," is lexicographically less than ",(0,r.kt)("em",{parentName:"p"},"G"),", or ",(0,r.kt)("em",{parentName:"p"},"F")," is equal to ",(0,r.kt)("em",{parentName:"p"},"G")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n\n< m"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"f"(10, "abc") <= "f"(10, "abc");\n"f"(10) <= "f"(10, "abc");\n')),(0,r.kt)("h5",{id:"node-notequal"},"Node NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on node values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the node names of the values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," are unequal or any of the\nchildren of each node is pairwise unequal, otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"f"(1, "abc", true) != "g"(1, "abc", true);\n"f"(1, "abc", true) != "f"(1, "abc", true);\n')),(0,r.kt)("h5",{id:"node-slice"},"Node Slice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a slice of a node\u2019s argument list."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 .. Exp4]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 , Exp3 .. Exp4]")))),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," are optional."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp3")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp4")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 .. Exp4 ]")," or ",(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 , Exp3 .. Exp4]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list[value]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A Node slice is similar to a list ",(0,r.kt)("a",{parentName:"p",href:"#slice"},"List Slice")," and uses the integer values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," to determine the ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," (",(0,r.kt)("strong",{parentName:"p"},"inclusive"),") and ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," (",(0,r.kt)("strong",{parentName:"p"},"exclusive"),") of a slice from the children of the\nnode value ",(0,r.kt)("em",{parentName:"p"},"ND")," of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". Negative indices count from the end of the list of children backwards. Using the\nsecond form, an extra index ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"3")," is given that determines the index of the second element in the slice and\nestablishes the ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," between successive elements in the slice. The default ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," is 1. If ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," is smaller than\n",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", the slice is constructed backwards."),(0,r.kt)("p",null,"Let ",(0,r.kt)("inlineCode",{parentName:"p"},"Len")," be the number of children of ",(0,r.kt)("em",{parentName:"p"},"ND")," and let ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"3")," and ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"4")," be the\nrespective values of the expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," when they are present."),(0,r.kt)("p",null,"The slice parameters ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," are determined as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2"))," is absent, then ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = 0"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("em",{parentName:"p"},"N",(0,r.kt)("sub",null,"2"))," ",">","= 0 then ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = N2")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = N2 + Len"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4"))," is absent, then ",(0,r.kt)("inlineCode",{parentName:"p"},"end = Len"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("em",{parentName:"p"},"N",(0,r.kt)("sub",null,"4"))," ",">","= 0, then ",(0,r.kt)("inlineCode",{parentName:"p"},"end = N4")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"end = N4 + Len"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"3")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"3"))," is absent, then if ",(0,r.kt)("inlineCode",{parentName:"p"},"begin < end")," then ",(0,r.kt)("inlineCode",{parentName:"p"},"step = 1")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"step = -1"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("inlineCode",{parentName:"p"},"begin < end"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"step = N3 - begin")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"step = begin - N3"),"."))))),(0,r.kt)("p",null,"Now, the constraints ",(0,r.kt)("inlineCode",{parentName:"p"},"0 \u21d0 begin < Len")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"0 < end < Len")," should hold, otherwise the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBounds")," is\nthrown."),(0,r.kt)("p",null,"The slice consists of the children ",(0,r.kt)("inlineCode",{parentName:"p"},"ND[begin]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ND[begin+step]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ND[end - step]"),". When ",(0,r.kt)("inlineCode",{parentName:"p"},"begin >= end"),", the elements\nare listed in reverse order."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the list ",(0,r.kt)("inlineCode",{parentName:"p"},'ND = "f"(0, "abc", 20, false, 40, [3,4,5], 60, {"a", "b"}, 80);')," as running example."),(0,r.kt)("p",null,"Here is a view on the children of ",(0,r.kt)("em",{parentName:"p"},"ND")," that will help to correlate positive and negative indices:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"i")),(0,r.kt)("th",{parentName:"tr",align:null},"0"),(0,r.kt)("th",{parentName:"tr",align:null},"1"),(0,r.kt)("th",{parentName:"tr",align:null},"2"),(0,r.kt)("th",{parentName:"tr",align:null},"3"),(0,r.kt)("th",{parentName:"tr",align:null},"4"),(0,r.kt)("th",{parentName:"tr",align:null},"5"),(0,r.kt)("th",{parentName:"tr",align:null},"6"),(0,r.kt)("th",{parentName:"tr",align:null},"7"),(0,r.kt)("th",{parentName:"tr",align:null},"8"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[i]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"0")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"abc"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"20")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"40")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[3,4,5]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"60")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"a", "b"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"80"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-i")),(0,r.kt)("td",{parentName:"tr",align:null},"-","9"),(0,r.kt)("td",{parentName:"tr",align:null},"-","8"),(0,r.kt)("td",{parentName:"tr",align:null},"-","7"),(0,r.kt)("td",{parentName:"tr",align:null},"-","6"),(0,r.kt)("td",{parentName:"tr",align:null},"-","5"),(0,r.kt)("td",{parentName:"tr",align:null},"-","4"),(0,r.kt)("td",{parentName:"tr",align:null},"-","3"),(0,r.kt)("td",{parentName:"tr",align:null},"-","2"),(0,r.kt)("td",{parentName:"tr",align:null},"-","1")))),(0,r.kt)("p",null,"Some common use cases (with ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," \u21d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),"):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Slice"),(0,r.kt)("th",{parentName:"tr",align:null},"Means:"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[begin..end]")),(0,r.kt)("td",{parentName:"tr",align:null},"children with indices ",(0,r.kt)("inlineCode",{parentName:"td"},"begin")," through ",(0,r.kt)("inlineCode",{parentName:"td"},"end-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[begin..]")),(0,r.kt)("td",{parentName:"tr",align:null},"children with indices ",(0,r.kt)("inlineCode",{parentName:"td"},"begin")," through the rest of the list of children")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[..end]")),(0,r.kt)("td",{parentName:"tr",align:null},"children with indices from the beginning through ",(0,r.kt)("inlineCode",{parentName:"td"},"end-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[..]")),(0,r.kt)("td",{parentName:"tr",align:null},"the whole list of children")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[-1]")),(0,r.kt)("td",{parentName:"tr",align:null},"last child of the list of children")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[-2..]")),(0,r.kt)("td",{parentName:"tr",align:null},"the last two children of the list of children")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ND[..-2]")),(0,r.kt)("td",{parentName:"tr",align:null},"all children except the last two.")))),(0,r.kt)("p",null,"Let\u2019s put this into practice now."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'ND = "f"(0, "abc", 20, false, 40, [3,4,5], 60, {"a", "b"}, 80);\n')),(0,r.kt)("p",null,"Slices with begin \\< end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"ND[1..3];\nND[1..];       // empty end => end of list of children\nND[..3];       // empty begin => first child of list\nND[..];        // both empty => whole list of children\n")),(0,r.kt)("p",null,"Slices with begin ",">","= end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"ND[3..1];      // slice contains children with indices 3 and 2 (in that order)\nND[3..3];      // empty slice when begin == end\n")),(0,r.kt)("p",null,"Slices with negative begin or end:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"ND[2..-2];     // equivalent to ND[2..7]\nND[2..7];\nND[-4..-2];    // equivalent to ND[5..7]\nND[5..7];\n")),(0,r.kt)("p",null,"Slices with an explicit second index:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"ND[1,3..6];\nND[5,3..];\n")),(0,r.kt)("p",null,"Explore error cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"ND[..10];\nND[1..20];\n")),(0,r.kt)("h5",{id:"node-subscription"},"Node Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve an argument of a node via its index."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"node")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Node subscription uses the integer value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," as index in the argument list of the node value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". The value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," should be greater or equal 0 and less than the number of arguments of\nthe node. If this is not the case, the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBounds")," is thrown."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Introduce a node, assign it to F and retrieve the various arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'F = "f"(1, "abc", false);\nF[0]\nF[1]\nF[2]\n')),(0,r.kt)("p",null,"Explore an error case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"F[3];\n")),(0,r.kt)("h3",{id:"number"},"Number"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"real"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"num")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Numbers include integers (values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),") and reals (values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"real"),"). If both operands have the same type\n(",(0,r.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"real"),") then the operator is the corresponding operator on integers or reals. Otherwise, integer arguments are\nfirst converted to real and the real operator is applied."),(0,r.kt)("p",null,"The following operations are provided on numbers:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#addition"},"Number Addition"),": Addition on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#conditional"},"Number Conditional"),": Conditional expression for numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#division"},"Number Division"),": Division on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Number Equal"),": Equality operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Number GreaterThan"),": Greater than operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Number GreaterThanOrEqual"),": Greater than or equal operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Number LessThan"),": Less than operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Number LessThanOrEqual"),": Less than or equal operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#multiplication"},"Number Multiplication"),": Multiply two numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#negation"},"Number Negation"),": Negate a numeric value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Number NotEqual"),": Not equal operator on numeric values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#remainder"},"Number Remainder"),": Remainder of two integer values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subtraction"},"Number Subtraction"),": Subtract two numeric values."))),(0,r.kt)("h5",{id:"number-addition"},"Number Addition"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Addition on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 + Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the numerical sum of the values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"12 + 13\n12 + 13.5\n")),(0,r.kt)("h5",{id:"number-conditional"},"Number Conditional"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Conditional expression for numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 ? Exp2 : Exp3")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp3")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 ? Exp2 : Exp3")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"If the value of ",(0,r.kt)("em",{parentName:"p"},"Exp")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," then the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," else the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"(3 > 2) ? 10 : 20\n(3 > 20) ? 10 : 20\n")),(0,r.kt)("h5",{id:"number-division"},"Number Division"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Division on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 / Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 / Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the result of dividing the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"12 / 3\n10 / 3\n12 / 3.0\n10 / 3.0\n12 / 0\n")),(0,r.kt)("h5",{id:"number-equal"},"Number Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality operator on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of both arguments is numerically equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"12 == 12\n12 == 12.0\n12 == 13\n12 == 13.0\n3.14 == 3.14\n3.14 == 3\n")),(0,r.kt)("h5",{id:"number-greaterthan"},"Number GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than operator on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," is numerically greater than the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"13 > 12\n12 > 13\n13.5 > 12\n12.5 > 13\n")),(0,r.kt)("h5",{id:"number-greaterthanorequal"},"Number GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than or equal operator on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," is numerically greater than or equal to the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),",\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"13 >= 12\n12 >= 13\n13.5 >= 12\n12.5 >= 13\n")),(0,r.kt)("h5",{id:"number-lessthan"},"Number LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than operator on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," is numerically less than the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"13 < 12\n12 < 13\n13.5 < 12\n12.5 < 13\n")),(0,r.kt)("h5",{id:"number-lessthanorequal"},"Number LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than or equal operator on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," is numerically less than or equal to the value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),", and\n",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"13 <= 12\n12 <= 13\n13.5 <= 12\n12.5 <= 13\n")),(0,r.kt)("h5",{id:"number-multiplication"},"Number Multiplication"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Multiply two numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 * Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 * Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the result of multiplying the values of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," and ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"12 * 13\n12 * 13.5\n-12*13\n")),(0,r.kt)("h5",{id:"number-negation"},"Number Negation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Negate a numeric value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"- Exp")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"- Exp")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the negated values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"-12\n-13.5\n- -12\n")),(0,r.kt)("h5",{id:"number-notequal"},"Number NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of both arguments is numerically unequal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"12 != 13\n12 != 12\n12 != 13.0\n12.0 != 13\n3.14 != 3\n3.14 != 3.14\n")),(0,r.kt)("h5",{id:"number-remainder"},"Number Remainder"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Remainder of two integer values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 % Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 % Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the remainder when dividing the of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"12 % 5\n12 % 6\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"Remainder is only defined on integers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"13.5 % 6\n")),(0,r.kt)("h5",{id:"number-subtraction"},"Number Subtraction"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Subtract two numeric values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 - Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 - Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"real"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the numerical result of subtracting the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," from the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"13 - 12\n13.5 - 12\n12 - 13\n12 - 13.5\n")),(0,r.kt)("h3",{id:"range"},"Range"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Numeric range of values."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"[ Exp1 .. Exp3 ]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"[ Exp1, Exp2 .. Exp3 ]")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Ranges are a shorthand for describing lists of integers from ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," up to (exclusive) ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"3")," with\nincrements of 1. When ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is present it is taken as the second element of the list and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," -\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is used as increment for the subsequent list elements."),(0,r.kt)("p",null,"A range with integer expressions is identical to a list ",(0,r.kt)("a",{parentName:"p",href:"#slice"},"List Slice"),". However, a range may also contain\nnumeric expressions that are not integers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1 .. 10];\n[1, 3 .. 10];\n[0.5, 3.2 .. 10];\n[1, -2 .. -10];\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Benefits.")),(0,r.kt)("p",null,"Ranges are mostly used to loop over ranges of integers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"In some cases ranges are empty where one could have expected at least one element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[1, 3 .. -10];\n")),(0,r.kt)("h3",{id:"real"},"Real"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Real values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"real")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The real values are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"real")," and are written as usual in most programming languages. They can have\n",(0,r.kt)("em",{parentName:"p"},"arbitrary size and precision"),"."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#number"},"Number")," for all operations on integers, reals and numbers."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"1.5")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"3.14e-123"))),(0,r.kt)("h3",{id:"reifiedtypes"},"ReifiedTypes"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Types can be represented by values"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The type reify expression operator has two functions in one go:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it transforms type literals into values that represent them (an isomorphic relation)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it reifies the declarations necessary to build values of the types as well"))),(0,r.kt)("p",null,"As a result a reified type can be used to reconstruct a type and the abstract (",(0,r.kt)("a",{parentName:"p",href:"#ADT"},"Algebraic Data\nType"),") or concrete (",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax Definition"),") grammar that\nproduced it."),(0,r.kt)("p",null,"Type literals have a nice interaction with ",(0,r.kt)("a",{parentName:"p",href:"#typeparameters"},"Type Parameters"),", since they can be used to\nbind a type parameter without having to provide a value of the type. An example is the ",(0,r.kt)("a",{parentName:"p",href:"#parse"},"???")," function in\n",(0,r.kt)("a",{parentName:"p",href:"#parseTree"},"???")," (see below for an example usage)."),(0,r.kt)("p",null,"The values that are used to represent types are declared in the ",(0,r.kt)("a",{parentName:"p",href:"#type"},"???")," module and\n",(0,r.kt)("a",{parentName:"p",href:"#parseTree"},"???")," modules, namely ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," is the data-type to represent types symbolically and\n",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," is the data-type for representing grammatical constructs."),(0,r.kt)("p",null,"A type literal wraps a ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," and a map of ","`","Production","`","s."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"First import the module ",(0,r.kt)("inlineCode",{parentName:"p"},"Type"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import Type;\n")),(0,r.kt)("p",null,"Builtin types can be constructed without definitions, so the reified type representation is simple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"#int\n#list[int]\n#rel[int from, int to]\n")),(0,r.kt)("p",null,"to get the symbol from the reified type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"#int.symbol\n")),(0,r.kt)("p",null,"or we can use some definitions and reify the defined type to see a different behavior:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"data Nat = zero() | succ(Nat prev) | add(Nat l, Nat r) | mul(Nat l, Nat r);\n#Nat\n")),(0,r.kt)("p",null,"and we can get an abstract definition of the constructors of the ","[","AlgebraicDataType","]",":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import Type;\n#Nat.definitions[adt("Nat",[])]\n')),(0,r.kt)("p",null,"we could go the other way around and construct a type literal dynamically:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"type(\\int(),())\ntype(\\int(),()) == #int\n")),(0,r.kt)("p",null,"we use type literals often in IO to express an expected type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import ValueIO;\nint testInt = readTextValueString(#int, "1");\ntuple[int,int] testTuple = readTextValueString(#tuple[int,int], "\\<1,2\\>");\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Note that the type reify operator always produces constant values, because type literals are always constants.")),(0,r.kt)("h3",{id:"relation"},"Relation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{ < Exp11, Exp12, \u2026\u200b > , < Exp21, Exp22, \u2026\u200b > , \u2026\u200b }")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp11")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp12")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"{ < Exp11, Exp12, \u2026\u200b > , \u2026\u200b }")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A relation is a set of elements with the following property:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"All elements have the same static tuple type.")),(0,r.kt)("p",null,"Relations are thus nothing more than sets of tuples, but since they are used so often we provide a shorthand notation\nfor them. Relations are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"rel[T1 L1, T2 L2, \u2026\u200b ]"),", where ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2"),", \u2026\u200b are\narbitrary types and ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"2"),", \u2026\u200b are optional labels. It is a shorthand for ",(0,r.kt)("inlineCode",{parentName:"p"},"set[tuple[T1 L1, T2\nL2, \u2026\u200b ]]"),"."),(0,r.kt)("p",null,"An n-ary relations with m tuples is denoted by `{< E11, E12, \u2026\u200b, E1n >,< E21, E22, \u2026\u200b, E2n >, \u2026\u200b, < Em1, Em2, \u2026\u200b, Emn"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"}`, where the ",(0,r.kt)("em",{parentName:"p"},"E"),(0,r.kt)("sub",null,"ij")," are expressions that yield the desired element type ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"i"),".")),(0,r.kt)("p",null,"Since relations are a form of set all operations (see ",(0,r.kt)("a",{parentName:"p",href:"#set"},"Set"),") and functions (see ",(0,r.kt)("a",{parentName:"p",href:"#set"},"???"),") are\nalso applicable to relations."),(0,r.kt)("p",null,"The following additional operators are provided for relations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#cartesianproduct"},"Relation CartesianProduct"),": Cartesian product of two relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#composition"},"Relation Composition"),": Composition of two relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"Relation FieldSelection"),": Select a field (column) from a relation value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#join"},"Relation Join"),": Join two relation values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#reflexivetransitiveclosure"},"Relation ReflexiveTransitiveClosure"),": The reflexive transitive closure of a\nbinary relation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Relation Subscription"),": Indexing of a relation via tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#transitiveclosure"},"Relation TransitiveClosure"),": Transitive closure on binary relation values."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#relation"},"library functions")," available for Relations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{<1,10>, <2,20>, <3,30>}\n")),(0,r.kt)("p",null,"instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"rel[int,int]")," we can also give ",(0,r.kt)("inlineCode",{parentName:"p"},"set[tuple[int,int]]")," as type of the above expression remember that these\ntypes are interchangeable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'{<"a",10>, <"b",20>, <"c",30>}\n{<"a", 1, "b">, <"c", 2, "d">}\n')),(0,r.kt)("h5",{id:"relation-cartesianproduct"},"Relation CartesianProduct"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Cartesian product of two relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 * Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 * Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns a binary relation that is the ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Cartesian_product"},"Cartesian product")," of two sets."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} * {9};\n{1, 2, 3} * {10, 11};\n")),(0,r.kt)("h5",{id:"relation-composition"},"Relation Composition"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Composition of two relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 o Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 o Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T2, T3]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T3]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the composition of two binary relations."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import Relation;\n{<1,10>, <2,20>, <3,15>} o {<10,100>, <20,200>};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"We use the letter ",(0,r.kt)("inlineCode",{parentName:"p"},"o")," as operator and this may conflict other defined names."),(0,r.kt)("h5",{id:"relation-fieldselection"},"Relation FieldSelection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Select a field (column) from a relation value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp . Name")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp . Name")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1 L1, T2 L2, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[Ti]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Exp")," should evaluate to a relation that has an ",(0,r.kt)("em",{parentName:"p"},"i"),"-th field label ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"i")," that is identical to ",(0,r.kt)("em",{parentName:"p"},"Name"),". Return a\nset with all values of that field. ",(0,r.kt)("em",{parentName:"p"},"Name")," stands for itself and is not evaluated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rel[str street, int nm] R = {<"abc", 1>, <"abc", 2>, <"def", 4>, <"def", 5>};\nR.street;\n')),(0,r.kt)("h5",{id:"relation-join"},"Relation Join"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Join two relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 join Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 join Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[ T11, T12, T13, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[ T21, T22, T23, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[ T11, T12, T13, \u2026\u200b, T21, T22, T23, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Relation resulting from the natural join of the relation values of the two arguments. This relation contains tuples that\nare the result from concatenating the elements from both arguments."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{<1,2>, <10,20>} join {<2,3>};\n{<1,2>} join {3, 4};\n{<1,2>, <10,20>} join {<2,3>, <20,30>};\n")),(0,r.kt)("h5",{id:"relation-reflexivetransitiveclosure"},"Relation ReflexiveTransitiveClosure"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The reflexive transitive closure of a binary relation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp *")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp *")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Reflexive transitive closure is defined by repeated composition of a relation. If we define for a given relation R:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"0")," = identity relation = ",(0,r.kt)("inlineCode",{parentName:"p"},"{<a, a>, <b, b> | <a, b> \u2190 R}"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"1")," = R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"2")," = R o R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"3")," = R o R",(0,r.kt)("sup",null,"2"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2026\u200b"))),(0,r.kt)("p",null,"then the reflexive transitive closure R","*"," can be defined in two ways: (also see ",(0,r.kt)("a",{parentName:"p",href:"#transitiveclosure"},"Relation\nTransitiveClosure"),"): ","*"," R","*"," = R",(0,r.kt)("sup",null,"0")," + R",(0,r.kt)("sup",null,"1")," + R",(0,r.kt)("sup",null,"2")," + R",(0,r.kt)("sup",null,"3")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u2026\u200b ","*"," R","*"," = R",(0,r.kt)("sup",null,"0")," + R+")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{<1,2>, <2,3>, <3,4>}*;\n")),(0,r.kt)("h5",{id:"relation-subscription"},"Relation Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Indexing of a relation via tuple values."),(0,r.kt)("h5",{id:"exp_0--exp1-exp2--expn"},(0,r.kt)("inlineCode",{parentName:"h5"},"Exp_0 [ Exp1, Exp2, \u2026\u200b Expn]")),(0,r.kt)("h5",{id:"exp_0--exp1"},(0,r.kt)("inlineCode",{parentName:"h5"},"Exp_0 [ Exp1]")),(0,r.kt)("h6",{id:"variant-1-3"},"Variant 1"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp_0")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp_0 [ Exp1, Exp2, \u2026\u200b ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2, \u2026\u200b Tm]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[Tn, Tn+1, \u2026\u200b Tm]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("h6",{id:"variant-2-3"},"Variant 2"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp0")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp0 [ Exp1 ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2, \u2026\u200b Tm]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T2, T2, \u2026\u200b Tm]"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Relation resulting from subscription of a relation ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"0"),"."),(0,r.kt)("h6",{id:"variant-1-4"},"Variant 1"),(0,r.kt)("p",null,"Subscription with the index values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", \u2026\u200b. The result is a relation with all tuples\nthat have these index values as first elements with the index values removed from the tuple. If the resulting tuple has\nonly a single element, a set is returned instead of a relation. A wildcard ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," as index value matches all possible\nvalues at that index position."),(0,r.kt)("h6",{id:"variant-2-4"},"Variant 2"),(0,r.kt)("p",null,"Subscription with a set of the index values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". The result is a relation with all tuples that have\nthese index values as first element with the index values removed from the tuple."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"R = {<1,10>, <2,20>, <1,11>, <3,30>, <2,21>};\nR[1];\nR[{1}];\nR[{1, 2}];\nRR = {<1,10,100>,<1,11,101>,<2,20,200>,<2,22,202>,\n              <3,30,300>};\nRR[1];\nRR[1,_];\n")),(0,r.kt)("p",null,"Introduce a relation with economic data and assign it to ",(0,r.kt)("inlineCode",{parentName:"p"},"GDP"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rel[str country, int year, int amount] GDP =\n{<"US", 2008, 14264600>, <"EU", 2008, 18394115>,\n <"Japan", 2008, 4923761>, <"US", 2007, 13811200>,\n <"EU", 2007, 13811200>, <"Japan", 2007, 4376705>};\n')),(0,r.kt)("p",null,"and then retrieve the information for the index ",(0,r.kt)("inlineCode",{parentName:"p"},'"Japan"'),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'GDP["Japan"];\n')),(0,r.kt)("p",null,"or rather for the indices ",(0,r.kt)("inlineCode",{parentName:"p"},'"Japan"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},"2008"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'GDP["Japan", 2008];\n')),(0,r.kt)("h5",{id:"relation-transitiveclosure"},"Relation TransitiveClosure"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Transitive closure on binary relation values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp +")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp +")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1, T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the transitive closure of a binary relation. Transitive closure is defined by repeated composition of a\nrelation. If we define for a given relation R:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"1")," = R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"2")," = R o R")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"R",(0,r.kt)("sup",null,"3")," = R o R",(0,r.kt)("sup",null,"2"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2026\u200b"))),(0,r.kt)("p",null,"then the transitive closure R+ can be defined as"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"R+ = R",(0,r.kt)("sup",null,"1")," + R",(0,r.kt)("sup",null,"2")," + R",(0,r.kt)("sup",null,"3")," + \u2026\u200b")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{<1,2>, <2,3>, <3,4>}+;\n")),(0,r.kt)("p",null,"We can also simply (but not necessarily efficiently) define transitive closure ourselves:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rel[int,int] tclosure(rel[int,int] R) {\n   tc = R;\n   while(true){\n      tc1 = tc;\n      tc += tc o R;\n      if(tc1 == tc)\n         return tc;\n   }\n}\n//tclosure({<1,2>, <2,3>, <3,4>});\n")),(0,r.kt)("h3",{id:"set"},"Set"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{ Exp1, Exp2, \u2026\u200b }")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"{ Exp1, Exp2, \u2026\u200b }")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"1"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"2"))),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},"set","["," lub(",(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"1")),", ",(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"2")),", \u2026\u200b ) ","]")))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A set is an unordered sequence of values and has the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All elements have the same static type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The order of the elements does not matter.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A set contains an element only once. In other words, duplicate elements are eliminated and no matter how many times\nan element is added to a set, it will occur in it only once."))),(0,r.kt)("p",null,"The type of a set has the form ",(0,r.kt)("inlineCode",{parentName:"p"},"set[T]"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an arbitrary type."),(0,r.kt)("p",null,"When a value or variable of type set occurs inside a set, that set value is inserted as set element. To achieve splicing\nof these elements, i.e., the insertion of the elements of the set value rather than the whole set, it has to be prefixed\nby the splice operator ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),"."),(0,r.kt)("p",null,"The following operators are provided on sets:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Set Comprehension"),": A set comprehension generates a set value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#difference"},"Set Difference"),": The difference between two sets.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Set Equal"),": Equal operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#insert"},"Set Insert"),": Add an element to a set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#intersection"},"Set Intersection"),": Intersection of two sets.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Set NotEqual"),": Not equal operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#product"},"Set Product"),": The product of two set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#splice"},"Set Splice"),": Splice the elements of a set in an enclosing set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsubset"},"Set StrictSubSet"),": Strict subset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#strictsuperset"},"Set StrictSuperSet"),": Strict superset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subset"},"Set SubSet"),": Subset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#superset"},"Set SuperSet"),": Superset operator on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#union"},"Set Union"),": Union of two set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#in"},"Set in"),": Membership test on set values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notin"},"Set notin"),": Negated membership test on set values."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#set"},"library functions")," available for Sets. .Examples ","#","#"," Set types"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'{1, 2, 3};\n{<1,10>, <2,20>, <3,30>};\n{1, "b", 3};\n{<"a", 10>, <"b", 20>, <"c", 30>}\n{{"a", "b"}, {"c", "d", "e"}}\n')),(0,r.kt)("p",null,"Note that"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"{1, 2, 3}")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"{3, 2, 1}")," are identical sets (since order is not relevant).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"{1, 2, 3}")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"{1, 2, 3, 1}")," are also identical sets (since duplication is not relevant)."))),(0,r.kt)("h5",{id:"set-splicing"},"Set splicing"),(0,r.kt)("p",null,"Introduce a set variable ",(0,r.kt)("inlineCode",{parentName:"p"},"S")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S = {1, 2, 3};\n")),(0,r.kt)("p",null,"and observe how the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"S")," is added as single element in another set:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{10, S, 20};\n")),(0,r.kt)("p",null,"or how its elements are added as elements to the other set:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{10, *S, 20};\n")),(0,r.kt)("h5",{id:"set-comprehension"},"Set Comprehension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A set comprehension generates a set value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{ Exp1, Exp2, \u2026\u200b | Gen1, Gen2, \u2026\u200b }")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"{ Exp1, Exp2, \u2026\u200b \\| Gen1, Gen2, \u2026\u200b }")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[ lub( T1, T2, \u2026\u200b ) ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A set comprehension consists of a number of contributing expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", \u2026\u200b and a\nnumber of generators ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"3"),", \u2026\u200b that are evaluated as described in\n",(0,r.kt)("a",{parentName:"p",href:"#comprehensions"},"Comprehensions"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{ N * N | int N <- [0 .. 10]};\n{ N * N | int N <- [0 .. 10], N % 3 == 0};\n")),(0,r.kt)("h5",{id:"set-difference"},"Set Difference"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The difference between two sets."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 - Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 - Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"If both ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," have a set as value, the result is the difference of these two set\nvalues. If ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," does not have a set as value, it is first converted to a set before the difference is\ncomputed. The difference is computed by removing all elements of the second set from the first set."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3, 4} - {1, 2, 3};\n{1, 2, 3, 4} - {3};\n{1, 2, 3, 4} - 3;\n{1, 2, 3, 4} - {5, 6, 7};\n")),(0,r.kt)("h5",{id:"set-equal"},"Set Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equal operator on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are equal sets and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} == {3, 2, 1};\n{1, 2, 3} == {1, 2};\n")),(0,r.kt)("h5",{id:"set-insert"},"Set Insert"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Add an element to a set."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 + Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator will add elements to sets."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} + 4;\n1 + { 2, 3, 4};\n{1} + 1;\n1 + {1};\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"if both operands of ",(0,r.kt)("inlineCode",{parentName:"li"},"+")," are a set then it acts as ",(0,r.kt)("a",{parentName:"li",href:"#union"},"Set Union"),".")),(0,r.kt)("h5",{id:"set-intersection"},"Set Intersection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Intersection of two sets."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 & Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 & Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns the intersection of the two set values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),". The intersection consists of\nthe common elements of both sets."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3, 4, 5} & {4, 5, 6};\n")),(0,r.kt)("h5",{id:"set-notequal"},"Set NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are unequal sets and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} != {3, 2, 1};\n{1, 2, 3} != {1, 2};\n")),(0,r.kt)("h5",{id:"set-product"},"Set Product"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The product of two set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 * Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 * Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"rel[T1,T2]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields a relation resulting from the product of the values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),". It contains a\ntuple for each combination of values from both arguments."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} * {4, 5, 6};\n")),(0,r.kt)("p",null,"A card deck can be created as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'{"clubs", "hearts", "diamonds", "spades"} * {1,2,3,4,5,6,7,8,9,10,11,12,13};\n')),(0,r.kt)("h5",{id:"set-splice"},"Set Splice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Splice the elements of a set in an enclosing set."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Expn")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"{Exp1, \u2026\u200b, Exp, \u2026\u200b, Expn}")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Tn")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1, \u2026\u200b, T, \u2026\u200b,Tn)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The operator ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," splices the elements of a set in an enclosing set."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the following set in which the set ",(0,r.kt)("inlineCode",{parentName:"p"},"{10, 20, 30}")," occurs as set element. It has as type ",(0,r.kt)("inlineCode",{parentName:"p"},"set[value]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, {10, 20, 30}, 3, 4};\n")),(0,r.kt)("p",null,"The effect of splicing the same set element in the enclosing set gives a flat list of type ",(0,r.kt)("inlineCode",{parentName:"p"},"set[int]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, *{10, 20, 30}, 3, 4};\n")),(0,r.kt)("p",null,"The same example can be written as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S = {10, 20, 30};\n{1, 2, *S, 3, 4};\n")),(0,r.kt)("h5",{id:"set-strictsubset"},"Set StrictSubSet"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Strict subset operator on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is a strict subset of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} < {1, 2, 3, 4};\n{1, 2, 3} < {1, 3, 4};\n{1, 2, 3} < {1, 2, 3};\n")),(0,r.kt)("h5",{id:"set-strictsuperset"},"Set StrictSuperSet"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Strict superset operator on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is a strict superset of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3, 4} > {3, 2, 1};\n{1, 2, 3, 4} > {4, 3, 2, 1};\n")),(0,r.kt)("h5",{id:"set-subset"},"Set SubSet"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Subset operator on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"SetExp"),(0,r.kt)("sub",null,"1")," is a subset of the value of ",(0,r.kt)("em",{parentName:"p"},"SetExp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} <= {1, 2, 3, 4};\n{1, 2, 3} <= {1, 2, 3};\n")),(0,r.kt)("h5",{id:"set-superset"},"Set SuperSet"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Superset operator on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is a superset of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3, 4} >= {3, 2, 1};\n{1, 2, 3, 4} >= {4, 3, 2, 1};\n")),(0,r.kt)("h5",{id:"set-union"},"Set Union"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Union of two set values."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T1]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[lub(T1,T2)]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator computes set union if both operands are sets. If one of the operands is not a set, it acts as ",(0,r.kt)("a",{parentName:"p",href:"#insert"},"Set\nInsert")," instead."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1, 2, 3} + {4, 5, 6};\n{1,2,3} + {2,3,4};\n{1, 2, 3} + {3};\n{2} + { 2, 3, 4};\n")),(0,r.kt)("h5",{id:"set-in"},"Set in"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Membership test on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 in Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 in Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")," \\<: ",(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," occurs as element in the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise. The type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should be compatible with the element type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"2 in {1, 2, 3};\n4 in {1, 2, 3};\n")),(0,r.kt)("h5",{id:"set-notin"},"Set notin"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Negated membership test on set values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 notin Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 notin Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")," \\<: ",(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"set[T2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," does not occur as element in the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\notherwise. The type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should be compatible with the element type of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"4 notin {1, 2, 3};\n4 notin {1, 2, 3, 4};\n")),(0,r.kt)("h3",{id:"string"},"String"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"String values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'"StringChar1StringChar2\u2026\u200b"')," where ","`",(0,r.kt)("em",{parentName:"p"},"StringChar",(0,r.kt)("sub",null,"i"))," may be one of the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Ordinary character"),": Any character except ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">"),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},"'")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"\\"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Escaped character"),": Backslash ",(0,r.kt)("inlineCode",{parentName:"p"},"\\")," followed by any of ",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">"),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},"'")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"\\")," represents the escaped character\nitself. Other escape sequences that are supported are:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\n"),": newline")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\t"),": tab")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\r"),": carriage return")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\b"),": backspace")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\f"),": vertical feed")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\u hexDigit1 hexDigit2 hexDigit3 hexDigit4")," : hexadecimal escapes with four digit indexes into UNICODE.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\U hexDigit1 hexDigit2 hexDigit3 hexDigit4 hexDigit5 hexDigit6")," : hexadecimal escapes with six digit indexes\ninto UNICODE.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"\\ a_hexDigit1_ hexDigit2"),": hexadecimal escapes with 2 digit indexes into ASCII (0x0 \u2026\u200b 0x7F).")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"String Interpolation"),":"))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Form"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<_Exp_>")),(0,r.kt)("td",{parentName:"tr",align:null},"Interpolate the value of the expression as a string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<if(Exp){> \u2026\u200b StringChars \u2026\u200b <}>")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional inclusion of ",(0,r.kt)("em",{parentName:"td"},"Text"),", where ",(0,r.kt)("em",{parentName:"td"},"StringChars")," may use variables introduced in ",(0,r.kt)("em",{parentName:"td"},"Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<if(Exp){> \u2026\u200b StringChars1 \u2026\u200b <} else {>  \u2026\u200b StringChars2 \u2026\u200b <}>")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional inclusion of either ",(0,r.kt)("em",{parentName:"td"},"StringChars",(0,r.kt)("sub",null,"1"))," or ",(0,r.kt)("em",{parentName:"td"},"StringChars",(0,r.kt)("sub",null,"2")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<for(Exp){>\u2026\u200b StringChars \u2026\u200b <}>")),(0,r.kt)("td",{parentName:"tr",align:null},"Iterative splicing of ",(0,r.kt)("em",{parentName:"td"},"StringChars")," into the result, where ",(0,r.kt)("em",{parentName:"td"},"StringChars")," may use variables introduced in ",(0,r.kt)("em",{parentName:"td"},"Exp"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<while(Exp){> \u2026\u200b StringChars \u2026\u200b <}>")),(0,r.kt)("td",{parentName:"tr",align:null},"Iterative splicing of ",(0,r.kt)("em",{parentName:"td"},"StringChars")," into the result, where ",(0,r.kt)("em",{parentName:"td"},"StringChars")," may use variables introduced in ",(0,r.kt)("em",{parentName:"td"},"Exp"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<do {>\u2026\u200b StringChars \u2026\u200b <} while (Exp)>")),(0,r.kt)("td",{parentName:"tr",align:null},"Iterative splicing of ",(0,r.kt)("em",{parentName:"td"},"StringChars")," into the result, where ",(0,r.kt)("em",{parentName:"td"},"StringChars")," may use variables introduced in ",(0,r.kt)("em",{parentName:"td"},"Exp"),".")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Multiline"),":")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Form"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"`",(0,r.kt)("em",{parentName:"td"},"StringChars",(0,r.kt)("sub",null,"1")),"\\","n ",(0,r.kt)("em",{parentName:"td"},"StringChars",(0,r.kt)("sub",null,"2"))," ","`"),(0,r.kt)("td",{parentName:"tr",align:null},"Strings can be multi-line without an escape or continuation marker")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"StringChars2\\n '  StringChars2")),(0,r.kt)("td",{parentName:"tr",align:null},"A margin character ",(0,r.kt)("inlineCode",{parentName:"td"},"'")," indicates where the next line starts")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"str")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The string values are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," and consist of character sequences surrounded by double quotes,\ne.g., ",(0,r.kt)("inlineCode",{parentName:"p"},'"a"')," or ",(0,r.kt)("inlineCode",{parentName:"p"},'"a\\nlong\\nstring"'),"."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Multiline"),": Strings may span more than one line. The margin character ",(0,r.kt)("inlineCode",{parentName:"p"},"'")," indicates which part of a line will be\nignored. This is useful for indenting a multi-line string with the source code that generates it."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Interpolation"),": String literals support so-called ",(0,r.kt)("em",{parentName:"p"},"string interpolation"),": inside string constants text between angle\nbrackets (",(0,r.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,r.kt)("inlineCode",{parentName:"p"},">"),") is first executed and then replaced by its string value. Various statements (if, for, while, do)\nalso return a value and can be used in this way. In the interpolation variant of these statements the block or blocks\nthat are part of the statement become arbitrary text (that may itself contain interpolations)."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Auto-indent"),": Expressions that get interpolated in a string will be auto-indented. This means that each line that\nresults from the evaluation of the expression is prefixed with the indentation level of the position of the expression\nin the current string."),(0,r.kt)("p",null,"The following operators are defined for Strings:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"String Concatenation"),": Concatenate two strings.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"String Equal"),": Equality operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"String GreaterThan"),": Greater than operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"String GreaterThanOrEqual"),": Greater than or equal operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"String LessThan"),": Less than operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"String LessThanOrEqual"),": Less than or equal operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"String NotEqual"),": Not equal operator on string values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"String Slice"),": Retrieve a slice of a string.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"String Subscription"),": Retrieve a substring via its index."))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#string"},"library functions")," available for Strings."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'N = 13;\n"The value of N is <N>";\n"The value of N*N is <N*N>";\n"The value is <(N < 10) ? 10 : N*N>";\n')),(0,r.kt)("p",null,"As you can see the string value of variables and expressions is interpolated in the result as expected. \\<br",">"," Some\nexamples of more advances string interpolation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"N is <if(N < 10){> small <} else {> large <}>";\n"N is <if(N < 10){> small <} else {> large (<N>)<}>";\n"before <for(x<-[1..5]){>a <x> b <}>after";\n')),(0,r.kt)("p",null,"multi-line string"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nprintln("hello\nthis\n  is\n    new")\n')),(0,r.kt)("p",null,"multi-line string with margin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"if (true)\n  println(\"this is\n          'what\n          '  margins\n          'are good for\n          \");\n")),(0,r.kt)("p",null,"auto indent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'str genMethod(str n) = "int <n>() {\n                       \'  return 0;\n                       \'}";\nstr genClass() = "class myClass {\n                 \'  <genMethod("myMethod")>\n                 \'}";\nprintln(genClass());\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Benefits.")),(0,r.kt)("p",null,"String interpolation enables very flexible template-based text generation as used in generators for source code, markup\nand the like."),(0,r.kt)("h5",{id:"string-concatenation"},"String Concatenation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Concatenate two strings."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 + Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 + Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Concatenates the string values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,"Note that to concatenate other types of values into a string, you can use ",(0,r.kt)("a",{parentName:"p",href:"#string"},"String")," interpolation."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abc" + "def";\n')),(0,r.kt)("h5",{id:"string-equal"},"String Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality operator on string values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abc" == "abc";\n"abc" == "defghi";\n')),(0,r.kt)("h5",{id:"string-greaterthan"},"String GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than operator on string values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the string value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is strictly lexicographically greater than the string value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abcdef" > "abc";\n"defghi" > "abcdef";\n"a" > "abc";\n')),(0,r.kt)("h5",{id:"string-greaterthanorequal"},"String GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than or equal operator on string values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the string value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is lexicographically greater than the string value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," or if both strings are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abc" >= "abc";\n"abcdef" >= "abc";\n"defghi" >= "abcdef";\n"a" >= "abc";\n')),(0,r.kt)("h5",{id:"string-lessthan"},"String LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than operator on string values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the string value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is strictly lexicographically less than the string value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abc" < "abcdef";\n"abc" < "defghi";\n"abc" < "a";\n')),(0,r.kt)("h5",{id:"string-lessthanorequal"},"String LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than or equal operator on string values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the string value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is lexicographically less than the string value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," or if both string are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abc" <= "abc";\n"abc" <= "abcdef";\n"abc" <= "defghi";\n"abc" <= "a";\n')),(0,r.kt)("h5",{id:"string-notequal"},"String NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on string values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are not identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'"abc" != "defghi";\n"abc" != "abc";\n')),(0,r.kt)("h5",{id:"string-slice"},"String Slice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a slice of a string."),(0,r.kt)("h5",{id:"exp1--exp2--exp4"},(0,r.kt)("inlineCode",{parentName:"h5"},"Exp1 [ Exp2 .. Exp4]")),(0,r.kt)("h5",{id:"exp1--exp2--exp3--exp4"},(0,r.kt)("inlineCode",{parentName:"h5"},"Exp1 [ Exp2 , Exp3 .. Exp4]")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," are optional."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp3")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp4")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 .. Exp4 ]")," or ",(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 , Exp3 .. Exp4]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A String slice is similar to a list ",(0,r.kt)("a",{parentName:"p",href:"#slice"},"List Slice")," and uses the integer values of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," to determine the ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," (",(0,r.kt)("strong",{parentName:"p"},"inclusive"),") and ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," (",(0,r.kt)("strong",{parentName:"p"},"exclusive"),") of a slice from the string value\n",(0,r.kt)("em",{parentName:"p"},"S")," of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". Negative indices count from the end of the string backwards. Using the second form, an extra\nindex ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"3")," is given that determines the index of the second element in the slice and establishes the ",(0,r.kt)("inlineCode",{parentName:"p"},"step"),"\nbetween successive elements in the slice. The default ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," is 1. If ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", the slice is\nconstructed backwards."),(0,r.kt)("p",null,"Let ",(0,r.kt)("inlineCode",{parentName:"p"},"Len")," be the length of ",(0,r.kt)("em",{parentName:"p"},"S")," and let ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"3")," and ",(0,r.kt)("em",{parentName:"p"},"N"),(0,r.kt)("sub",null,"4")," be the respective values of\nthe expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," when they are present."),(0,r.kt)("p",null,"The slice parameters ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," are determined as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"2"))," is absent, then ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = 0"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("em",{parentName:"p"},"N",(0,r.kt)("sub",null,"2"))," ",">","= 0 then ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = N2")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"begin = N2 + Len"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4"))," is absent, then ",(0,r.kt)("inlineCode",{parentName:"p"},"end = Len"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("em",{parentName:"p"},"N",(0,r.kt)("sub",null,"4"))," ",">","= 0, then ",(0,r.kt)("inlineCode",{parentName:"p"},"end = N4")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"end = N4 + Len"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"3")),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"3"))," is absent, then if ",(0,r.kt)("inlineCode",{parentName:"p"},"begin < end")," then ",(0,r.kt)("inlineCode",{parentName:"p"},"step = 1")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"step = -1"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, if ",(0,r.kt)("inlineCode",{parentName:"p"},"begin < end"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"step = N3 - begin")," else ",(0,r.kt)("inlineCode",{parentName:"p"},"step = begin - N3"),"."))))),(0,r.kt)("p",null,"Now, the constraints ",(0,r.kt)("inlineCode",{parentName:"p"},"0 \u21d0 begin < Len")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"0 < end < Len")," should hold, otherwise the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBounds")," is\nthrown."),(0,r.kt)("p",null,"The slice consists of the elements ",(0,r.kt)("inlineCode",{parentName:"p"},"S[begin]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"S[begin+step]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"S[end - step]"),". When ",(0,r.kt)("inlineCode",{parentName:"p"},"begin >= end"),", the elements are\nlisted in reverse order."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the string ",(0,r.kt)("inlineCode",{parentName:"p"},'S = "abcdefghi";')," (with size 9) as running example."),(0,r.kt)("p",null,"Here is a view on ",(0,r.kt)("em",{parentName:"p"},"L")," that will help to correlate positive and negative indices:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"i")),(0,r.kt)("th",{parentName:"tr",align:null},"0"),(0,r.kt)("th",{parentName:"tr",align:null},"1"),(0,r.kt)("th",{parentName:"tr",align:null},"2"),(0,r.kt)("th",{parentName:"tr",align:null},"3"),(0,r.kt)("th",{parentName:"tr",align:null},"4"),(0,r.kt)("th",{parentName:"tr",align:null},"5"),(0,r.kt)("th",{parentName:"tr",align:null},"6"),(0,r.kt)("th",{parentName:"tr",align:null},"7"),(0,r.kt)("th",{parentName:"tr",align:null},"8"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[i]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"a"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"b"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"c"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"d"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"e"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"f"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"g"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"h"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"i"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-i")),(0,r.kt)("td",{parentName:"tr",align:null},"-","9"),(0,r.kt)("td",{parentName:"tr",align:null},"-","8"),(0,r.kt)("td",{parentName:"tr",align:null},"-","7"),(0,r.kt)("td",{parentName:"tr",align:null},"-","6"),(0,r.kt)("td",{parentName:"tr",align:null},"-","5"),(0,r.kt)("td",{parentName:"tr",align:null},"-","4"),(0,r.kt)("td",{parentName:"tr",align:null},"-","3"),(0,r.kt)("td",{parentName:"tr",align:null},"-","2"),(0,r.kt)("td",{parentName:"tr",align:null},"-","1")))),(0,r.kt)("p",null,"Some common use cases (with ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," \u21d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"end"),"):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Slice"),(0,r.kt)("th",{parentName:"tr",align:null},"Means:"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[begin..end]")),(0,r.kt)("td",{parentName:"tr",align:null},"characters with indices ",(0,r.kt)("inlineCode",{parentName:"td"},"begin")," through ",(0,r.kt)("inlineCode",{parentName:"td"},"end-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[begin..]")),(0,r.kt)("td",{parentName:"tr",align:null},"characters with indices ",(0,r.kt)("inlineCode",{parentName:"td"},"begin")," through the rest of the string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[..end]")),(0,r.kt)("td",{parentName:"tr",align:null},"characters with indices from the beginning through ",(0,r.kt)("inlineCode",{parentName:"td"},"end-1"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[..]")),(0,r.kt)("td",{parentName:"tr",align:null},"the whole list")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[-1]")),(0,r.kt)("td",{parentName:"tr",align:null},"last element of the string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[-2..]")),(0,r.kt)("td",{parentName:"tr",align:null},"the last two characters of the string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"S[..-2]")),(0,r.kt)("td",{parentName:"tr",align:null},"all characters except the last two.")))),(0,r.kt)("p",null,"Let\u2019s put this into practice now."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'S = "abcdefghi";\n')),(0,r.kt)("p",null,"Slices with begin \\< end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S[1..3];\nS[1..];       // empty end => end of string\nS[..3];       // empty begin => first character of string\nS[..];        // both empty => whole string\n")),(0,r.kt)("p",null,"Slices with begin ",">","= end"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S[3..1];      // slice contains characters with indices 3 and 2 (in that order)\nS[3..3];      // empty slice when begin == end\n")),(0,r.kt)("p",null,"Slices with negative begin or end:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S[2..-2];     // equivalent to S[2..7]\nS[2..7];\nS[-4..-2];    // equivalent to S[5..7]\nS[5..7];\n")),(0,r.kt)("p",null,"Slices with an explicit second index:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S[1,3..6];\nS[5,3..];\n")),(0,r.kt)("p",null,"Explore error cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S[..10];\nS[1..20];\n")),(0,r.kt)("h5",{id:"string-subscription"},"String Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a substring via its index."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 ]")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 [ Exp2 ]")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"String subscription uses the integer value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," as index in the string value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),". The\nvalue of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," should be greater or equal 0 and less than the number of characters in the string. If this is\nnot the case, the exception ",(0,r.kt)("inlineCode",{parentName:"p"},"IndexOutOfBounds")," is thrown."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce a string, assign it to S and retrieve the element with index 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'S = "abc";\nS[1];\n')),(0,r.kt)("p",null,"Explore an error case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"S[5];\n")),(0,r.kt)("h3",{id:"tuple"},"Tuple"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"< Exp1, Exp2, \u2026\u200b >")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"< Exp1, Exp2, \u2026\u200b >")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"2"))),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[T1, T2, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A tuple is a sequence of elements with the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Each element in a tuple (may) have a different type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Each element of a tuple may have a label that can be used to select that element of the tuple.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Each tuple is fixed-width, i.e., has the same number of elements."))),(0,r.kt)("p",null,"Tuples are represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"tuple[T1 L1, T2 L2, \u2026\u200b]"),", where ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2"),", \u2026\u200b are arbitrary\ntypes and ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"L"),(0,r.kt)("sub",null,"2"),", \u2026\u200b are optional labels."),(0,r.kt)("p",null,"The following operators are provided for tuples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#concatenation"},"Tuple Concatenation"),": Concatenate two tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Tuple Equal"),": Equality operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fieldselection"},"Tuple FieldSelection"),": Select a field from a tuple by its field name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Tuple GreaterThan"),": Greater than operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Tuple GreaterThanOrEqual"),": Greater than or equal operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Tuple LessThan"),": Less than operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Tuple LessThanOrEqual"),": Less than or equal operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Tuple NotEqual"),": Not equal operator on tuple values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Tuple Subscription"),": Retrieve a tuple field by its index position."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'tuple[str first, str last, int age] P = <"Jo","Jones",35>;\nP.first;\nP.first = "Bo";\n')),(0,r.kt)("h5",{id:"tuple-concatenation"},"Tuple Concatenation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Concatenate two tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 + Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp_2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp_2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b, T21, T22, \u2026\u200b ]"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Returns a tuple consisting of the concatenation of the tuple elements of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<"abc", 1, 2.5> + <true, "def">;\n')),(0,r.kt)("h5",{id:"tuple-equal"},"Tuple Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equality operator on tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both tuples are identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<1, "abc", true> == <1, "abc", true>;\n')),(0,r.kt)("h5",{id:"tuple-fieldselection"},"Tuple FieldSelection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Select a field from a tuple by its field name."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp . Name")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Name")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp . Name")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T1 L1, T2 L2, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Li")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Ti"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Field selection applies to tuples with named elements. ",(0,r.kt)("em",{parentName:"p"},"Exp")," should evaluate to a tuple with field ",(0,r.kt)("em",{parentName:"p"},"Name")," and returns\nthe value of that field. ",(0,r.kt)("em",{parentName:"p"},"Name")," stands for itself and is not evaluated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'tuple[int key, str val] T = <1, "abc">;\nT.val;\n')),(0,r.kt)("h5",{id:"tuple-greaterthan"},"Tuple GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than operator on tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"both tuples are not equal, and")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the left-most element in the tuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," that differs from the corresponding element in the\ntuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is greater than that element in ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."))),(0,r.kt)("p",null,"Otherwise the result if ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<1, "def", true> > <1, "abc", true>;\n')),(0,r.kt)("h5",{id:"tuple-greaterthanorequal"},"Tuple GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than or equal operator on tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"both tuples are equal, or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the left-most element in the tuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," that differs from the corresponding element in the\ntuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is greater than that element in ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."))),(0,r.kt)("p",null,"Otherwise the result if ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<1, "abc", true> > <1, "abc", true>;\n<1, "def", true> > <1, "abc", true>;\n')),(0,r.kt)("h5",{id:"tuple-lessthan"},"Tuple LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than operator on tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"both tuples are not equal, and")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the left-most element in the tuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," that differs from the corresponding element in the\ntuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is less than that element in ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."))),(0,r.kt)("p",null,"Otherwise the result if ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<1, "abc", true> < <1, "def", true>;\n')),(0,r.kt)("h5",{id:"tuple-lessthanorequal"},"Tuple LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than or equal operator on tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"both tuples are equal, or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"the left-most element in the tuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"1"))," that differs from the corresponding element in the\ntuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is less than that element in ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),"."))),(0,r.kt)("p",null,"Otherwise the result if ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<1, "abc", true> <= <1, "abc", true>;\n<1, "abc", true> <= <1, "def", true>;\n')),(0,r.kt)("h5",{id:"tuple-notequal"},"Tuple NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on tuple values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T11, T12, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tuple[ T21, T22, \u2026\u200b ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both tuples are not identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<1, "abc", true> != <1, "abc">;\n<1, "abc", true> != <1, "abc", true>;\n')),(0,r.kt)("h5",{id:"tuple-subscription"},"Tuple Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Retrieve a tuple field by its index position."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Exp2 ]")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Subscription retrieves the tuple element with index ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," from the tuple value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce a tuple, assign it to T and retrieve the element with index 0:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T = <"mon", 1>;\nT[0];\n')),(0,r.kt)("h3",{id:"value"},"Value"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"value")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Value stands for all possible Rascal values and is represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),". This type is a container for all\nother types and does not have any values itself."),(0,r.kt)("p",null,"The following operators are provided for values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#conditional"},"Value Conditional"),": Conditional expression on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#equal"},"Value Equal"),": Equal operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthan"},"Value GreaterThan"),": Greater than operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#greaterthanorequal"},"Value GreaterThanOrEqual"),": Greater than or equal operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthan"},"Value LessThan"),": Less than operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#lessthanorequal"},"Value LessThanOrEqual"),": Less than or equal operator on values.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#notequal"},"Value NotEqual"),": Not equal operator on values."))),(0,r.kt)("h5",{id:"value-conditional"},"Value Conditional"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Conditional expression on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 ? Exp2 : Exp3")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp3")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 ? Exp2 : Exp3")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T3")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lub(T2,T3)"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"3"),"\notherwise. The result type is the ",(0,r.kt)("em",{parentName:"p"},"least upper bound")," (also known as ",(0,r.kt)("inlineCode",{parentName:"p"},"lub"),", see ",(0,r.kt)("a",{parentName:"p",href:"#staticTyping"},"Static\nTyping"),") of the types of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," and ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"3"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'( 3 > 2 ) ? 30 : 40;\n( 3 < 2 ) ? "abc" : {3, 4};\n')),(0,r.kt)("h5",{id:"value-equal"},"Value Equal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Equal operator on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 == Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 == Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Introduce two variables ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," and force them to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value X = "abc";\nvalue Y = "abc";\nvalue Z = 3.14;\n')),(0,r.kt)("p",null,"Now compare ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," for equality:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X == Y;\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X == Z;\n")),(0,r.kt)("h5",{id:"value-greaterthan"},"Value GreaterThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than operator on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 > Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 > Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"By brute force, a total less than operator between two values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"2")," of arbitrary types\n",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2")," is defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the types ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"1"))," and ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"2"))," can be compared then ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"1"))," less than ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"2"))," is\nused.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise values are ordered according their type name, for instance, ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," is\nsmaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"rel"),"."))),(0,r.kt)("p",null,"Greater than yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is strictly less than (according to the ordering defined\nabove) the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce two variables ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," and force them to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value X = "def";\nvalue Y = "abc";\nvalue Z = 3.14;\n')),(0,r.kt)("p",null,"Now compare ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Y"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X > Y;\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X > Z;\n")),(0,r.kt)("h5",{id:"value-greaterthanorequal"},"Value GreaterThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Greater than or equal operator on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 >= Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 >= Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"By brute force, a total less than operator between two values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"2")," of arbitrary types\n",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2")," is defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the types ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"1"))," and ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"2"))," can be compared then ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"1"))," less than ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"2"))," is\nused.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise values are ordered according their type name, for instance, ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," is\nsmaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"rel"),"."))),(0,r.kt)("p",null,"Greater than or equal yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is strictly less than (according to the ordering\ndefined above) the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," or if both values are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce two variables ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," and force them to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value X = "def";\nvalue Y = "abc";\nvalue Z = 3.14;\n')),(0,r.kt)("p",null,"Now compare ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Y"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X >= Y;\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X >= Z;\n")),(0,r.kt)("h5",{id:"value-lessthan"},"Value LessThan"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than operator on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 < Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 < Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"By brute force, a total less than operator between two values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"2")," of arbitrary types\n",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2")," is defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the types ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"1"))," and ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"2"))," can be compared then ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"1"))," less than ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"2"))," is\nused.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise values are ordered according their type name, for instance, ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," is\nsmaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"rel"),"."))),(0,r.kt)("p",null,"Less than yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is strictly less than (according to the ordering defined\nabove) the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce two variables ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," and force them to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value X = "abc";\nvalue Y = "def";\nvalue Z = 3.14;\n')),(0,r.kt)("p",null,"Now compare ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Y"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X < Y;\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X < Z;\n")),(0,r.kt)("h5",{id:"value-lessthanorequal"},"Value LessThanOrEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Less than or equal operator on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 \u21d0 Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 \u21d0 Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"By brute force, a total less than operator between two values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"2")," of arbitrary types\n",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"2")," is defined:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the types ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"1"))," and ",(0,r.kt)("em",{parentName:"p"},"T",(0,r.kt)("sub",null,"2"))," can be compared then ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"1"))," less than ",(0,r.kt)("em",{parentName:"p"},"V",(0,r.kt)("sub",null,"2"))," is\nused.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise values are ordered according their type name, for instance, ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," is\nsmaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"rel"),"."))),(0,r.kt)("p",null,"Less than or equal yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is strictly less than (according to the ordering\ndefined above) the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," or if both values are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce two variables ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," and force them to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value X = "abc";\nvalue Y = "def";\nvalue Z = 3.14;\n')),(0,r.kt)("p",null,"Now compare ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Y"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X <= Y;\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X <= Z;\n")),(0,r.kt)("h5",{id:"value-notequal"},"Value NotEqual"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Not equal operator on values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 != Exp2")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1 != Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Yields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if both arguments are not identical and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Introduce two variables ",(0,r.kt)("inlineCode",{parentName:"p"},"X"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z")," and force them to be of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value X = "abc";\nvalue Y = "abc";\nvalue Z = 3.14;\n')),(0,r.kt)("p",null,"Now compare ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Y")," for inequality:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X != Y;\n")),(0,r.kt)("p",null,"and ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Z"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"X != Z;\n")),(0,r.kt)("h3",{id:"void"},"Void"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"void"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"void")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Void stands for ",(0,r.kt)("em",{parentName:"p"},"nothing")," and is represented by the type ",(0,r.kt)("inlineCode",{parentName:"p"},"void"),". It is a type without any values."),(0,r.kt)("h3",{id:"operators"},"Operators"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The Rascal operators."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"operator expression")," consists of an operator and one or more operands. The evaluation order of the operands depends\non the operator. The operator is applied to the operands and the resulting value (or values in some cases) is the result\nof the operator expression."),(0,r.kt)("p",null,"All operators are summarized in the following table. They are listed from highest precedence to lowest precedence. In\nother words, operators listed earlier in the table bind stronger."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"See"),(0,r.kt)("th",{parentName:"tr",align:null},"Short Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp . Name")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#fieldselection"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#fieldselection"},"DateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#fieldselection"},"Tuple"),", ",(0,r.kt)("a",{parentName:"td",href:"#fieldselection.Relation"},"???"),","),(0,r.kt)("td",{parentName:"tr",align:null},"Select named field from structured value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 [ Name = Exp2 ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#fieldAssignment"},"???")),(0,r.kt)("td",{parentName:"tr",align:null},"Change value of named field of structured value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp < field1, \u2026\u200b >")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#fieldProjection"},"???")),(0,r.kt)("td",{parentName:"tr",align:null},"Select fields from relation or structured value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp is Name")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#parseTree"},"???"),", ",(0,r.kt)("a",{parentName:"td",href:"#concretesyntax"},"Concrete Syntax"),", ",(0,r.kt)("a",{parentName:"td",href:"#ADT"},"Algebraic Data Type")),(0,r.kt)("td",{parentName:"tr",align:null},"Returns true if and only if the constructor name of the value produced by ",(0,r.kt)("em",{parentName:"td"},"Exp")," is equal to ",(0,r.kt)("em",{parentName:"td"},"Name"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp has Name")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#parseTree"},"???"),", ",(0,r.kt)("a",{parentName:"td",href:"#concretesyntax"},"Concrete Syntax"),", ",(0,r.kt)("a",{parentName:"td",href:"#ADT"},"Algebraic Data Type")),(0,r.kt)("td",{parentName:"tr",align:null},"Returns true if and only if the constructor (node or parse tree) of the value produced by ",(0,r.kt)("em",{parentName:"td"},"Exp")," has any field labeled ",(0,r.kt)("em",{parentName:"td"},"Name"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 [ Exp2 , Exp3, \u2026\u200b. ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#subscription"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#subscription"},"Map"),", ",(0,r.kt)("a",{parentName:"td",href:"#subscription"},"Tuple"),", ",(0,r.kt)("a",{parentName:"td",href:"#subscription"},"Relation")),(0,r.kt)("td",{parentName:"tr",align:null},"Retrieve values for given index/key from list, map, tuple or relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 [ Exp2 , Exp3 .. Exp4 ]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#list-Slice"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#slice"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#slice"},"Node")),(0,r.kt)("td",{parentName:"tr",align:null},"Retrieve a slice from a list, string, or node.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp?")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#isdefined"},"Boolean")),(0,r.kt)("td",{parentName:"tr",align:null},"Test whether an expression has a defined value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#negation"},"Boolean")),(0,r.kt)("td",{parentName:"tr",align:null},"Negate a Boolean value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"- Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#negation"},"Number")),(0,r.kt)("td",{parentName:"tr",align:null},"Negation of numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp +")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#transitiveclosure"},"Relation"),", ",(0,r.kt)("a",{parentName:"td",href:"#transitiveclosure"},"ListRelation"),","),(0,r.kt)("td",{parentName:"tr",align:null},"Transitive closure on relation or list relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp *")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#reflexivetransitiveclosure"},"Relation"),", ",(0,r.kt)("a",{parentName:"td",href:"#reflexivetransitiveclosure"},"ListRelation")),(0,r.kt)("td",{parentName:"tr",align:null},"Reflexive transitive closure on relation or list relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp @ Name")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#selection"},"???")),(0,r.kt)("td",{parentName:"tr",align:null},"Value of annotation ",(0,r.kt)("em",{parentName:"td"},"Name")," of ",(0,r.kt)("em",{parentName:"td"},"Exp"),"'s value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 [@ Name = Exp2]")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#replacement"},"???")),(0,r.kt)("td",{parentName:"tr",align:null},"Assign value of ",(0,r.kt)("em",{parentName:"td"},"Exp"),(0,r.kt)("sub",null,"2")," to annotation ",(0,r.kt)("em",{parentName:"td"},"Name")," of ",(0,r.kt)("em",{parentName:"td"},"Exp"),(0,r.kt)("sub",null,"1"),"'s value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 o Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#composition"},"Relation"),", ",(0,r.kt)("a",{parentName:"td",href:"#composition"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"Exp"),(0,r.kt)("sub",null,"1")," and ",(0,r.kt)("em",{parentName:"td"},"Exp"),(0,r.kt)("sub",null,"2"),' should evaluate to a relation or map; return their composition. Note: the letter "o" is thus a keyword')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 / Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#division"},"Number")),(0,r.kt)("td",{parentName:"tr",align:null},"Divide two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 % Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#remainder"},"Number")),(0,r.kt)("td",{parentName:"tr",align:null},"Remainder on numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 * Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#multiplication"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#product"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#product"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#cartesianproduct"},"Relation")),(0,r.kt)("td",{parentName:"tr",align:null},"Multiply numbers; product of list, set, or relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 & Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#intersection"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#intersection"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#intersection"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Intersection of list, set (including relation), or map")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 + Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#addition"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#concatenation"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#concatenation"},"List Concatenation"),", ",(0,r.kt)("a",{parentName:"td",href:"#insert"},"List Insert"),",",(0,r.kt)("a",{parentName:"td",href:"#append"},"List Append"),", ",(0,r.kt)("a",{parentName:"td",href:"#concatenation"},"Tuple Concatenation"),", ",(0,r.kt)("a",{parentName:"td",href:"#union"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#union"},"Map"),", ",(0,r.kt)("a",{parentName:"td",href:"#addsegment"},"Location")),(0,r.kt)("td",{parentName:"tr",align:null},"Add numbers; concatenate string, list or tuple; union on set (including relation), or map; concatenate location and string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 - Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#subtraction"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#difference"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#difference"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#difference"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Subtract numbers; difference of list, set (including relation), or map")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 join Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#join"},"Relation")),(0,r.kt)("td",{parentName:"tr",align:null},"Join on relation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 in Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#in"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#in"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#in"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Membership test for element in list, map, set (including relation)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 notin Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#notin"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#notin"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#notin"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Negated membership test for element in list, map, set (including relation)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 \u21d0 Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#lessthanorequal"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#lessthanorequal"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#lessthanorequal"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#lessthanorequal"},"DateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#sublist"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#subset"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#submap"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Less than or equal on all values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 < Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#lessthan"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#lessthan"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#lessthan"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#lessthan"},"dateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#strictsublist"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#strictsubset"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#strictsubmap"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Less than on all values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 >= Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#greaterthanorequal"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#greaterthanorequal"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#greaterthanorequal"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#greaterthanorequal"},"DateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#superlist"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#superset"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#supermap"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Greater than or equal on all values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 > Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#greaterthan"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#greaterthan"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#greaterthan"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#greaterthan"},"DateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#strictsuperlist"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#strictsuperset"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#strictsupermap"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Greater than on all values.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Pat := Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#match"},"Boolean Match")),(0,r.kt)("td",{parentName:"tr",align:null},"Pattern matches value of expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Pat !:= Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#nomatch"},"Boolean NoMatch")),(0,r.kt)("td",{parentName:"tr",align:null},"Pattern does not match value of expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 == Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#equal"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#equal"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#equal"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#equal"},"DateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#equal"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#equal"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#equal"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Equality on all values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 != Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#notequal"},"Number"),", ",(0,r.kt)("a",{parentName:"td",href:"#notequal"},"String"),", ",(0,r.kt)("a",{parentName:"td",href:"#notequal"},"Location"),", ",(0,r.kt)("a",{parentName:"td",href:"#notequal"},"DateTime"),", ",(0,r.kt)("a",{parentName:"td",href:"#notequal"},"List"),", ",(0,r.kt)("a",{parentName:"td",href:"#notequal"},"Set"),", ",(0,r.kt)("a",{parentName:"td",href:"#notequal"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},"Inequality on all values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 ? Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#ifdefinedelse"},"Boolean IfDefinedElse")),(0,r.kt)("td",{parentName:"tr",align:null},"Value of expression when it is defined, otherwise alternative value")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 ? Exp2 : Exp3")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#conditional"},"Value Conditional")),(0,r.kt)("td",{parentName:"tr",align:null},"Conditional expression for all types")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 =\u21d2 Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#implication"},"Boolean Implication")),(0,r.kt)("td",{parentName:"tr",align:null},"Implication on Boolean values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 \u21d0\u21d2 Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#equivalence"},"Boolean Equivalence")),(0,r.kt)("td",{parentName:"tr",align:null},"Equivalence on Boolean values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 && Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#and"},"Boolean And")),(0,r.kt)("td",{parentName:"tr",align:null},"And on Boolean values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Exp1 \\|\\| Exp2")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#or"},"Boolean Or")),(0,r.kt)("td",{parentName:"tr",align:null},"Or on Boolean values")))),(0,r.kt)("h3",{id:"field-assignment"},"Field Assignment"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assignment to a field of a tuple or datatype."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1 [ Name = Exp2 ]")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," should evaluate to a tuple or datatype with a field ",(0,r.kt)("em",{parentName:"p"},"Name"),"; assign the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," to\nthat field"),(0,r.kt)("p",null,"Field assignment applies to all values that have named components like tuples and relations with named elements, data\ntypes, and locations. Field assignment returns a new value in which the named component has been replaced by a new\nvalue. ",(0,r.kt)("em",{parentName:"p"},"Name")," stands for itself and is not evaluated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'tuple[int key, str val] T = <1, "abc">;\nT[val = "def"];\n T;\n')),(0,r.kt)("p",null,"Observe that field assignment creates a new value with an updated field. The old value remains unchanged as can be seen\nfrom the unchanged value of T in the above example."),(0,r.kt)("h3",{id:"field-projection"},"Field Projection"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Projection of tuple."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp < Field1, Field2 \u2026\u200b >")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Exp")," should evaluate to a tuple or relation, and ",(0,r.kt)("em",{parentName:"p"},"Field"),(0,r.kt)("sub",null,"i")," should be a field name or an integer constant that\nrefers to elements in the order in which they occur in the original value (counting from 0)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Suppose we have a relation with traffic information that records the name of the day, the day number, and the length of\nthe traffic jams at that day."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rel[str day, int daynum, int length] Traffic =\n{<"mon", 1, 100>, <"tue", 2, 150>, <"wed", 3, 125>,\n <"thur", 4, 110>, <"fri", 5, 90>};\nTraffic<length,daynum>;\nTraffic<2,day>;\n')),(0,r.kt)("p",null,"Field projection thus selects parts from a larger value that has a fixed number of parts. The selection is based on\nposition and not on value and can be used to completely reorder or remove the parts of a larger value."),(0,r.kt)("h3",{id:"call"},"Call"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Function call."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Name ( Exp1, Exp2, \u2026\u200b )")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")),(0,r.kt)("th",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Name ( Exp1, Exp2, \u2026\u200b )")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T1")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T2")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2026\u200b"),(0,r.kt)("td",{parentName:"tr",align:null},"Determined by ",(0,r.kt)("em",{parentName:"td"},"Name"),", ",(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"i"))," and function declarations")))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"First, the actual parameter expressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"i")," are evaluated resulting in values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"i"),". Based on\n",(0,r.kt)("em",{parentName:"p"},"Name")," and the argument types ",(0,r.kt)("em",{parentName:"p"},"T"),(0,r.kt)("sub",null,"i"),", the identity of the function to be called is determined."),(0,r.kt)("p",null,"The values ",(0,r.kt)("em",{parentName:"p"},"V"),(0,r.kt)("sub",null,"i")," are bound to the formal parameter names of the declared functions and the function body is\nexecuted. The value returned by the function is used as value of the function call."),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"constructor call")," has identical syntax to that of a function call, see ",(0,r.kt)("a",{parentName:"p",href:"#constructor"},"Constructor"),","),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration")," for more details about function declarations."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"Describe keyword parameters.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"First declare a function ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," with argument ",(0,r.kt)("em",{parentName:"p"},"n")," that returns ",(0,r.kt)("em",{parentName:"p"},"n^2"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int square(int n) { return n * n; }\n")),(0,r.kt)("p",null,"Next call ",(0,r.kt)("inlineCode",{parentName:"p"},"square"),". This results in the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Based on the name ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," and the int argument 12 we identify the function to be called (= the function ",(0,r.kt)("inlineCode",{parentName:"p"},"square")," we\njust defined).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Compute the value of the actual parameter (= 12).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Bind the formal parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," to the actual value 12.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Execute the body of ",(0,r.kt)("inlineCode",{parentName:"p"},"square"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The return value of square is the vale of the call:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"square(12);\n")),(0,r.kt)("h3",{id:"comprehensions"},"Comprehensions"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Comprehensions provide a concise notation to conditionally generate new values."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Comprehensions are defined for the following types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"list"),", see ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"List Comprehension"),",")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"set"),", see ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Set Comprehension"),",")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"map"),", see ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Map Comprehension"),"."))),(0,r.kt)("p",null,"The syntax varies slightly for each type, but comprehensions have the following common elements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("em",{parentName:"p"},"generator")," can come in two flavours:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"an ",(0,r.kt)("em",{parentName:"p"},"enumerator")," that generates all the values in some subject value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("em",{parentName:"p"},"filter")," that performs an arbitrary test on previously generated values.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"One or more ",(0,r.kt)("em",{parentName:"p"},"contributing expressions")," that are added to the list, set or map that is being constructed."))),(0,r.kt)("p",null,"The contributing expressions are evaluated for all possible values of the enumerators that are not excluded by a test.\nWhen a filter fails, execution continues with the preceding enumerator (if any)."),(0,r.kt)("p",null,"Each enumerator may introduce new variables that can be used in subsequent generators as well as in the contributing\nexpressions. A generator can use the variables introduced by preceding generators."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"A list comprehension:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[ 3 * X | int X <- [1 .. 10] ];\n")),(0,r.kt)("p",null,"A list comprehension with a filter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[ 3 * X | int X <- [1 .. 10], X > 5];\n")),(0,r.kt)("p",null,"A list comprehension with multiple contributing expressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[X, X * X | int X <- [1, 2, 3, 4, 5], X >= 3];\n")),(0,r.kt)("p",null,"A set comprehension with a filter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{X | int X <- {1, 2, 3, 4, 5}, X >= 3};\n")),(0,r.kt)("p",null,"A set comprehension that constructs a relation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{<X, Y> | int X <- {1, 2, 3}, int Y <- {2, 3, 4}, X >= Y};\n{<Y, X> | <int X, int Y> <- {<1,10>, <2,20>}};\n")),(0,r.kt)("p",null,"Introduce a map of ",(0,r.kt)("inlineCode",{parentName:"p"},"fruits")," and use a map comprehension to filter fruits with an associated value larger than 10:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'fruits = ("pear" : 1, "apple" : 3, "banana" : 0, "berry" : 25, "orange": 35);\n(fruit : fruits[fruit] | fruit <- fruits, fruits[fruit] > 10);\n')),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"List Comprehension"),", ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Set Comprehension"),", or ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Map\nComprehension")," for more examples."),(0,r.kt)("h3",{id:"enumerator"},"Enumerator"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Enumerate all values in a given subject value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Pattern \u2190 Exp")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An enumerator generates all the values in a given subject value. For elementary types (",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"real"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"num"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"loc"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"datetime"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"str"),") this is just a singleton. For composite types (",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tuple"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"rel"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"node"),")\nthe values of their elements, respectively, their direct children are enumerated. An enumerator is evaluated as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," is evaluated and may have an arbitrary value ",(0,r.kt)("em",{parentName:"p"},"V"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The elements of ",(0,r.kt)("em",{parentName:"p"},"V")," are enumerated one by one.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Each element value is matched against the pattern ",(0,r.kt)("em",{parentName:"p"},"Pattern"),". There are two cases:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The match succeeds, any variables in ",(0,r.kt)("em",{parentName:"p"},"Pattern")," are bound, and the next generator in the comprehension is\nevaluated. The variables that are introduced by an enumerator are only available to generators that appear later\n(i.e., to the right) in the comprehension. When this enumerator is the last generator in the comprehension, the\ncontributing expressions of the comprehension are evaluated.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The match fails, no variables are bound. If ",(0,r.kt)("em",{parentName:"p"},"V")," has more elements, a next element is tried. Otherwise, a\nprevious generator (i.e., to the left) is tried. If this enumerator is the first generator in the comprehension,\nthe evaluation of the comprehension is complete."))))),(0,r.kt)("p",null,"Type information is used to check the validity of an enumerator and guard you against mistakes. An impossible enumerator\nlike"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'int N <- {"apples", "oranges"}\n')),(0,r.kt)("p",null,"will be flagged as an error since the pattern can never match."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here are some examples of enumerators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"int N \u2190 {1, 2, 3, 4, 5}"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"str K \u2190 KEYWORDS"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"KEYWORDS")," should evaluate to a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"set[str]"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'<str K, int N> \u2190 {<"a",10>, <"b",20>, <"c",30>}'),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"<str K, int N> \u2190 FREQUENCIES"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"FREQUENCIES")," should evaluate to a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"rel[str,int]"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"<str K, 10> \u2190 FREQUENCIES"),", will only generate pairs with ",(0,r.kt)("inlineCode",{parentName:"p"},"10")," as second element.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"int N \u2190 17"),", will only generate the value ",(0,r.kt)("inlineCode",{parentName:"p"},"17"),"."))),(0,r.kt)("p",null,"Here are examples of enumerators in action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'[ N * N | int N <- [1, 2, 3, 4, 5] ];\n{<N, K> | <str K, int N> <- {<"a",10>, <"b",20>, <"c",30>}};\n')),(0,r.kt)("h3",{id:"filter"},"Filter"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Filter values in a ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"List Comprehension"),"]",", ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Set Comprehension")," or ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"Map\nComprehension"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A filter is a boolean-valued expression. If the evaluation of the filter gives ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," this indicates that the current\ncombination of generated values up to this filter is still desired and execution continues with subsequent generators.\nIf the evaluation gives ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," this indicates that the current combination of values is undesired, and that another\ncombination should be tried by going back to the previous generator."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Adding a filter to a comprehension, may restrict the values that are included in the result of the comprehension:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[ X * X | int X <- [1, 2, 3, 4, 5, 6] ];\n[ X * X | int X <- [1, 2, 3, 4, 5, 6], X % 3 == 0 ];\n")),(0,r.kt)("p",null,"Filters can also be applied to values produced by several generators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[<X, Y> | int X <- [0 .. 10], int Y <- [0 .. 10], X + Y == 10]\n")),(0,r.kt)("h3",{id:"concrete-syntax"},"Concrete Syntax"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Concrete syntax is a notation for patterns that match parse trees and expressions that generate them."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"(Nonterminal) `sentence`"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"`"," ",(0,r.kt)("inlineCode",{parentName:"p"},"sentence")," ","`"))),(0,r.kt)("p",null,"where each sentence is a string over the language generated from ",(0,r.kt)("inlineCode",{parentName:"p"},"Nonterminal"),". This language is extended in the\nfollowing way. Each non-terminal reachable ",(0,r.kt)("inlineCode",{parentName:"p"},"X")," from ",(0,r.kt)("em",{parentName:"p"},"Non"),"-terminal has an added alternative to allow nested Rascal\n",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns")," inside of concrete syntax fragments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'syntax X = "<" Pattern p ">";'))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A concrete syntax fragment allows the programmer to write patterns and expressions in the language that is currently\nanalyzed, transformed or generated. The ",(0,r.kt)("a",{parentName:"p",href:"#concretesyntax"},"Concrete Syntax")," feature is derived from ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),"s. For any non-terminal defined in a ",(0,r.kt)("a",{parentName:"p",href:"#definition"},"Syntax\nDefinition"),", you may use ",(0,r.kt)("a",{parentName:"p",href:"#concretesyntax"},"Concrete Syntax")," to match or\ngenerate its parse trees."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Easy notation for complex structures")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Since Rascal currently has no type-checker, the disambiguation of concrete syntax fragments is done heuristically\nwhich may lead to surprises.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The disambiguation of embedded concrete syntax fragments may change in the near future."))),(0,r.kt)("h3",{id:"reducer"},"Reducer"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Reduce generated values to a single value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"( InitExp | RedExp | Gen1, Gen2, \u2026\u200b )")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A reducer resembles the ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Fold_(higher-order_function)"},"fold")," function found in most\nfunctional languages."),(0,r.kt)("p",null,"A reducer is equivalent to the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"it = InitExp; \nfor(Gen1, Gen2, ... ) \n    it = RedExp; \nit; \n")),(0,r.kt)("p",null,"and is executed as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A fresh variable ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," is initialized with ",(0,r.kt)("em",{parentName:"p"},"InitExp"),". We call the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," since we use ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," to initialize the\nreducer, to make changes to ",(0,r.kt)("inlineCode",{parentName:"p"},"it"),", and to return ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," as result.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A for loop iterates over all values produced by the generators ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Gen2"),", \u2026\u200b .")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In the body of the loop, variable ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," is updated to reflect a new reduced value. Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," itself and\nvariables introduced in ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"1"),", ",(0,r.kt)("em",{parentName:"p"},"Gen"),(0,r.kt)("sub",null,"2"),", \u2026\u200b may occur in ",(0,r.kt)("em",{parentName:"p"},"RedExp"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The value of ",(0,r.kt)("inlineCode",{parentName:"p"},"it")," is the result of the reducer."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [1, 3, 5, 7];\n(0 | it + e | int e <- L);\n(1 | it * e | int e <- L);\n")),(0,r.kt)("h3",{id:"statement-as-expression"},"Statement as Expression"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Statements that have a value and can be used as expressions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Several forms of statements produce a value and can be used as expression. This is further explained in the sections for\nthe relevant statements, see ",(0,r.kt)("a",{parentName:"p",href:"#if"},"If"),", ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," and\n",(0,r.kt)("a",{parentName:"p",href:"#for"},"For"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"It is likely that the design of Rascal will evolve into completely merging expressions and statements."),(0,r.kt)("h3",{id:"visit"},"Visit"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Visit the elements in a tree or value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Strategy visit ( Exp ) {\ncase PatternWithAction1;\ncase PatternWithAction2;\n...\ndefault: ...\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Visiting, recursively traversing, the nodes in a deeply nested data-structure is a very common task in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/WhyRascal#easy"},"EASY"),"\ndomain. In many cases (but certainly not all) this data-structure is a syntax tree of some source code file and the\nnodes correspond to expressions or statements."),(0,r.kt)("p",null,"The visit expression/statement allows to focus on the points of interest in the data-structure while automating the\nsearch over the other parts for the programmer."),(0,r.kt)("p",null,"Computing metrics or refactoring are examples of tasks that require a tree visit. There are three frequently occurring\nscenarios:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Accumulator: traverse the tree and collect information (fold).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Transformer: traverse the tree and transform it into another tree (map).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Accumulating Transformer: traverse the tree, collect information and also transform the tree."))),(0,r.kt)("p",null,"The visit expression in Rascal can accommodate all these (and more) use cases."),(0,r.kt)("p",null,"Given a subject term (the current value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),") and a list of cases (consisting of a sequence of\n",(0,r.kt)("a",{parentName:"p",href:"#pattern-with-Action"},"???"),"s, it traverses the term. Depending on the precise actions it may perform replacement\n(mimicking a transformer), update local variables (mimicking an accumulator) or a combination of these two (accumulating\ntransformer). If ",(0,r.kt)("strong",{parentName:"p"},"any")," of the actions contains an ",(0,r.kt)("a",{parentName:"p",href:"#insert"},"Insert")," statement, the value of the visit\nexpression is a new value that is obtained by successive insertions in the subject term by executing one or more cases.\nOtherwise, the original value of the subject term is returned."),(0,r.kt)("p",null,"The visit expression is optionally preceded by one of the following strategy indications that determine the traversal\norder of the subject:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"top-down"),": visit the subject from root to leaves.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"top-down-break"),": visit the subject from root to leaves, but stop at the current path when a case matches.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bottom-up"),": visit the subject from leaves to root (this is the default).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bottom-up-break"),": visit the subject from leaves to root, but stop at the current path when a case matches.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"innermost"),": repeat a bottom-up traversal as long as a case matches.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"outermost"),": repeat a top-down traversal as long as a case matches."))),(0,r.kt)("p",null,"The execution of the cases has the following effect:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A PatternWithAction of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern \u21d2 Exp")," replaces the current subtree of the subject by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),".\nNote that a copy of the subject is created at the start of the visit statement and all replacements are made in this\ncopy. As a consequence, modifications made during the visit cannot influence matches later on. The modified copy of\nthe subject is ultimately returned by the visit expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A PatternWithAction of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern : Statement")," executes ",(0,r.kt)("inlineCode",{parentName:"p"},"Statement")," and this should lead to one of the\nfollowing:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Execution of an Insert statement of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"insert Exp2"),". The value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," replaces the subtree\nof the subject that is currently being visited. Once again, this modification takes place in a copy of the\noriginal subject (see above). Note that:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An insert statement may only occur in a PatternWithAction in a visit expression or a rule.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Pattern \u21d2 Exp")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern : insert Exp;"),".")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Execution of a ",(0,r.kt)("a",{parentName:"p",href:"#fail"},"Fail")," statement: the next case is tried.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Execution of a ",(0,r.kt)("a",{parentName:"p",href:"#return"},"Return")," statement that returns a value from the enclosing function."))))),(0,r.kt)("p",null,"The precise behaviour of the visit expression depends on the type of the subject:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For type node or ADT, all nodes of the tree are visited (in the order determined by the strategy). Concrete patterns\nand abstract patterns directly match tree nodes. Regular expression patterns match only values of type string.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For other structured types (list, set, map, tuple, rel), the elements of the structured type are visited and matched\nagainst the cases. When inserts are made, a new structured value is created. In these cases a strategy does not have\nany effect."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Visit a value and increment a counter for pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"leaf(int N)")," matches:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"visit(t) {\n     case leaf(int N): c = c + N;\n   };\n")),(0,r.kt)("p",null,"Replace all values that match the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"red(l, r)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"visit(t) {\n     case red(l, r) => green(l, r)\n   };\n")),(0,r.kt)("p",null,"Do a bottom-up visit of an expression and apply the function ",(0,r.kt)("inlineCode",{parentName:"p"},"simp")," to each subexpression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"bottom-up visit(e){\n           case Exp e1 => simp(e1)\n         }\n")),(0,r.kt)("p",null,"More examples can, for instance, be found in Recipes, see ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#ColoredTrees"},"ColoredTrees"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#WordReplacement"},"WordReplacement"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#CommonCountConstructors"},"CountConstructors"),", and\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#Derivative"},"Derivative"),"."),(0,r.kt)("h3",{id:"pattern-with-action"},"Pattern With Action"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A pattern with an associated action that is executed on a successful match."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Pattern \u21d2 Exp"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Pattern: Statement")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Patterns can be used in various contexts, but a common context is a PatternWithAction, which in its turn, may be used in\nvarious statements such ",(0,r.kt)("a",{parentName:"p",href:"#switch"},"Switch")," and ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit"),"."),(0,r.kt)("p",null,"There are two variants as listed above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When the subject matches ",(0,r.kt)("em",{parentName:"p"},"Pattern"),", the expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," is evaluated and the subject is replaced with the result.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When the subject matches Pat, the Statement is executed. More statements can be executed by including them in a\n",(0,r.kt)("a",{parentName:"p",href:"#block"},"Block"),"."))),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"#switch"},"Switch")," statements, only the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern : Statement")," is allowed. When the subject matches\n",(0,r.kt)("em",{parentName:"p"},"Pattern"),", the ",(0,r.kt)("em",{parentName:"p"},"Statement")," is executed and the execution of the switch statement is complete. However, when a fail\nstatement is executed in ",(0,r.kt)("em",{parentName:"p"},"Statement")," further alternatives of ",(0,r.kt)("em",{parentName:"p"},"Pattern")," are tried. If no alternatives remain,\nPatternWithAction as a whole fails and subsequent cases of the switch statement are tried."),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," expressions, the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern \u21d2 Exp")," describes subtree replacement: the current subtree\nof the subject of the visit expression is replaced by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),". The form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern : Statement")," is as described\nfor switch statements, with the addition that execution of an ",(0,r.kt)("a",{parentName:"p",href:"#insert"},"Insert")," statement will replace the\ncurrent subtree. After both success or failure of the PatternWithAction, the traversal of the subject continues."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Two examples of variant 1 (replacement):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"case red(CTree l, CTree r) => red(r,l)\ncase red(l, r) => green(l, r)\n")),(0,r.kt)("p",null,"Three examples of variant 2 (Statement):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'case /Leila/: println("The topic is Starwars");\ncase red(_, _):    println("A red root node");\ncase red(_,_): c = c + 1;\n')),(0,r.kt)("p",null,"The action may also be a ",(0,r.kt)("a",{parentName:"p",href:"#block"},"Block"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'case red(_,_): { c = c + 1; println("c = <c>"); }\n')),(0,r.kt)("h2",{id:"statements"},"Statements"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"All Rascal statements."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The following statements are available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#append"},"Append"),": Append an element to the list value produced by various loop statements.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#assert"},"Assert"),": An executable assertion.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#assignment"},"Assignment"),": Assign a value to a variable or more complex data structure."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#annotation"},"Annotation"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#constructor"},"Constructor"),": Assign to constructor.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#field"},"Field"),": Assign to a field of a tuple, relation or datatype.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#isdefined"},"IsDefined"),": Assign but replace if value is not defined.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#multiple"},"Multiple"),": Assign to multiple assignables.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"Slice"),": Assign to a slice of a list or string.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Subscription"),": Assign a single element of a structured value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable"),": Assign to a variable.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#block"},"Block"),": Group statements into a block.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#break"},"Break"),": End the execution of a while, do or for loop.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#continue"},"Continue"),": Continue with the next iteration of while, do or for loop.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#do"},"Do"),": Repeat statements while condition holds.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#fail"},"Fail"),": Let the current alternative of a pattern match fail.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#for"},"For"),": For loop.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#if"},"If"),": Conditional statement.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#insert"},"Insert"),": Insert a value in a tree during a ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#return"},"Return"),": Return a value as result of a ","[","Function","]",".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#solve"},"Solve"),": Solve a set of equalities by fixed-point iteration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#switch"},"Switch"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#test"},"Test"),": Test statement (",(0,r.kt)("em",{parentName:"p"},"deprecated"),").")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#throw"},"Throw"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#try-catch"},"Try Catch"),": Try to execute a statement and catch resulting exceptions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),": While loop."))),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Statement Types",src:a(7426).Z,width:"669",height:"498"})),(0,r.kt)("h3",{id:"append"},"Append"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Append an element to the list value produced by various loop statements."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"append Exp")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An append statement may only occur in the body of a ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," or\n",(0,r.kt)("a",{parentName:"p",href:"#for"},"For")," statement. It appends the value of ",(0,r.kt)("em",{parentName:"p"},"Exp")," to the resulting list value of the loop construct in\nwhich it occurs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"for(int i <- [1..5]) append i*i;\nL = for(int i <- [1..5]) append i*i;\n")),(0,r.kt)("h3",{id:"assert"},"Assert"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"An executable assertion."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"assert Exp1"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"assert Exp1 : Exp2")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp2")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"str"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An assert statement may occur everywhere where a declaration is allowed. It has two forms:"),(0,r.kt)("p",null,"An assert statement consists of a Boolean expression ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," and an optional string expression\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," that serves as a identifying message for this assertion."),(0,r.kt)("p",null,"When ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", an ",(0,r.kt)("inlineCode",{parentName:"p"},"AssertionFailed")," exception is thrown."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'assert 1==2 : "is never true";\nint div(int x, int y) {\n  assert y != 0 : "y must be non-zero";\n  return x / y;\n}\ndiv(4,0);\n')),(0,r.kt)("h3",{id:"assignment"},"Assignment"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign a value to a variable or more complex data structure."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Assignable AssignmentOp Exp")),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"AssignmentOp")," may be one of ",(0,r.kt)("inlineCode",{parentName:"p"},"="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"+="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"-="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"*="),", ",(0,r.kt)("inlineCode",{parentName:"p"},"/="),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"?="),"."),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"Assignable")," is one of the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Var"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp ]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp .. Exp ]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp, Exp .. Exp ]"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable . Name"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"< Assignable, Assignable, \u2026\u200b, Assignable >"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable ? Exp"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable @ Name"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Name ( Assignable, Assignable, \u2026\u200b )")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The purpose of an assignment is to assign a new value to a simple variable or to an element of a more complex data\nstructure."),(0,r.kt)("p",null,"The standard assignment operator is ",(0,r.kt)("inlineCode",{parentName:"p"},"="),". The other assignment operators can be expressed as abbreviations for the\nstandard assignment operator."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Assignment Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Equivalent to"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable += Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable = Assignable + Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable -= Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable = Assignable - Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable *= Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable = Assignable * Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable /= Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable = Assignable / Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable &= Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable = Assignable & Exp"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable ?= Exp")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Assignable = Assignable ? Exp"))))),(0,r.kt)("p",null,"An assignable is either a single variable, (the base variable), optionally followed by subscriptions, slices or field\nselections. The assignment statement always results in assigning a completely new value to the base variable. We\ndistinguish the following forms of assignment:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#annotation"},"Annotation"),":")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#constructor"},"Constructor"),": Assign to constructor.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#field"},"Field"),": Assign to a field of a tuple, relation or datatype.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#isdefined"},"IsDefined"),": Assign but replace if value is not defined.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#multiple"},"Multiple"),": Assign to multiple assignables.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#slice"},"Slice"),": Assign to a slice of a list or string.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#subscription"},"Subscription"),": Assign a single element of a structured value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#variable"},"Variable"),": Assign to a variable."))),(0,r.kt)("h3",{id:"annotation"},"Annotation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign to an annotation. This feature is deprecated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The value ",(0,r.kt)("em",{parentName:"p"},"V")," of ",(0,r.kt)("em",{parentName:"p"},"Assignable")," is determined and should be of a type that has an annotation ",(0,r.kt)("em",{parentName:"p"},"Name"),". A new value ",(0,r.kt)("em",{parentName:"p"},"V"),"' is\ncreated that is a copy of ",(0,r.kt)("em",{parentName:"p"},"V")," but with the value of annotation ",(0,r.kt)("em",{parentName:"p"},"Name")," replaced by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),". ",(0,r.kt)("em",{parentName:"p"},"V"),"' is assigned\nto ",(0,r.kt)("em",{parentName:"p"},"Assignable"),". See ",(0,r.kt)("a",{parentName:"p",href:"#annotation"},"Annotation Declaration"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Examples have been removed since this feature is deprecated."),(0,r.kt)("h3",{id:"constructor-1"},"Constructor"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign to constructor."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"First the value ",(0,r.kt)("em",{parentName:"p"},"Exp")," is determined and should be a data value of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Name(V1, V2, \u2026\u200b, Vn).\nNext the assignments `Assignablei = Vi")," are performed for 1 \\<= i \\<= n."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'data FREQ = wf(str word, int freq);\nW = wf("rascal", 1000);\nwf(S, I) = W;\nS;\nI;\n')),(0,r.kt)("h3",{id:"field"},"Field"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign to a field of a tuple, relation or datatype."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The value ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," of ",(0,r.kt)("em",{parentName:"p"},"Assignable")," is determined and should be of a type that has a field ",(0,r.kt)("em",{parentName:"p"},"Name"),". The value of that field is\nreplaced in ",(0,r.kt)("em",{parentName:"p"},"V")," by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp")," resulting in a new value ",(0,r.kt)("em",{parentName:"p"},"V"),"' that is assigned to ",(0,r.kt)("em",{parentName:"p"},"Assignable"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'data FREQ = wf(str word, int freq);\nW = wf("rascal", 1000);\nW.freq = 100000;\n')),(0,r.kt)("h3",{id:"isdefined"},"IsDefined"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign but replace if value is not defined."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"First the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is determined and if that is defined it is assigned to ",(0,r.kt)("em",{parentName:"p"},"Assignable"),". Otherwise, the\nvalue of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," is assigned to ",(0,r.kt)("em",{parentName:"p"},"Assignable"),". Values which can be undefined are values in ",(0,r.kt)("a",{parentName:"p",href:"#map"},"Map"),"s\nwhere the key is not set or values of ",(0,r.kt)("a",{parentName:"p",href:"#annotation"},"Annotations")," which have not been set yet."),(0,r.kt)("p",null,"No other values can be used in an undefined state, so the ? operator does not make sense on undefined or uninitialized\nvariables for example."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'M = ("Andy": 1, "Brian" : 2);\n')),(0,r.kt)("p",null,"Using an ",(0,r.kt)("inlineCode",{parentName:"p"},"isDefined")," assignable can we increment a non-existing entry:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'M["SomebodyElse"] ? 0 += 1;\nM["SomebodyElse"];\n')),(0,r.kt)("p",null,"And if we increment an existing entry the ? has no effect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'M["Andy"] ? 0 += 1;\nM["Andy"]\n')),(0,r.kt)("h3",{id:"multiple"},"Multiple"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign to multiple assignables."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"First the value ",(0,r.kt)("em",{parentName:"p"},"Exp")," is determined and should be a tuple of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"< V1, V2, \u2026\u200b, Vn >"),". Next the assignments\n",(0,r.kt)("inlineCode",{parentName:"p"},"Assignablei = Vi")," are performed for 1 \\<= i \\<= n."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'<A, B, C> = <"abc", 2.5, [1,2,3]>;\nA;\nB;\nC;\n')),(0,r.kt)("h3",{id:"slice"},"Slice"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign to a slice of a list or string."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp1 .. Exp_3 ] = Exp4"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp1, Exp2 .. Exp3 ] = Exp4")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Exp1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Exp3")," are optional .Types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A slice assignment is defined for ",(0,r.kt)("a",{parentName:"p",href:"#list"},"List"),", ",(0,r.kt)("a",{parentName:"p",href:"#string"},"String")," and ",(0,r.kt)("a",{parentName:"p",href:"#node"},"Node")," and aims to\nreplace a slice from the old value of the assignable by a new value. See ",(0,r.kt)("a",{parentName:"p",href:"#slice"},"List Slice"),", ",(0,r.kt)("a",{parentName:"p",href:"#slice"},"String\nSlice")," or ",(0,r.kt)("a",{parentName:"p",href:"#slice"},"Node Slice")," for a more detailed explanation of slicing."),(0,r.kt)("p",null,"Let ",(0,r.kt)("em",{parentName:"p"},"V")," be the current value of ",(0,r.kt)("em",{parentName:"p"},"Assignable"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp1 .. Exp3 ] = Exp4"),": The slice ",(0,r.kt)("inlineCode",{parentName:"p"},"[ Exp1 .. Exp3 ]")," determines two indices ",(0,r.kt)("inlineCode",{parentName:"p"},"begin")," (inclusive) and\n",(0,r.kt)("inlineCode",{parentName:"p"},"end")," (exclusive) in ",(0,r.kt)("em",{parentName:"p"},"V"),". A new value ",(0,r.kt)("em",{parentName:"p"},"V"),"' is computed that is a copy of ",(0,r.kt)("em",{parentName:"p"},"V")," but with all the elements in ",(0,r.kt)("em",{parentName:"p"},"V")," with\n",(0,r.kt)("inlineCode",{parentName:"p"},"begin \u21d0 index < end")," replaced by the elements of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4"),". Note that the size of ",(0,r.kt)("em",{parentName:"p"},"V")," and ",(0,r.kt)("em",{parentName:"p"},"V"),"'\nmay differ. ",(0,r.kt)("em",{parentName:"p"},"V"),"' is assigned to the ",(0,r.kt)("em",{parentName:"p"},"Assignable"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Assignable [ Exp1, Exp2 .. Exp3 ] = Exp4"),": The slice ",(0,r.kt)("inlineCode",{parentName:"p"},"[ Exp1, Exp2 .. Exp3 ]")," determines two indices ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),"\n(inclusive) and ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," (exclusive) and a ",(0,r.kt)("inlineCode",{parentName:"p"},"step")," between indices in ","_","V\\</emphasis",">",". A new value ",(0,r.kt)("em",{parentName:"p"},"V"),"' is computed\nthat is a copy of ",(0,r.kt)("em",{parentName:"p"},"V")," but with all the elements in ",(0,r.kt)("em",{parentName:"p"},"V")," with indices ",(0,r.kt)("inlineCode",{parentName:"p"},"begin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"begin+step"),". \u2026\u200b ",(0,r.kt)("inlineCode",{parentName:"p"},"end-step")," \u21d0 ",(0,r.kt)("inlineCode",{parentName:"p"},"index <\nend")," replaced by the successive elements of the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4"),". Note that the size of ",(0,r.kt)("em",{parentName:"p"},"V")," and ",(0,r.kt)("em",{parentName:"p"},"V"),"' may\ndiffer. ",(0,r.kt)("em",{parentName:"p"},"V"),"' is assigned to the ",(0,r.kt)("em",{parentName:"p"},"Assignable"),". If the number of indices in the slice and the number of elements in\nthe value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"4")," is not equal the following is done:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the number of elements in the slice is larger: the elements of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4"))," are used in a circular\nmanner.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the number of elements in the slice is smaller: the remaining elements of ",(0,r.kt)("em",{parentName:"p"},"Exp",(0,r.kt)("sub",null,"4"))," is inserted after\nthe last index in the slice."))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Replace the elements with index 3, 4, 5 in ",(0,r.kt)("inlineCode",{parentName:"p"},"L"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [0,1,2,3,4,5,6,7,8,9];\nL[3..6] = [100,200,300,400,500];\n")),(0,r.kt)("p",null,"Replace the elements with index 1, 3, 5, 7 in ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," (note how the elements from ",(0,r.kt)("inlineCode",{parentName:"p"},"[100,200]")," are used in a circular way):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [0,1,2,3,4,5,6,7,8,9];\nL[1,3..8] = [100,200];\n")),(0,r.kt)("p",null,"Replace the elements with index 1, 3, 5, 7 in ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," (note how the unused elements from ",(0,r.kt)("inlineCode",{parentName:"p"},"[100,200,300,400,500]")," are insert\nat index 7):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [0,1,2,3,4,5,6,7,8,9];\nL[1,3..8] = [100,200,300,400,500];\n")),(0,r.kt)("p",null,"Similar examples for slicing assignment on strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'S = "abcdefghij";\nS[3..6] = "UVWXYZ";\nS = "abcdefghij";\nS[1,3..8] = "XY";\nS = "abcdefghij";\nS[1,3..8] = "UVWXYZ";\n')),(0,r.kt)("p",null,"Replace the elements with index 3, 4, 5 in node ",(0,r.kt)("inlineCode",{parentName:"p"},"N"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'N = "f"(0,true,2,"abc",4,5.5,6,{7,77},8,{9,99,999});\nN[3..6] = [100,200,300,400,500];\n')),(0,r.kt)("p",null,"Replace the elements with index 1, 3, 5, 7 in ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," (note how the elements from ",(0,r.kt)("inlineCode",{parentName:"p"},"[100,200]")," are used in a circular way):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'N = "f"(0,true,2,"abc",4,5.5,6,{7,77},8,{9,99,999});\nN[1,3..8] = [100,200];\n')),(0,r.kt)("p",null,"Replace the elements with index 1, 3, 5, 7 in ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," (note how the unused elements from ",(0,r.kt)("inlineCode",{parentName:"p"},"[100,200,300,400,500]")," are insert\nat index 7):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'N = "f"(0,true,2,"abc",4,5.5,6,{7,77},8,{9,99,999});\nN[1,3..8] = [100,200,300,400,500];\n')),(0,r.kt)("h3",{id:"subscription"},"Subscription"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign a single element of a structured value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Let ",(0,r.kt)("em",{parentName:"p"},"V")," be the current value of ",(0,r.kt)("em",{parentName:"p"},"Assignable"),". The value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"1")," is used as index in ",(0,r.kt)("em",{parentName:"p"},"V")," and the value of\n",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"2")," replaces the original value at that index position. The result is a new value ",(0,r.kt)("em",{parentName:"p"},"V"),"' that is assigned to\nthe ",(0,r.kt)("em",{parentName:"p"},"Assignable"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"")),(0,r.kt)("p",null,"Assignable has a list value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [10,20,30];\nP = L;\nL[1] = 200;\n")),(0,r.kt)("p",null,"Observe that ",(0,r.kt)("inlineCode",{parentName:"p"},"P")," is unchanged:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"P;\n")),(0,r.kt)("p",null,"Assignable has a map value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'M = ("abc": 1, "def" : 2);\nM["def"] = 3;\n')),(0,r.kt)("p",null,"Assignable has a tuple value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'T = <1, "abc", true>;\nT[1] = "def";\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/usethesource/rascal/issues/948"},"https://github.com/usethesource/rascal/issues/948"))),(0,r.kt)("h3",{id:"variable"},"Variable"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Assign to a variable."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," is evaluated and its value is assigned to the variable ",(0,r.kt)("em",{parentName:"p"},"Var"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"N = 3;\nN;\n")),(0,r.kt)("h3",{id:"block"},"Block"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Group statements into a block."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"{ Statement1; \u2026\u200b ; Statementn }")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"block")," consists of a sequence of statements separated by semi-colons."),(0,r.kt)("p",null,"Since a block is itself a statement, it may be used in all places where a statement is required. A block also introduces\na new scope and variables that are declared in the block are local to that block. The value produced by a block is the\nvalue produced by its last statement (if any)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is a contrived block of three expressions (be aware of the last semi-colon):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{1;2;3;}\n")),(0,r.kt)("p",null,"its value is ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,r.kt)("p",null,"The effect of a local variable declared in a block can be seen as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{int x = 3; x*x;}\n")),(0,r.kt)("p",null,"After the block we cannot refer to ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"x;\n")),(0,r.kt)("h3",{id:"break"},"Break"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"End the execution of a while, do or for loop."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"break")," statement is only allowed inside the body of a ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," or\n",(0,r.kt)("a",{parentName:"p",href:"#for"},"For")," statement and is associated with the innermost loop statement in which it is contained. Its\neffect is to end the execution of the loop."),(0,r.kt)("p",null,"Also see ",(0,r.kt)("a",{parentName:"p",href:"#continue"},"Continue")," and ",(0,r.kt)("a",{parentName:"p",href:"#fail"},"Fail"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is an example using break to find the first number divisible by 3:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nfor(int i <- [1 .. 10]){\n    if(i % 3 == 0){\n       println("i = <i> is divisible by 3");\n       break;\n    }\n}\n')),(0,r.kt)("h3",{id:"continue"},"Continue"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Continue with the next iteration of while, do or for loop."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A continue statement is only allowed inside the body of a ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While"),", ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," or\n",(0,r.kt)("a",{parentName:"p",href:"#for"},"For")," statement and is associated with the innermost loop statement in which it is contained. Its\neffect is to end the execution of the block for the current iteration of the loop and to continue with the next\niteration of the loop."),(0,r.kt)("p",null,"Also see ",(0,r.kt)("a",{parentName:"p",href:"#break"},"Break")," and ",(0,r.kt)("a",{parentName:"p",href:"#fail"},"Fail"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is an example using continue to avoid printing numbers that are divisible by 3:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nfor(int i <- [1 .. 10]){\n    if(i % 3 == 0)\n       continue;\n    println("i = <i>");\n}\n')),(0,r.kt)("h3",{id:"do"},"Do"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Repeat statements while condition holds."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"do Statement while ( Exp );")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Statement")," is executed repeatedly, as long as the Boolean expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," yields true. Expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," is executed\nfrom scratch in each repetition and only the first true value (if any) is used."),(0,r.kt)("p",null,"By default, the value of a do statement is the empty list. In general, the value of a do statement consists of all\nvalues contributed by ",(0,r.kt)("a",{parentName:"p",href:"#append"},"Append")," statements that are executed during the repeated execution of its\nbody Statement."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nint n = 3;\ndo { println("n = <n>"); n -= 1; } while (n > 0);\n')),(0,r.kt)("p",null,"Now build a list result using the ",(0,r.kt)("inlineCode",{parentName:"p"},"append")," statement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"n = 3;\ndo { append n * n; n -= 1; } while (n > 0);\n")),(0,r.kt)("h3",{id:"fail"},"Fail"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Let the current alternative of a pattern match fail."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"fail;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," statement is only allowed in statements that are controlled by the outcome of a pattern match:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("a",{parentName:"p",href:"#patterns"},"Patterns")," in a ",(0,r.kt)("a",{parentName:"p",href:"#pattern-with-Action"},"???")," in ",(0,r.kt)("a",{parentName:"p",href:"#switch"},"Switch")," or\n",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," statement controls the statements in the action part.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The test (expression) of a ",(0,r.kt)("a",{parentName:"p",href:"#while"},"While")," or ",(0,r.kt)("a",{parentName:"p",href:"#do"},"Do")," statement controls the statements in\nthe body part.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The test (expressions) of a ",(0,r.kt)("a",{parentName:"p",href:"#for"},"For")," statement control the statements in the body part.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The formal parameter declaration of a ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function Declaration"),"."))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," statement is associated with the innermost pattern match by which it is controlled."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," is executed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the associated pattern has more alternatives, the next alternative is explored,")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"otherwise the pattern as a whole fails."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In the case of switch or visit this means that the next case will be tried.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For while, do and for, this implies that any bindings caused by the pattern are undone and that the next\nalternative in the test is tried; otherwise the loop is terminated.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For a function call it means that the next function declaration (or the default one) is tried."))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is an example taken from ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes#Bubble"},"Bubble"),". It uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," for the case that no unsorted element can be\nfound in the list of numbers. As a result, the whole case fails and the default case is used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import IO;\npublic list[int] sort(list[int] numbers){\n  switch(numbers){\n    case [*int nums1, int p, int q, *int nums2]:\n       if(p > q){\n          return sort(nums1 + [q, p] + nums2);\n       } else {\n          fail;\n       }\n     default: return numbers;\n   }\n}\nsort([10, 1, 5, 3]);\n")),(0,r.kt)("h3",{id:"for"},"For"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"For loop."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"for ( Exp1 , Exp2 , \u2026\u200b , Expn ) Statement;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The for-statement executes ",(0,r.kt)("em",{parentName:"p"},"Statement")," for all possible combinations of values generated, and filtered, by the\nexpressions ",(0,r.kt)("em",{parentName:"p"},"Exp"),(0,r.kt)("sub",null,"i"),"."),(0,r.kt)("p",null,"Some of the expressions can generate bindings (",(0,r.kt)("a",{parentName:"p",href:"#enumerator"},"Enumerator"),",\n",(0,r.kt)("a",{parentName:"p",href:"#values"},"Boolean,Match"),"), and some can filter them (",(0,r.kt)("a",{parentName:"p",href:"#values"},"Boolean"),"). The for loop will\niterate over the cartesian product of all the generating expressions, and filter the combinations which fail the\nconditional expressions."),(0,r.kt)("p",null,"By default, the value of a for statement is the empty list. In general, the value of a for statement consists of all\nvalues contributed by ",(0,r.kt)("a",{parentName:"p",href:"#append"},"Append")," statements that are executed during the repeated execution of its\nbody Statement."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nfor(int n <- [1 .. 5]) println("n = <n>");\nfor(int n <- [1 .. 5]) append n * n;\n')),(0,r.kt)("h3",{id:"if"},"If"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Conditional statement."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"if ( Exp ) Statement;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"if ( Exp ) Statement1 else Statement2;")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"if ( Exp ) Statement;")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"void"))))),(0,r.kt)("p",null,"Types"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Exp")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Statement1")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"Statement2")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"th"},"if ( Exp ) Statement1 else Statement2;")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"1"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("em",{parentName:"td"},"T",(0,r.kt)("sub",null,"2"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"lub(T1, T2)"))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The test ",(0,r.kt)("em",{parentName:"p"},"Exp")," is evaluated and its outcome determines the statement to be executed: ",(0,r.kt)("em",{parentName:"p"},"Statement"),(0,r.kt)("sub",null,"1")," if ",(0,r.kt)("em",{parentName:"p"},"Exp"),"\nyields ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,r.kt)("em",{parentName:"p"},"Statement"),(0,r.kt)("sub",null,"2")," otherwise. The value of an if-then statement is equal to ",(0,r.kt)("em",{parentName:"p"},"Statement")," when its\ntest is true. Otherwise it is void. The value of an if-then-else statement is the value of the statement that was\nexecuted."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"if( 3 > 2 ) 30; else 40;\nx = if( 3 > 2 ) 30; else 40;\nif( 3 > 2 ) 30;\n")),(0,r.kt)("p",null,"An if-then statement yields ",(0,r.kt)("inlineCode",{parentName:"p"},"void")," when its test is false (demonstrated by the ",(0,r.kt)("em",{parentName:"p"},"ok")," that is printed by the Rascal\nsystem):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"if( 2 > 3 ) 30;\n")),(0,r.kt)("h3",{id:"insert"},"Insert"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Insert a value in a tree during a ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"insert Exp;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"An insert statement may only occur in the action part of a ",(0,r.kt)("a",{parentName:"p",href:"#patternwithaction"},"Pattern With Action"),", more\nprecisely in a case in a ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," expression. The value matched by the pattern of this case is\nreplaced by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),"."),(0,r.kt)("p",null,"The following rule applies:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The static type of ",(0,r.kt)("em",{parentName:"li"},"Exp")," should be a subtype of the type of the value that is replaced.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Consider the following datatype ",(0,r.kt)("inlineCode",{parentName:"p"},"CTree")," and assign a CTree value to variable ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"data CTree = leaf(int n) | red(CTree left, CTree right) | green(CTree left, CTree right);\nCTree T = red(green(leaf(1), red(leaf(2), leaf(3))), red(leaf(4), leaf(5)));\n")),(0,r.kt)("p",null,"We can now switch the arguments of all red nodes as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"visit(T){\n  case red(CTree l, CTree r): insert red(r,l);\n}\n")),(0,r.kt)("p",null,"Since this is a very common idiom, we also have a shorthand for it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"visit(T){\n  case red(CTree l, CTree r) => red(r,l)\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"There is a glitch in the Rascal syntax that ",(0,r.kt)("em",{parentName:"p"},"requires")," a semicolon after a case (as in the first example), but refuses\nit in the abbreviated version using ",(0,r.kt)("inlineCode",{parentName:"p"},"\u21d2")," (the second example)."),(0,r.kt)("h3",{id:"return"},"Return"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Return a value as result of a ","[","Function","]","."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"return;"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"return Exp")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A return statement comes in two variants: without and with an expression, both variants end the execution of the current\nfunction. The first variant applies to functions with ",(0,r.kt)("inlineCode",{parentName:"p"},"void")," as return type. The second variants applies to non-void\nfunctions and returns the value of ",(0,r.kt)("em",{parentName:"p"},"Exp")," as result of the function invocation. The following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The static type of ",(0,r.kt)("em",{parentName:"p"},"Exp")," should be compatible with the declared return type of the function in which the return\nstatement occurs.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In each function with a return type that is not void, every possible execution path through the body of the function\nshould end in a return statement."))),(0,r.kt)("p",null,"In each function with a return type that is void, a return statement is implicitly assumed at the end of each execution\npath through the function body."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int twice(int n) { return 2 * n; }\ntwice(5);\n")),(0,r.kt)("p",null,"Functions that only return a value can be abbreviated (and the return is implicit):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int twiceb(int n) = 2 * n;\ntwiceb(5);\n")),(0,r.kt)("h3",{id:"solve"},"Solve"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Solve a set of equalities by fixed-point iteration."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"solve(Var1, Var2, \u2026\u200b, Varn; Exp) Statement;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Rascal provides a solve statement for performing arbitrary fixed-point computations. This means, repeating a certain\ncomputation as long as it causes changes. This can, for instance, be used for the solution of sets of simultaneous\nlinear equations but has much wider applicability."),(0,r.kt)("p",null,"The solve statement consists of the variables for which a fixed point will be computed and a statement. Optionally, an\nexpression ",(0,r.kt)("em",{parentName:"p"},"Exp")," directly following the list of variables gives an upper bound on the number of iterations."),(0,r.kt)("p",null,"Statement can use and modify the listed variables ",(0,r.kt)("em",{parentName:"p"},"Var"),(0,r.kt)("sub",null,"i"),". The statement is executed, assigning new values to\nthe variables ",(0,r.kt)("em",{parentName:"p"},"Var"),(0,r.kt)("sub",null,"i"),", and this is repeated as long as the value of any of the variables was changed compared\nto the previous repetition. Note that this computation will only terminate if the variables range over a so-called\n",(0,r.kt)("em",{parentName:"p"},"bounded monotonic lattice"),", in which values can only become larger until a fixed upper bound or become smaller until a\nfixed lower bound."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Let\u2019s consider transitive closure as an example (transitive closure is already available as built-in operator, we use it\nhere just as a simple illustration). Transitive closure of a relation is usually defined as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"R+ = R + (R o R) + (R o R o R) + ...\n")),(0,r.kt)("p",null,"In other words, it is the union of successive ",(0,r.kt)("a",{parentName:"p",href:"#composition"},"Relation Composition"),"s of ",(0,r.kt)("inlineCode",{parentName:"p"},"R")," with itself. For a\ngiven relation ",(0,r.kt)("inlineCode",{parentName:"p"},"R")," this can be expressed as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rel[int,int] R = {<1,2>, <2,3>, <3,4>};\nT = R;\nsolve (T) {\n          T = T + (T o R);\n        }\n")),(0,r.kt)("h3",{id:"switch"},"Switch"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The switch statement is a control flow statement where the next block is selected by pattern matching against a number\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," patterns."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"switch ( Exp ) {\ncase PatternWithAction1;\ncase PatternWithAction2;\n...\ndefault: ...\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A switch statement is similar to a switch statement in C or Java. The value of the expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," is the subject term\nthat will be matched by the successive ",(0,r.kt)("a",{parentName:"p",href:"#patternwithaction"},"Pattern With Action"),"s in the switch statement. The\nswitch statement provides only matching at the top level of the subject term and does not traverse it. The type of the\npattern in each case must be identical to the type of the subject term (or be a supertype of it). If no case matches,\nthe switch acts as a dummy statement. There is no fall through from one case to the next."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Suppose we want to naively analyze a sentence and print the topic it is about:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nS = "Princess Leila sipped from her rum punch";\nswitch(S){\n  case /Leila/: println("The topic is Star Wars");\n  case /rum/:   println("The topic is Drunken man");\n  case /punch/: println("The topic is Kick Boxing");\n}\n')),(0,r.kt)("p",null,"From the printed message you can infer that the cases are tried in the order in which they occur."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,r.kt)("p",null,"The switch statement does not yet return a value, this will be changed."),(0,r.kt)("h3",{id:"test"},"Test"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Test statement (",(0,r.kt)("em",{parentName:"p"},"deprecated"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," statement is deprecated and is replaced by the ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," modifier in function declarations, see ",(0,r.kt)("a",{parentName:"p",href:"#function"},"Function\nDeclaration"),"."),(0,r.kt)("h3",{id:"throw"},"Throw"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Throw any value as an exception up the call stack."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"throw Exp")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A throw statement causes the immediate abortion of the execution of the current function with ",(0,r.kt)("em",{parentName:"p"},"Exp")," ","\\","'s value as\nexception value. The exception can be caught by a ",(0,r.kt)("a",{parentName:"p",href:"#try-catch"},"Try Catch")," statement in the current function or\nin one of its callers. If the exception is not caught, the execution of the Rascal program is terminated. The following\nrules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The static type of ",(0,r.kt)("em",{parentName:"p"},"Exp")," should be ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeException"),", see\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#runtimeexception"},"RuntimeException"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Rascal program may contain data declarations that extend the type ",(0,r.kt)("inlineCode",{parentName:"p"},"RuntimeException"),"."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Here is a a variant of string concatenation for ball haters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'str conc(str x, str y){ if("ball" in {x, y}) throw "I hate balls"; return x + y; }\nconc("fairy", "tale");\nconc("foot", "ball");\n')),(0,r.kt)("h3",{id:"try-catch"},"Try Catch"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Try to execute a statement and catch resulting exceptions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"try\n   Statement1;\ncatch PatternWithAction1;\ncatch PatternWithAction2;\n...\ncatch: Statement2;\nfinally: Statement3;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A try catch statement has as purpose to catch any ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#exception"},"Exceptions")," that are raised during the\nexecution of ",(0,r.kt)("em",{parentName:"p"},"Statement"),(0,r.kt)("sub",null,"1"),". These exceptions may caused by:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The execution of an explicit ",(0,r.kt)("a",{parentName:"p",href:"#throw"},"Throw")," statement.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Rascal system that discovers an abnormal condition, e.g., an out of bounds error when accessing a list element."))),(0,r.kt)("p",null,"Note that all elements of the try catch statement are optional but that at least one has to be present. Their meaning is\nas follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a pattern of some ",(0,r.kt)("em",{parentName:"p"},"PatternWithAction",(0,r.kt)("sub",null,"i"))," matches, the corresponding action is executed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Otherwise, ",(0,r.kt)("em",{parentName:"p"},"Statement",(0,r.kt)("sub",null,"2"))," is executed (when present).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Before leaving the try catch statement ",(0,r.kt)("em",{parentName:"p"},"Statement",(0,r.kt)("sub",null,"3"))," is always executed (when present)."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("p",null,"Let\u2019s define a variant of the ",(0,r.kt)("a",{parentName:"p",href:"/docs/Libraries#head"},"head")," function that returns the first element of a list, but throws\nan exception when the list is empty. Our variant will return ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," for an empty list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"import List;\nimport Exception;\nint hd(list[int] x) { try return head(x); catch: return 0; }\nhd([1,2,3]);\nhd([]);\n")),(0,r.kt)("p",null,"We can also be more specific and catch the ",(0,r.kt)("inlineCode",{parentName:"p"},"EmptyList")," exception (which is available here since we have imported the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Exception")," module):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int hd2(list[int] x) { try return head(x); catch EmptyList(): return 0; }\nhd2([]);\n")),(0,r.kt)("h3",{id:"visit-1"},"Visit"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," expression can also be used directly as a statement"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"???"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#visit"},"Visit")," for the details."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"x = [[1],[2],[3]];\nif (true) {\n  // this visit is a nested statement in an if block:\n  visit (x) {\n    case int i => i + 1\n  }\n}\n")),(0,r.kt)("h3",{id:"while"},"While"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"While loop."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Syntax.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"while ( Exp ) Statement;")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The Boolean expression ",(0,r.kt)("em",{parentName:"p"},"Exp")," is evaluated repeatedly and ",(0,r.kt)("em",{parentName:"p"},"Statement")," is executed when the test is true. Execution ends\nthe first time that the test yields false. The test ",(0,r.kt)("em",{parentName:"p"},"Exp")," is executed from scratch in each repetition and only the first\n",(0,r.kt)("inlineCode",{parentName:"p"},"true")," value (if any) is used. This is relevant when ",(0,r.kt)("em",{parentName:"p"},"Exp")," contains a ",(0,r.kt)("a",{parentName:"p",href:"#match"},"Boolean Match")," or ",(0,r.kt)("a",{parentName:"p",href:"#nomatch"},"Boolean\nNoMatch")," operator."),(0,r.kt)("p",null,"By default, the value of a while statement is the empty list. In general, the value of a while statement consists of all\nvalues contributed by ",(0,r.kt)("a",{parentName:"p",href:"#append"},"Append")," statements that are executed during the repeated execution of its\nbody ",(0,r.kt)("em",{parentName:"p"},"Statement"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Examples.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nint n = 3;\nwhile( n > 0 ) { println("n = <n>"); n -= 1; }\n')),(0,r.kt)("p",null,"Now build a list result using the ",(0,r.kt)("inlineCode",{parentName:"p"},"append")," statement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"n = 3;\nwhile (n > 0) { append n * n; n -= 1; }\n")),(0,r.kt)("p",null,"Just to be sure, a ",(0,r.kt)("a",{parentName:"p",href:"#comprehension"},"List Comprehension")," is the superior way to write this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"[n * n | n <- [3 .. 1]];\n")))}d.isMDXComponent=!0},8903:function(e,t,a){t.Z=a.p+"assets/images/module-parts-0b764d62248b790799603c0a673fc03b.png"},7426:function(e,t,a){t.Z=a.p+"assets/images/statement-parts-dec016f07d74df845a52f4d117d3ef38.png"},4867:function(e,t,a){t.Z=a.p+"assets/images/type-lattice-9a476acc338596237526acde1ad0c66b.png"}}]);