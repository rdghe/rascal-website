"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[61702],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(67294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),m=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=m(a),u=l,k=c["".concat(s,".").concat(u)]||c[u]||d[u]||r;return a?n.createElement(k,i(i({ref:t},p),{},{components:a})):n.createElement(k,i({ref:t},p))}));function u(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var m=2;m<r;m++)i[m]=a[m];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},29208:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var n=a(87462),l=(a(67294),a(3905));const r={title:"Symbol",keywords:['"',"'","[","]","!","-","||","&&","(",")","?","+","*","{","}","|","()","^","@",">>","!>>","<<","!<<"]},i=void 0,o={unversionedId:"Rascal/Declarations/SyntaxDefinition/Symbol/index",id:"Rascal/Declarations/SyntaxDefinition/Symbol/index",title:"Symbol",description:"Synopsis",source:"@site/docs/Rascal/Declarations/SyntaxDefinition/Symbol/index.md",sourceDirName:"Rascal/Declarations/SyntaxDefinition/Symbol",slug:"/Rascal/Declarations/SyntaxDefinition/Symbol/",permalink:"/docs/Rascal/Declarations/SyntaxDefinition/Symbol/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Rascal/Declarations/SyntaxDefinition/Symbol/index.md",tags:[],version:"current",frontMatter:{title:"Symbol",keywords:['\\"',"'","[","]","!","-","||","&&","(",")","?","+","*","{","}","|","()","^","@",">>","!>>","<<","!<<"]},sidebar:"tutorialSidebar",previous:{title:"Parse Trees",permalink:"/docs/Rascal/Declarations/SyntaxDefinition/ParseTrees/"},next:{title:"Alias Declaration",permalink:"/docs/Rascal/Declarations/Alias/"}},s={},m=[{value:"Synopsis",id:"synopsis",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Types",id:"types",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4},{value:"Benefits",id:"benefits",level:4},{value:"Pitfalls",id:"pitfalls",level:4}],p={toc:m};function d(e){let{components:t,...a}=e;return(0,l.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"synopsis"},"Synopsis"),(0,l.kt)("p",null,"The symbols that can occur in a syntax definition."),(0,l.kt)("h4",{id:"syntax"},"Syntax"),(0,l.kt)("p",null,"Nonterminal symbols are identifier names that ",(0,l.kt)("em",{parentName:"p"},"start with an uppercase letter"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol fieldName")),(0,l.kt)("td",{parentName:"tr",align:null},"Any symbol can be labeled with a field name that ",(0,l.kt)("em",{parentName:"td"},"starts with a lowercase letter"))))),(0,l.kt)("p",null,"The following literal symbols and character classes are defined:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'"stringliteral"')),(0,l.kt)("td",{parentName:"tr",align:null},"Literal string")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"'stringliteral'")),(0,l.kt)("td",{parentName:"tr",align:null},"Case-insensitive literal string")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"[range\u2081 range\u2082 ... ]")),(0,l.kt)("td",{parentName:"tr",align:null},"Character class")))),(0,l.kt)("p",null,"The following operations on character classes can be composed arbitrarily:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Class"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"!Class")),(0,l.kt)("td",{parentName:"tr",align:null},"Complement of ",(0,l.kt)("inlineCode",{parentName:"td"},"Class")," with respect to the UTF8 universe of characters")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2081 - Class\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},"Difference of character classes ",(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2081")," and ",(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2082"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2081 \\|\\| Class\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},"Union of character classes ",(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2081")," and ",(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2082"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2081 && Class\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},"Intersection of character classes ",(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2081")," and ",(0,l.kt)("inlineCode",{parentName:"td"},"Class\u2082"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(Class)")),(0,l.kt)("td",{parentName:"tr",align:null},"Brackets for defining application order of class operators")))),(0,l.kt)("p",null,"The following regular expressions can be constructed over ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/Symbol/"},"Symbol"),"s:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol?")),(0,l.kt)("td",{parentName:"tr",align:null},"Optional ",(0,l.kt)("em",{parentName:"td"},"Symbol"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol+")),(0,l.kt)("td",{parentName:"tr",align:null},"Non-empty list of _Symbol_s")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol*")),(0,l.kt)("td",{parentName:"tr",align:null},"Possibly empty list of _Symbol_s.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{Symbol\u2081 Symbol\u2082}+")),(0,l.kt)("td",{parentName:"tr",align:null},"Non-empty list of ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2081")," separated by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2082"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{Symbol\u2081 Symbol\u2082}*")),(0,l.kt)("td",{parentName:"tr",align:null},"Possibly empty list of ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2081")," separated by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2082"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(Symbol\u2081 Symbol\u2082 ... )")),(0,l.kt)("td",{parentName:"tr",align:null},"Embedded sequence of symbols")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(Symbol\u2081 \\| Symbol\u2082 \\| ... )")),(0,l.kt)("td",{parentName:"tr",align:null},"Embedded choice of alternative symbols")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"()")),(0,l.kt)("td",{parentName:"tr",align:null},"The anonymous non-terminal for the language with the empty string")))),(0,l.kt)("p",null,"Inline conditions (",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/Disambiguation/"},"Disambiguation"),"s) can be added to symbols to constrain their acceptability:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Disambiguation"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol _")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol")," ends at end of line or end of file")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"^Symbol")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol")," starts at begin of line")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol @ ColumnIndex")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol")," starts at certain column index.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol\u2081 >> Symbol\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol\u2081")," must be (directly) followed by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2082"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol\u2081 !>> Symbol\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol\u2081")," must ",(0,l.kt)("em",{parentName:"td"},"not")," be (directly) followed by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2082"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol\u2081 << Symbol\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol\u2082")," must be (directly) preceded by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2081"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol\u2081 !<< Symbol\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol\u2082")," must ",(0,l.kt)("em",{parentName:"td"},"not")," be (directly) preceded by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2081"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Symbol\u2081 \\ Symbol\u2082")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"td"},"Symbol\u2081")," must not be in the language defined by ",(0,l.kt)("em",{parentName:"td"},"Symbol\u2082"))))),(0,l.kt)("p",null,"Symbols can be composed arbitrarily."),(0,l.kt)("h4",{id:"types"},"Types"),(0,l.kt)("p",null,"Every non-terminal symbol is a type."),(0,l.kt)("h4",{id:"description"},"Description"),(0,l.kt)("p",null,"The basic symbols are the non-terminal name and the labeled non-terminal name.\nThese refer to the names defined by ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"Syntax Definition"),".\nYou can use any defined non-terminal name in any other definition (lexical in syntax, syntax in lexical, etc). "),(0,l.kt)("p",null,"Then we have literals and character classes to define the ",(0,l.kt)("em",{parentName:"p"},"terminals")," of a grammar.\nWhen you use a literal such as ",(0,l.kt)("inlineCode",{parentName:"p"},'"begin"'),", Rascal will produce a definition for it down to the character level before generating a parser: ",(0,l.kt)("inlineCode",{parentName:"p"},'syntax "begin" = [b][e][g][i][n];'),". This effect will be visible in the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/ParseTrees/"},"Parse Trees")," produced by the parser. For case insensitive literals you will see a similar effect; the use of ",(0,l.kt)("inlineCode",{parentName:"p"},"'begin'")," produces ",(0,l.kt)("inlineCode",{parentName:"p"},"syntax 'begin' = [bB][eE][gG][iI][nN]"),"."),(0,l.kt)("p",null,"Character classes have the same escaping conventions as characters in a ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Values/String/"},"String")," literal, but spaces and newlines are meaningless and have to be escaped and the ",(0,l.kt)("inlineCode",{parentName:"p"},"[")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"]")," brackets as well as the dash ",(0,l.kt)("inlineCode",{parentName:"p"},"-")," need escaping. For example, one writes ",(0,l.kt)("inlineCode",{parentName:"p"},"[\\[ \\] \\ \\n\\-]")," for a class that includes the open and close square brackets and a space, a newline and a dash. Character classes support ranges as in ",(0,l.kt)("inlineCode",{parentName:"p"},"[a-zA-Z0-9]"),". Please note about character classes that:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"the operations on character classes are executed before parser generation time. You will not find explicit representation of these operations in ","[ParseTrees]",", but rather their net effect as resulting character classes. "),(0,l.kt)("li",{parentName:"ul"},"Character classes are also ordered by Rascal and overlapping ranges are merged before parsers are generated. Equality between character classes is checked after this canonicalization."),(0,l.kt)("li",{parentName:"ul"},"Although all ",(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/Symbol/"},"./Symbol"),"s are type constructors, the character class operators are not allowed in types.")),(0,l.kt)("p",null,"The other symbols either ",(0,l.kt)("em",{parentName:"p"},"generate")," for you parts of the construction of a grammar, or they ",(0,l.kt)("em",{parentName:"p"},"constrain")," the rules of the grammar to generate a smaller set of trees as ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/Disambiguation/"},"Disambiguation"),"s."),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"generative symbols")," are referred to as the ",(0,l.kt)("em",{parentName:"p"},"regular symbols"),". These are like named non-terminals, except that they are defined implicitly and interpreted by the parser generator to produce a parser that can recognize a symbol optionally, iteratively, alternatively, sequentially, etc. You also need to know this about the regular symbols:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In ",(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/ParseTrees/"},"Parse Trees")," you will find special nodes for the regular expression symbols that hide ",(0,l.kt)("em",{parentName:"li"},"how")," these were recognized. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Patterns/"},"Patterns")," using ",(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Expressions/ConcreteSyntax/"},"./Concrete Syntax")," have special semantics for the regular symbols (list matching, separator handling, ignoring layout, etc.)."),(0,l.kt)("li",{parentName:"ul"},"Regular symbols are not allowed in ",(0,l.kt)("em",{parentName:"li"},"keyword")," ",(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"Syntax Definition"),"s"),(0,l.kt)("li",{parentName:"ul"},"Depending on their occurrence in a ",(0,l.kt)("em",{parentName:"li"},"lexical"),", ",(0,l.kt)("em",{parentName:"li"},"syntax")," or ",(0,l.kt)("em",{parentName:"li"},"layout")," ",(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"Syntax Definition"),"\nthe semantics of regular symbols changes. In the ",(0,l.kt)("em",{parentName:"li"},"syntax")," context, layout non-terminals will be woven\ninto the regular symbol, but not in the ",(0,l.kt)("em",{parentName:"li"},"lexical")," and ",(0,l.kt)("em",{parentName:"li"},"layout")," contexts.\nFor example, a ",(0,l.kt)("inlineCode",{parentName:"li"},"Symbol\\*")," in a syntax definition such as ",(0,l.kt)("inlineCode",{parentName:"li"},"syntax X = A*;")," will be processed to ",(0,l.kt)("inlineCode",{parentName:"li"},"syntax X = "),"{A Layout}*",(0,l.kt)("inlineCode",{parentName:"li"},". Similarly, "),"syntax X = {A B}+;",(0,l.kt)("inlineCode",{parentName:"li"},"will be processed to"),"syntax X = {A (Layout B Layout)}+;`. ")),(0,l.kt)("p",null,"The ",(0,l.kt)("em",{parentName:"p"},"constraint")," symbols are specially there to deal with the fact that Rascal does not generate a scanner. There are no a priori disambiguation rules such as prefer keywords or longest match. Instead, you should use the constraint symbols to define the effect of keyword reservation and longest match. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It is important to note that these constraints work on a character-by-character level in the input stream. So, a follow constraint such as ",(0,l.kt)("inlineCode",{parentName:"li"},"A >> [a-z]")," means that the character immediately following a recognized A must be in the range ",(0,l.kt)("inlineCode",{parentName:"li"},"[a-z]"),"."),(0,l.kt)("li",{parentName:"ul"},"Read more on the constraint symbols via ",(0,l.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/Disambiguation/"},"Disambiguation"),"s.")),(0,l.kt)("h4",{id:"examples"},"Examples"),(0,l.kt)("p",null,"A character class that defines all alphanumeric characters:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"lexical AlphaNumeric = [a-zA-Z0-9];\n")),(0,l.kt)("p",null,"A character class that defines anything except quotes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'lexical AnythingExceptQuote = ![\\"];\n')),(0,l.kt)("p",null,"An identifier class with longest match (can not be followed immediately by ","[a-z]","):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"lexical Id = [a-z]+ !>> [a-z];\n")),(0,l.kt)("p",null,"An identifier class with longest match and first match (can not be preceded or followed by ","[a-z]","):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},"rascal>lexical Id = [a-z] !<< [a-z]+ !>> [a-z];\nok\n")),(0,l.kt)("p",null,"An identifier class with some reserved keywords and longest match:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'lexical Id = [a-z]+ !>> [a-z] \\ "if" \\ "else" \\ "fi";\n')),(0,l.kt)("p",null,"An optional else branch coded using sequence and optional symbols:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Statement = "if" Expression "then" Statement ("else" Statement)? "fi";\n')),(0,l.kt)("p",null,"A block of statements separated by semicolons:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Statement = "{" {Statement ";"}* "}";\n')),(0,l.kt)("p",null,"A declaration with an embedded list of alternative modifiers and a list of typed parameters:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Declaration = ("public" | "private" | "static" | "final")* Type Id "(" {(Type Id) ","}* ")" Statement;\n')),(0,l.kt)("h4",{id:"benefits"},"Benefits"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The symbol language is very expressive and can lead to short definitions of complex syntactic constructs."),(0,l.kt)("li",{parentName:"ul"},"There is no built-in longest match for iterators, which makes syntax definitions open to languages that do not have longest match."),(0,l.kt)("li",{parentName:"ul"},"There is no built-in keyword preference or reservation, which makes syntax definitions open to language composition and legacy languages.")),(0,l.kt)("h4",{id:"pitfalls"},"Pitfalls"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"By nesting too many symbols definitions can be become hard to understand. "),(0,l.kt)("li",{parentName:"ul"},"By nesting too many symbols pattern matching and term construction becomes more complex. Extra non-terminals and rules with meaningful names can make a language specification more manageable. "),(0,l.kt)("li",{parentName:"ul"},"The lack of automatic longest match and prefer keyword heuristics (you have to define it yourself), sometimes leads to unexpected ambiguity. See ","[Disambiguation]",".")))}d.isMDXComponent=!0}}]);