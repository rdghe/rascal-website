"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[20456],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,g=d["".concat(o,".").concat(m)]||d[m]||u[m]||s;return n?a.createElement(g,i(i({ref:t},c),{},{components:n})):a.createElement(g,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<s;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},36961:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const s={title:"Parse"},i=void 0,l={unversionedId:"Recipes/Languages/Lisra/Parse/index",id:"Recipes/Languages/Lisra/Parse/index",title:"Parse",description:"Synopsis",source:"@site/docs/Recipes/Languages/Lisra/Parse/index.md",sourceDirName:"Recipes/Languages/Lisra/Parse",slug:"/Recipes/Languages/Lisra/Parse/",permalink:"/docs/Recipes/Languages/Lisra/Parse/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Recipes/Languages/Lisra/Parse/index.md",tags:[],version:"current",frontMatter:{title:"Parse"},sidebar:"tutorialSidebar",previous:{title:"Test",permalink:"/docs/Recipes/Languages/Lisra/Test/"},next:{title:"Syntax",permalink:"/docs/Recipes/Languages/Lisra/Syntax/"}},o={},p=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"synopsis"},"Synopsis"),(0,r.kt)("p",null,"Parsing a Lisp expression."),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Given the Lisp ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes/Languages/Lisra/Syntax/"},"Syntax"),", we can now apply it to parse textual Lisp expressions\nand convert them to the runtime representation ",(0,r.kt)("inlineCode",{parentName:"p"},"Lval"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Lisra::Parse\n\nimport Prelude;\nimport demo::lang::Lisra::Syntax;\nimport demo::lang::Lisra::Runtime;\n\nLval parse(str txt) = build(parse(#LispExp, txt)); // <1>\n\n\nLval build((LispExp)`<IntegerLiteral il>`) = Integer(toInt("<il>"));      // <2>\nLval build((LispExp)`<AtomExp at>`)        = Atom("<at>");                // <3>\nLval build((LispExp)`( <LispExp* lst> )`)  = List([build(l) | l <- lst]);\ntest bool build2() = build((LispExp) `abc`) == Atom("abc");\ntest bool build3() = build((LispExp) `(abc 42)`) == List([Atom("abc"), Integer(42)]);\n\ntest bool parse1() = parse("123") == Integer(123);\ntest bool parse2() = parse("abc") == Atom("abc");\ntest bool parse3() = parse("()") == List([]);\ntest bool parse4() = parse("(123)") == List([Integer(123)]);\ntest bool parse5() = parse("(123 abc)") == List([Integer(123), Atom("abc")]);\n\n')),(0,r.kt)("p",null,"<1> First we define the actual ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," function: it takes a string as argument and returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Lval"),".\nIt proceeds in two steps:\n",(0,r.kt)("strong",{parentName:"p"},"  First the text is parsed using ",(0,r.kt)("inlineCode",{parentName:"strong"},"parse(#LispExp, txt)"),". The result is parse tree.\n"),"  Next, the auxiliary function ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," is used to transform the parse tree to an ",(0,r.kt)("inlineCode",{parentName:"p"},"Lval"),"."),(0,r.kt)("p",null,"<2> Function ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," is defined in cases, to handle the various parse tree forms.\nFortunately, we do not have to spell out the details of the parse tree, but we can use concrete\npatterns instead (see ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Patterns/Concrete/"},"concrete patterns"),", below)."),(0,r.kt)("p",null,"   The right-hand sides deserve some attention. Here the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"il")," is a ",(0,r.kt)("em",{parentName:"p"},"parse tree")," (!!) that represents an integer literal.\nWe first convert it to a string using string interpolation (",(0,r.kt)("inlineCode",{parentName:"p"},'"<il>"'),") and then convert it to an integer."),(0,r.kt)("p",null,"<3> The text of the atom is reconstructed in a similar fashion."),(0,r.kt)("p",null,"<4> The concrete list elements in ",(0,r.kt)("inlineCode",{parentName:"p"},"lst")," are converted one-by-one using build and are then used to\ncreate a new ",(0,r.kt)("inlineCode",{parentName:"p"},"List")," value."),(0,r.kt)("p",null,".Concrete Patterns"),(0,r.kt)("hr",null),(0,r.kt)("p",null,"We use concrete patterns in these definitions. For instance, the argument pattern "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"(LispExp)`<IntegerLiteral il>`\n")),(0,r.kt)("p",null,"says:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Match something of type ",(0,r.kt)("inlineCode",{parentName:"li"},"LispExp"),"."),(0,r.kt)("li",{parentName:"ul"},"It should be an ",(0,r.kt)("inlineCode",{parentName:"li"},"IntegerLiteral")," and bind it to a variable ",(0,r.kt)("inlineCode",{parentName:"li"},"il"),".")),(0,r.kt)("p",null,"More precisely, the text between backquotes should be a string that can be parsed according to the non-terminal\nthat precedes it (",(0,r.kt)("inlineCode",{parentName:"p"},"LispExp")," in this example). This is illustrated by the list case where the parentheses appear in the concrete pattern:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"(LispExp)`( <LispExp* lst> )`\n")),(0,r.kt)("hr",null),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>import demo::lang::Lisra::Parse;\nok\nrascal>import demo::lang::Lisra::Runtime;\nok\nrascal>parse("1");\nLval: Integer(1)\nrascal>parse("x");\nLval: Atom("x")\nrascal>parse("(+ 5 7)");\nLval: List([\n    Atom("+"),\n    Integer(5),\n    Integer(7)\n  ])\n')))}u.isMDXComponent=!0}}]);