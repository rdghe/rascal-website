"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[1120],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),o=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=o(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=o(a),d=r,k=u["".concat(p,".").concat(d)]||u[d]||m[d]||l;return a?n.createElement(k,i(i({ref:t},c),{},{components:a})):n.createElement(k,i({ref:t},c))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var o=2;o<l;o++)i[o]=a[o];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3811:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return s},metadata:function(){return o},toc:function(){return m}});var n=a(3117),r=a(102),l=(a(7294),a(3905)),i=["components"],s={sidebar_position:4,title:"Concepts"},p=void 0,o={unversionedId:"RascalConcepts",id:"RascalConcepts",title:"Concepts",description:"Synopsis.",source:"@site/docs/RascalConcepts.md",sourceDirName:".",slug:"/RascalConcepts",permalink:"/docs/RascalConcepts",draft:!1,editUrl:"https://github.com/usethesource/rascal-website/tree/website-v2/docs/docs/RascalConcepts.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Concepts"},sidebar:"tutorialSidebar",previous:{title:"Getting Help",permalink:"/docs/GettingHelp"},next:{title:"Language Reference",permalink:"/docs/Rascal"}},c={},m=[{value:"Static Typing",id:"static-typing",level:2},{value:"Datatypes",id:"datatypes",level:2},{value:"Immutable Values",id:"immutable-values",level:2},{value:"Comprehensions",id:"comprehensions",level:2},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Control Structures",id:"control-structures",level:2},{value:"Case Distinction",id:"case-distinction",level:2},{value:"Visiting",id:"visiting",level:2},{value:"Functions",id:"functions",level:2},{value:"Syntax Definition and Parsing",id:"syntax-definition-and-parsing",level:2},{value:"IDE Construction (OUTDATED)",id:"ide-construction-outdated",level:2},{value:"Code Models",id:"code-models",level:2},{value:"Enumerating",id:"enumerating",level:2},{value:"Equation Solving",id:"equation-solving",level:2},{value:"Rewriting",id:"rewriting",level:2}],u={toc:m};function d(e){var t=e.components,s=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Gentle introduction to the main concepts of the Rascal language."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Rascal is based on a dozen concepts and having a global understanding of them will help to grasp the language more\nquickly. Here we will informally explain and illustrate these concepts and often we will refer to the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal"},"Rascal Language\nReference")," for further details. In other words, we are providing here a friendly front-end for the actual\nlanguage description."),(0,l.kt)("p",null,"Most language concepts are described separately but some features we just mention here:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Rascal programs consist of modules that are organized in packages.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Modules can import other modules.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The visibility of entities declared in modules can be controlled using public/private modifiers.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Data structures may have annotations that can be explicitly used and modified.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"There is an extensive library for built-in datatypes, input/output, fact extraction from Java source code,\nvisualization, and more."))),(0,l.kt)("p",null,"Here are the concepts to be discussed:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#static-typing"},"Static Typing"),": Static type checking.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#datatypes"},"Datatypes"),": Built-in and user-defined datatypes.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#immutable-values"},"Immutable Values"),": Immutable values.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#comprehensions"},"Comprehensions"),": Comprehensions for generating values.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#pattern-matching"},"Pattern Matching"),": Pattern matching.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#control-structures"},"Control Structures"),": Success-directed control structures.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#case-distinction"},"Case Distinction"),": Case distinction via pattern matching.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#visiting"},"Visiting"),": Visiting tree structures and arbitrary values.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#functions"},"Functions"),": Functions and pattern-directed invocation.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#syntax-definition-and-parsing"},"Syntax Definition and Parsing"),": Syntax definition and parser generation\nfor new languages.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#ide-construction"},"IDE Construction"),": Extend an IDE with interactive, language-specific, features\n(Eclipse only).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#code-models"},"Code Models"),": Code models are abstract representations of source code.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#enumerating"},"Enumerating"),": Enumerating values.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#equation-solving"},"Equation Solving"),": Solving equations by fixed-point iteration.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"#rewriting"},"Rewriting"),": Rewriting using pattern-directed invocation."))),(0,l.kt)("h2",{id:"static-typing"},"Static Typing"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Static type checking."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Type Lattice",src:a(4867).Z,width:"847",height:"951"})),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Rascal has a static and a dynamic type system, which interact with eachother. The static type system is used by a type\nchecker (not yet released) to predict errors and give warnings where possibly slipups have been made. The dynamic type\nsystem ensures well-formedness of data structures and plays an important role while pattern matching, since many\nalgorithms dispatch on the types of values."),(0,l.kt)("p",null,"Rascal\u2019s static type system does not ensure that all functions will go right:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"functions may throw exceptions."),(0,l.kt)("li",{parentName:"ul"},"functions may not be defined for the specific pattern which occur on the call site.")),(0,l.kt)("p",null,"However, the static type system will produce an error when a function will certainly throw an exception, or when it is\ncertainly not defined for a certain case. Also it catches some logical tautologies and contradictions which would lead\nto dead code."),(0,l.kt)("p",null,"The Rascal types are ordered in a so-called ",(0,l.kt)("em",{parentName:"p"},"type lattice")," shown in the figure above."),(0,l.kt)("p",null,"The arrows describe a ",(0,l.kt)("em",{parentName:"p"},"subtype-of")," relation between types. The type ",(0,l.kt)("inlineCode",{parentName:"p"},"void")," is the ",(0,l.kt)("em",{parentName:"p"},"smallest")," type and is included in all\nother types and the type ",(0,l.kt)("inlineCode",{parentName:"p"},"value")," is the ",(0,l.kt)("em",{parentName:"p"},"largest")," type that includes all other types. We also see that ",(0,l.kt)("inlineCode",{parentName:"p"},"rel")," is a\nsubtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"set")," and that each ADT is a subtype of ",(0,l.kt)("inlineCode",{parentName:"p"},"node"),". A special role is played by the datatype ",(0,l.kt)("inlineCode",{parentName:"p"},"Tree")," that is the\ngeneric type of syntax trees. Syntax trees for specific languages are all subtypes of ",(0,l.kt)("inlineCode",{parentName:"p"},"Tree"),". As a result, syntax trees\ncan be addressed at two levels:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"in a generic fashion as ",(0,l.kt)("inlineCode",{parentName:"p"},"Tree")," and,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"in a specific fashion as a more precisely typed syntax tree. Finally, each ",(0,l.kt)("inlineCode",{parentName:"p"},"alias")," is structurally equivalent to one\nor more specific other types."))),(0,l.kt)("p",null,"Rascal does not provide an explicit casting mechanism (as in Java), but pattern matching can play that role."),(0,l.kt)("p",null,"The language provides higher-order, parametric polymorphism. A type aliasing mechanism allows documenting specific uses\nof a type. Built-in operators are heavily overloaded. For instance, the operator ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," is used for addition on integers\nand reals but also for list concatenation, set union and the like."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Some example can illustrate the above."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int I = 3;\n")),(0,l.kt)("p",null,"Since I is declared as type ",(0,l.kt)("inlineCode",{parentName:"p"},"int"),", we cannot assign a ",(0,l.kt)("inlineCode",{parentName:"p"},"real")," value to it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"I = 3.5;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"num N = 3;\n")),(0,l.kt)("p",null,"Since N is declared as type ",(0,l.kt)("inlineCode",{parentName:"p"},"num"),", we can assign both ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"real")," values to it:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"N = 3.5;\n")),(0,l.kt)("p",null,"Since all types are a subtype of type ",(0,l.kt)("inlineCode",{parentName:"p"},"value"),", one can assign values of any type to a variable declared as ",(0,l.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'value V = 3;\nV = "abc";\nV = false;\n')),(0,l.kt)("p",null,"We can use pattern matching to classify the actual type of a value:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'str classify(value V){\n  switch(V){\n    case str S: return "A string";\n    case bool B: return "A Boolean";\n    default: return "Another type";\n  }\n}\nclassify(V);\nV = 3.5;\nclassify(V);\n')),(0,l.kt)("p",null,"In addition to these standard examples, it is interesting that all ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#ADT"},"Algebraic Data\nTypes")," are subtypes of type ",(0,l.kt)("inlineCode",{parentName:"p"},"node"),". Let\u2019s introduce a simple ",(0,l.kt)("inlineCode",{parentName:"p"},"Color")," data type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"data Color = red(int level) | blue(int level);\n")),(0,l.kt)("p",null,"Unsurprisingly, we have:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"Color C = red(3);\n")),(0,l.kt)("p",null,"Due to subtyping, we can also have:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"node ND = red(3);\n")),(0,l.kt)("p",null,"One example of the actual application of subtypes can be found in ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#countconstructors"},"Count\nConstructors"),"."),(0,l.kt)("h2",{id:"datatypes"},"Datatypes"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Built-in and user-defined datatypes."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Rascal provides a rich set of datatypes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#boolean"},"Boolean")," (",(0,l.kt)("inlineCode",{parentName:"p"},"bool"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Infinite precision ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#integer"},"Integer")," (",(0,l.kt)("inlineCode",{parentName:"p"},"int"),"), ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#real"},"Real")," (",(0,l.kt)("inlineCode",{parentName:"p"},"real"),"), and\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#number"},"Number")," (",(0,l.kt)("inlineCode",{parentName:"p"},"num"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#string"},"String"),"s (",(0,l.kt)("inlineCode",{parentName:"p"},"str"),") that can act as templates with embedded expressions and statements.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Source code ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#location"},"Location"),"s (",(0,l.kt)("inlineCode",{parentName:"p"},"loc"),") based on an extension of Universal Resource Identifiers\n(URI) that allow precise description of text areas in local and remote files.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Date and time values (",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#datetime"},"DateTime"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"datetime"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#list"},"List")," (",(0,l.kt)("inlineCode",{parentName:"p"},"list"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#tuple"},"Tuple")," (",(0,l.kt)("inlineCode",{parentName:"p"},"tuple"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#set"},"Set")," (",(0,l.kt)("inlineCode",{parentName:"p"},"set"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#map"},"Map")," (",(0,l.kt)("inlineCode",{parentName:"p"},"map"),")")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#relation"},"Relation")," (",(0,l.kt)("inlineCode",{parentName:"p"},"rel"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Untyped tree structures (",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#node"},"Node"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"node"),").")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"User-defined algebraic datatypes (",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#ADT"},"Algebraic Data Type"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"data"),") allow the\nintroduction of problem-specific types and are a subtype of node. This makes it possible to have typed and untyped\nviews on the same data. A special case are syntax trees that are the result of parsing source files are represented\nas datatypes (",(0,l.kt)("inlineCode",{parentName:"p"},"Tree"),")."))),(0,l.kt)("p",null,"There is a wealth of built-in operators and library functions available on the standard datatypes."),(0,l.kt)("p",null,"These built-in datatypes are closely related to each other:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In a list all elements have the same static type and the order of elements matters. A list may contain the same\nvalue more than once.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In a set all elements have the same static type and the order of elements does not matter. A set contains an element\nonly once. In other words, duplicate elements are eliminated and no matter how many times an element is added to a\nset, it will occur in it only once.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In a tuple all elements (may) have a different static type. Each element of a tuple may have a label that can be\nused to select that element of the tuple.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A relation is a set of tuples which all have the same static tuple type.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A map is an associative table of (key, value) pairs. Key and value (may) have different static type and a key can\nonly be associated with a value once."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here are some examples of the built-in data types:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"th"},"Type")),(0,l.kt)("th",{parentName:"tr",align:null},(0,l.kt)("em",{parentName:"th"},"Examples")))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bool")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"true"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"false"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"11, 101, 1-11, 1123456789"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"real")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"1.01, 11.0232e201, 1-25.5"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"str")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'"abc"'),", ",(0,l.kt)("inlineCode",{parentName:"td"},'"first\\nnext"'),", ",(0,l.kt)("inlineCode",{parentName:"td"},'"result: <X>"'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"loc")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"\\|file:///etc/passwd\\|"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"dateTime")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"$2101-09-05T07:16:19.714+0200$"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tuple[T1,\u2026\u200b,_Tn]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"<1,2>"),", ",(0,l.kt)("inlineCode",{parentName:"td"},'<"john", 43, true>'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"list[T]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"[]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"[1]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"[1,2,3]"),", ",(0,l.kt)("inlineCode",{parentName:"td"},'[true, 2, "abc"]'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"set[T]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{}"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"{1,2,3,5,7}"),", ",(0,l.kt)("inlineCode",{parentName:"td"},'{"john", 4.0}'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"rel[T1,\u2026\u200b,_Tn]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{<1,2>,<2,3>,<1,3>}"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"{<1,10,100>, <2,20,200>}"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"map[T, U]")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"()"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"(1:true, 2:false)"),", ",(0,l.kt)("inlineCode",{parentName:"td"},'("a":1, "b":2)'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"node")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"f()"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"add(x,y)"),", ",(0,l.kt)("inlineCode",{parentName:"td"},'g("abc", [2,3,4])'))))),(0,l.kt)("p",null,"A fragment of the datatype that defines the abstract syntax for statements (assignment, if, while) in a programming\nlanguage would look as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"data STAT = asgStat(Id name, EXP exp)\n          | ifStat(EXP exp,list[STAT] thenpart,\n                           list[STAT] elsepart)\n          | whileStat(EXP exp, list[STAT] body)\n          ;\n")),(0,l.kt)("p",null,"Here are some examples how Rascal responds to values of the above built-in datatypes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'true;\n101;\n3.14;\n"Rascal";\n|file:///etc/passwd|;\n$2101-09-05$;\n[30, 20, 10];\n<"Rascal", 100000>;\n{"apples", "oranges", "bananas"};\n{<"apples", 10, 15>, <"oranges", 5, 7>, <"bananas", 9, 11>};\n("apples" : 100, "oranges": 150, "bananas": 75);\n"abc"(1, 2, 3);\n')),(0,l.kt)("h2",{id:"immutable-values"},"Immutable Values"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Immutable values."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Values are the basic building blocks of a language and the type of values determines how they may be used."),(0,l.kt)("p",null,"Rascal is a ",(0,l.kt)("em",{parentName:"p"},"value-oriented language"),". This means that values are immutable and are always freshly constructed from\nexisting parts. For instance, replacing an element in a list does not modify the original list but produces a new list\nthat only differs from the original one in the modified position."),(0,l.kt)("p",null,"The language also provides variables. A value can be associated with a variable as the result of an explicit assignment\nstatement: during the lifetime of a variable different (immutable) values may be assignment to it. Other ways to\nassociate a value with a variable is by way of function calls (binding of formal parameters to actual values) and as the\nresult of a successful pattern match."),(0,l.kt)("p",null,"The approach that values are immutable and that variables can be associated with different immutable values during their\nlifetime avoids sharing and aliasing problems that exist in many languages."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"First we, create a list value and assign it to two variables ",(0,l.kt)("inlineCode",{parentName:"p"},"L")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"M"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L = [1, 2, 3];\nM = L;\n")),(0,l.kt)("p",null,"Next we assign a new value to the first element of the list. The effect is that a new list value ",(0,l.kt)("inlineCode",{parentName:"p"},"[10, 2, 3]")," is\nconstructed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L[0] = 10;\n")),(0,l.kt)("p",null,"L is now associated with this new value:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"L;\n")),(0,l.kt)("p",null,"But ",(0,l.kt)("inlineCode",{parentName:"p"},"M")," is still associated with the original, unmodified, value."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"M;\n")),(0,l.kt)("p",null,"In pointer-based languages and in object-oriented languages the change to the original value of ",(0,l.kt)("inlineCode",{parentName:"p"},"L")," would also be\nvisible via ",(0,l.kt)("inlineCode",{parentName:"p"},"M"),"."),(0,l.kt)("p",null,"String values are, like all other values, also immutable. Let\u2019s experiment with the\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#replaceall"},"replaceAll")," function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import String;\nreplaceAll("abracadabra", "a", "A");\n')),(0,l.kt)("p",null,"Now assign to variables ",(0,l.kt)("inlineCode",{parentName:"p"},"S")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," the string ",(0,l.kt)("inlineCode",{parentName:"p"},'"abracadabra"')," and let\u2019s see what happens:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'S = "abracadabra";\nT = S;\nS = replaceAll("abracadabra", "a", "A");\nS;\nT;\n')),(0,l.kt)("p",null,"To summarize: all values are immutable and variables can during their lifetime be associated with different immutable\nvalues."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Immutable values contribute to referential transparence.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Immutable values maybe less efficient than mutable ones.")),(0,l.kt)("h2",{id:"comprehensions"},"Comprehensions"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Comprehensions for generating values."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Comprehensions are a notation inspired by mathematical ",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Set-builder_notation"},"set-builder\nnotation")," and ",(0,l.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/List_comprehension"},"list\ncomprehensions")," that help to write succinct definitions of lists and\nsets. They are also inspired by queries as found in a language like SQL."),(0,l.kt)("p",null,"Rascal generalizes comprehensions in various ways. Comprehensions exist for lists, sets and maps. A comprehension\nconsists of an expression that determines the successive elements to be included in the result and a list of enumerators\nand tests (boolean expressions). The enumerators produce values and the tests filter them."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#comprehensions"},"Comprehensions"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#comprehension"},"List Comprehension"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#comprehension"},"Set\nComprehension"),", and ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#comprehension"},"Map Comprehension")," for details."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"A standard example is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{ x * x | int x <- [1 .. 10], x % 3 == 0 }\n")),(0,l.kt)("p",null,"i.e., the squares of the integers in the range ",(0,l.kt)("inlineCode",{parentName:"p"},"[ 1 .. 10 ]")," that are divisible by 3. A more intriguing example (that we\ndo not give in full detail) is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"{name | /asgStat(Id name, _) <- P}\n")),(0,l.kt)("p",null,"which traverses program ",(0,l.kt)("inlineCode",{parentName:"p"},"P")," (using the ",(0,l.kt)("em",{parentName:"p"},"descendant match")," operator ",(0,l.kt)("inlineCode",{parentName:"p"},"/"),", see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#abstract"},"Patterns"),") and\nconstructs a set of all identifiers that occur on the left hand side of assignment statements in ",(0,l.kt)("inlineCode",{parentName:"p"},"P"),"."),(0,l.kt)("h2",{id:"pattern-matching"},"Pattern Matching"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Pattern matching."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Pattern matching determines whether a given pattern matches a given value. The outcome can be ",(0,l.kt)("inlineCode",{parentName:"p"},"false")," (no match) or\n",(0,l.kt)("inlineCode",{parentName:"p"},"true")," (a match). A pattern match that succeeds may bind values to variables."),(0,l.kt)("p",null,"Pattern matching is ",(0,l.kt)("em",{parentName:"p"},"the")," mechanism for case distinction (",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#switch"},"Switch")," statement) and search\n(",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#visit"},"Visit")," statement) in Rascal. Patterns can also be used in an explicit match operator ",(0,l.kt)("inlineCode",{parentName:"p"},":="),"\nand can then be part of larger boolean expressions. Since a pattern match may have more than one solution, local\nbacktracking over the alternatives of a match is provided. Patterns can also be used in\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#enumerator"},"Enumerators"),"s and control structures like ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#for"},"For")," and\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#while"},"While")," statement."),(0,l.kt)("p",null,"A very rich pattern language is provided that includes string matching based on regular expressions, matching of\nabstract patterns, and matching of concrete syntax patterns. Some of the features that are provided are list\n(associative) matching, set (associative, commutative, idempotent) matching, and deep matching of descendant patterns.\nAll these forms of matching can be used in a single pattern and can be nested. Patterns may contain variables that are\nbound when the match is successful. Anonymous (don\u2019t care) positions are indicated by the underscore (",(0,l.kt)("inlineCode",{parentName:"p"},"_"),"). See\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#patterns"},"Patterns")," for more details."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is a ",(0,l.kt)("em",{parentName:"p"},"regular expression")," that matches a line of text, finds the first alphanumeric word in it, and extracts the\nword itself as well as the before and after it (",(0,l.kt)("inlineCode",{parentName:"p"},"\\W")," matches all non-word characters; ",(0,l.kt)("inlineCode",{parentName:"p"},"\\w")," matches all word characters):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"/^<before:\\W*><word:\\w+><after:.*$>/\n")),(0,l.kt)("p",null,"Regular expressions follow the Java regular expression syntax with one exception: instead of using numbered groups to\nrefer to parts of the subject string that have been matched by a part of the regular expression we use the notation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"Name</emphasis>:_RegularExpression_>\n")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"RegularExpression")," matches, the matched substring is assigned to string variable ",(0,l.kt)("inlineCode",{parentName:"p"},"Name"),"."),(0,l.kt)("p",null,"The following abstract pattern matches the abstract syntax of a while statement defined earlier:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"whileStat(EXP Exp, list[STAT] Stats)\n")),(0,l.kt)("p",null,"Variables in a pattern are either explicitly declared in the pattern itself---as done in the example---or they may be\ndeclared in the context in which the pattern occurs. So-called multi-variables in list and set patterns are declared by\na ",(0,l.kt)("inlineCode",{parentName:"p"},"  ")," suffix: ",(0,l.kt)("inlineCode",{parentName:"p"},"X</emphasis>")," is thus an abbreviation for ",(0,l.kt)("inlineCode",{parentName:"p"},"list[\u2026\u200b] X")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"set[\u2026\u200b] X"),", where the precise element type\ndepends on the context. The above pattern can then be written as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"whileStat(EXP Exp, Stats*)\n")),(0,l.kt)("p",null,"or, if you are not interested in the actual value of the statements as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"whileStat(EXP Exp, _*)\n")),(0,l.kt)("p",null,"When there is a grammar for this example language, we can also write concrete patterns as described in ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#concrete"},"Concrete\nPatterns"),"."),(0,l.kt)("h2",{id:"control-structures"},"Control Structures"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Success-directed control structures."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"The flow of Rascal program execution is completely explicit. Boolean expressions determine choices that drive the\ncontrol structures. Only local backtracking is provided in the context of boolean expressions and pattern matching."),(0,l.kt)("p",null,"Control structures like ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#if"},"If"),", ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#while"},"While")," and ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#for"},"For"),"\nstatement are driven by Boolean expressions. Actually, combinations of generators and Boolean expressions can be used to\ndrive the control structures. In the latter case, the Boolean expression is executed for each generated value."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"A classical if statement:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"if(N <= 0)\n     return 1;\n  else\n     return N * fac(N - 1);\n")),(0,l.kt)("p",null,"A combination of a generator and a test:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"for(/docs/asgStat(Id name, _) <- P, size(name) > 10){\n    println(name);\n}\n")),(0,l.kt)("p",null,"This statement prints all identifiers in assignment statements (",(0,l.kt)("inlineCode",{parentName:"p"},"asgStat"),") that consist of more than 10 characters."),(0,l.kt)("h2",{id:"case-distinction"},"Case Distinction"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Case distinction via pattern matching."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"The switch statement as known from C and Java is generalized: the subject value to switch on may be an arbitrary value\nand the cases are arbitrary patterns followed by a statement. Each case is comparable to a ",(0,l.kt)("em",{parentName:"p"},"transaction"),": when the\npattern succeeds and the following statement is executed successfully, all changes to variables made by the statement\nare committed and thus become permanent. The variables bound by the pattern are always local to the statement associated\nwith the case."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#switch"},"Switch"),",",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#visit"},"Visit")," and ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#pattern-with-action"},"Pattern With\nAction")," for more details."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"We use the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#colored-trees"},"ColoredTrees")," datatype as example and use a switch to distinguish between red\nand black nodes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'data ColoredTree =\n      leaf(int N)\n    | red(ColoredTree left, ColoredTree right)\n    | black(ColoredTree left, ColoredTree right);\nColoredTree CT = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));\nimport IO;\nswitch (CT){\ncase red(_, _):\n     println("A red root node");\ncase black(_, _):\n     println("A black root node");\n}\n')),(0,l.kt)("h2",{id:"visiting"},"Visiting"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Visiting tree structures and arbitrary values."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Visiting the elements of a data structure is one of the most common operations in our domain and the visitor design\npattern is a solution known to every software engineer. Given a tree-like data structure we want to perform an operation\non some (or all) nodes of the tree. The purpose of the visitor design pattern is to decouple the logistics of visiting\neach node from the actual operation on each node. In Rascal the logistics of visiting is completely automated."),(0,l.kt)("p",null,"Visiting is achieved by way of visit expressions that resemble the switch statement. A visit expression traverses an\narbitrarily complex subject value and applies a number of cases to all its subtrees. All the elements of the subject are\nvisited. When one of the cases matches the statements associated with that case are executed. These cases may:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"cause some side effect, i.e., assign a value to local or global variables;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"execute an ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#insert"},"Insert")," statement that replaces the current element;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"execute a ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#fail"},"Fail")," statement that causes the match for the current case to fail."))),(0,l.kt)("p",null,"The value of a visit expression is the original subject value with all replacements made as dictated by matching cases.\nThe traversal order in a visit expressions can be explicitly defined by the programmer."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Examples of visiting are, for instance, given in the Recipes ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#colored-trees"},"ColoredTrees")," and\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#derivative"},"Derivative"),"."),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Functions and pattern-directed invocation."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Functions allow the definition of frequently used operations. They have a name and formal parameters. They are\nexplicitly declared and are fully typed. Functions can also be used as values thus enabling higher-order functions.\nRascal is a higher-order language in which functions are first-class values."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#function-declaration"},"Function Declaration")," for details."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Here is an example of a function that counts the number of assignment statements in a program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"int countAssignments(PROGRAM P){\n    int n = 0;\n    visit (P){\n    case asgStat(_, _):\n         n += 1;\n    }\n    return n;\n}\n")),(0,l.kt)("p",null,"Consider the following use of higher-order functions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"int double(int x) { return 2 * x; }\n\nint triple(int x) { return 3 * x; }\n\nint f(int x, int (int) multi){ return multi(x); }\n")),(0,l.kt)("p",null,"The functions ",(0,l.kt)("inlineCode",{parentName:"p"},"double")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"triple")," simply multiply their argument with a constant. Function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is, however, more\ninteresting. It takes an integer ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," and a function ",(0,l.kt)("inlineCode",{parentName:"p"},"multi")," (with integer argument and integer result) as argument and\napplies multi to its own argument. ",(0,l.kt)("inlineCode",{parentName:"p"},"f(5, triple)")," will hence return ",(0,l.kt)("inlineCode",{parentName:"p"},"15"),". Function values can also be created\nanonymously as illustrated by the following, alternative, manner of writing this same call to ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"f(5, int (int y){return 3 * y;});\n")),(0,l.kt)("p",null,"Here the second argument of ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is an anonymous function."),(0,l.kt)("h2",{id:"syntax-definition-and-parsing"},"Syntax Definition and Parsing"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Syntax definition and parser generation for new languages."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"All source code analysis projects need to extract information directly from the source code. There are two main\napproaches to this:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("em",{parentName:"p"},"Lexical information"),": Use regular expressions to extract useful, but somewhat superficial, flat, information. This\ncan be achieved using regular expression patterns, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#regular"},"Regular Expression Pattern"),"s.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("em",{parentName:"p"},"Structured information"),": Use syntax analysis to extract the complete, nested, structure of the source code in the\nform of a syntax tree. Rascal can directly manipulate the parse trees, but it also enables user-defined mappings\nfrom parse tree to abstract syntax tree."))),(0,l.kt)("p",null,"Using ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#syntax-definition"},"Syntax Definitions")," you can define the syntax of any (programming)\nlanguage. Then Rascal:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"will generate the parser, and")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"will provide pattern matching and pattern construction on parse trees and abstract syntax trees, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#abstract"},"Abstract\nPatterns")," and ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#concrete"},"Concrete Patterns"),"."))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"Let\u2019s use the Exp language as example. It contains the following elements:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Integer constants, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"123"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A multiplication operator, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"3*4"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"An addition operator, e.g., ",(0,l.kt)("inlineCode",{parentName:"p"},"3+4"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Multiplication is left-associative and has precedence over addition.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Addition is left-associative.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Parentheses can be used to override the precedence of the operators."))),(0,l.kt)("p",null,"Here are some examples:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"123"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"2+3+4"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"2+3*4"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"(2+3)*4")))),(0,l.kt)("p",null,"The EXP language can be defined as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Exp::Concrete::WithLayout::Syntax\n\nlayout Whitespace = [\\t-\\n\\r\\ ]*; \n\nlexical IntegerLiteral = [0-9]+;\n\nstart syntax Exp\n  = IntegerLiteral\n  | bracket "(" Exp ")"\n  > left Exp "*" Exp\n  > left Exp "+" Exp\n  ;\n')),(0,l.kt)("p",null,"Now you may parse and manipulate programs in the EXP language. Let\u2019s demonstrate parsing an expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import demo::lang::Exp::Concrete::WithLayout::Syntax;\nimport ParseTree;\nparse(#start[Exp], "2+3*4");\n')),(0,l.kt)("p",null,"First we import the syntax definition and the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#parsetree"},"ParseTree")," module that provides the parsing\nfunctionality. Finally, we parse ",(0,l.kt)("inlineCode",{parentName:"p"},"2+3*4")," using the start symbol ",(0,l.kt)("inlineCode",{parentName:"p"},"Exp"),"."),(0,l.kt)("p",null,"Don\u2019t be worried, we are just showing the resulting parse tree here. It intended for programs and not for humans. The\npoints we want to make are:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Rascal grammars are relatively easy to read and write (unfortunately, writing grammars will never become simple).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Parser generation is completely implicit.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Given a syntax definition, it can be used immediately for parsing."))),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes"},"Recipes")," for a more extensive presentation of the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#exp"},"EXP")," language and\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#languages"},"Languages")," for other language examples."),(0,l.kt)("h2",{id:"ide-construction-outdated"},"IDE Construction (OUTDATED)"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Extend an IDE with interactive, language-specific, features (Eclipse only)."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Meta-programs become most useful, when they are integrated with an Interactive Development Environment (IDE)."),(0,l.kt)("p",null,"A Rascal program running inside Eclipse can get access to many of the services provided by Eclipse such as syntax\nhighlighting, outlining, documentation hovering and much more."),(0,l.kt)("p",null,"Rascal uses the services of the IDE Meta-tooling Platform, or ",(0,l.kt)("a",{parentName:"p",href:"http://www.eclipse.org/imp/"},"IMP")," for short, a collection\nof API and tools to support constructing IDEs for programming languages and domain specific languages. Rascal is also\npart of the collection of IMP tools and (will be) hosted shortly on eclipse.org."),(0,l.kt)("p",null,"Using the ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#ide"},"IDE library"),", you can instantiate the services that IMP provides for any language\nimplemented in Rascal."),(0,l.kt)("p",null,"To instantiate an IDE for a language implemented using Rascal, use the following steps:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define the grammar for the language.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define a parse function for the language.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Register the language."))),(0,l.kt)("p",null,"The following IDE features are available"),(0,l.kt)("h2",{id:"code-models"},"Code Models"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Code models are abstract representations of source code"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"You can use any of Rascal\u2019s ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#values"},"Values")," to represent facts about source code. For example,\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#ADT"},"Algebraic Data Types")," can be used to define abstract syntax trees and\n",(0,l.kt)("a",{parentName:"p",href:"#values-Relation"},"???")," are used to represent call graphs. We consistently use ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#location"},"Locations")," to\nrefer to source code artifacts, either physically (",(0,l.kt)("inlineCode",{parentName:"p"},"|file:///tmp/HelloWorld.java|"),") or logically\n(",(0,l.kt)("inlineCode",{parentName:"p"},"|java+class://java/lang/Object|"),")."),(0,l.kt)("p",null,"Specifically we have standardized a set of models to represent source code which are ready for computing metrics:\n","#","/Libraries","#","analysis-m3","[","M3","]",". This M3 model consists of:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"an open (extensible) set of ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#relation"},"Relations")," between source code artifacts.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"a number of extensible ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#ADT"},"Algebraic Data Types")," for representing abstract\nsyntax trees."))),(0,l.kt)("p",null,"The core language independent model can be found here: ",(0,l.kt)("a",{parentName:"p",href:"/docs/Libraries#m3"},"analysis::m3"),"."),(0,l.kt)("p",null,"Extensions for representing facts about specific languages:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/docs/Libraries#m3"},"lang::java::m3"),".")),(0,l.kt)("h2",{id:"enumerating"},"Enumerating"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Enumerating values."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Enumerating regards the enumeration of the values in a given (finite) domain, be it the elements in a list, the\nsubstrings of a string, or all the nodes in a tree. Each value that is enumerated is first matched against a pattern\nbefore it can possibly contribute to the result of the enumerator. An enumerator yields ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," as long as it has\ngenerated a new value, and ",(0,l.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#enumerator"},"Enumerator")," for details."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"int x <- { 1, 3, 5, 7, 11 }\nint x <- [ 1 .. 10 ]\n/asgStat(Id name, _) <- P\n")),(0,l.kt)("p",null,"The first two produce the integer elements of a set of integers, respectively, a range of integers. Observe that the\nleft-hand side of an enumerator is a pattern, of which ",(0,l.kt)("inlineCode",{parentName:"p"},"int x")," is a specific instance. The use of more general patterns\nis illustrated by the third enumerator that does a deep traversal (as denoted by the descendant operator ",(0,l.kt)("inlineCode",{parentName:"p"},"/"),") of the\ncomplete program ",(0,l.kt)("inlineCode",{parentName:"p"},"P")," (that is assumed to have a ",(0,l.kt)("inlineCode",{parentName:"p"},"PROGRAM")," as value) and only yields statements that match the assignment\npattern (",(0,l.kt)("inlineCode",{parentName:"p"},"asgStat"),"). Note the use of an anonymous variable at the ",(0,l.kt)("inlineCode",{parentName:"p"},"EXP")," position in the pattern."),(0,l.kt)("p",null,"Let\u2019s practice some of these examples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int x <- {};\n")),(0,l.kt)("p",null,"The enumerator does not produce any value and returns ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"int x <- {1, 3, 5, 7, 11 };\nx;\n")),(0,l.kt)("p",null,"Well, this is a disappointing experience. The generator returned ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," since it did produce a value. Apparently, we\ncannot inspect the value of the variable ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," that was bound."),(0,l.kt)("p",null,"Another example that results in an error:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"str x <- {1, 3, 5, 7, 11 };\n")),(0,l.kt)("p",null,"Here, the enumerator produces its first integer value, an attempt is made to assign this to variable ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," that is\ndeclared as string, and an error results."),(0,l.kt)("p",null,"A more satisfying use is as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"{ x * x | int x <- {1, 3, 5, 7, 11 }};\n")),(0,l.kt)("p",null,"When used inside ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#comprehensions"},"Comprehensions"),", or ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#for"},"For"),",\n",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#do"},"Do"),", or ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#while"},"While")," statement, all values of the generator will be\nproduced and used. The variables that are introduced by a enumerator are local to the construct in which the enumerator\nis used. Here is a similar example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'import IO;\nfor(int x <- {1, 3, 5, 7, 11 })\n    println("x = <x>");\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Pitfalls.")),(0,l.kt)("p",null,"The variables that are bound by an enumerator are local to the statement in which the enumerator is used."),(0,l.kt)("h2",{id:"equation-solving"},"Equation Solving"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Solving equations by fixed-point iteration."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"Many problems can be solved by forms of ",(0,l.kt)("em",{parentName:"p"},"constraint solving"),". This is a declarative way of programming: specify the\nconstraints that a problem solution should satisfy and how potential solutions can be generated. The actual solution (if\nany) is found by enumerating solutions and testing their compliance with the constraints."),(0,l.kt)("p",null,"Rascal provides a ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#solve"},"Solve")," statement that helps writing constraint solvers."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"A typical example is data flow analysis where the propagation of values through a program can be described by a set of\nequations. Their solution can be found with the solve statement."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("strong",{parentName:"p"},"Warning")),(0,l.kt)("p",{parentName:"blockquote"},"add links")),(0,l.kt)("h2",{id:"rewriting"},"Rewriting"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Synopsis.")),(0,l.kt)("p",null,"Rewriting using pattern-directed invocation"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Description.")),(0,l.kt)("p",null,"A rewrite rule is a recipe on how to simplify values. Remember: (",(0,l.kt)("em",{parentName:"p"},"a")," + ",(0,l.kt)("em",{parentName:"p"},"b"),")",(0,l.kt)("sup",null,"2")," = ",(0,l.kt)("em",{parentName:"p"},"a"),(0,l.kt)("sup",null,"2")," + 2 ",(0,l.kt)("em",{parentName:"p"},"ab")," +\n",(0,l.kt)("em",{parentName:"p"},"b"),(0,l.kt)("sup",null,"2"),"? A rewrite rule has a pattern as left-hand side\u2009\u2014\u2009here: (",(0,l.kt)("em",{parentName:"p"},"a")," + ",(0,l.kt)("em",{parentName:"p"},"b"),")",(0,l.kt)("sup",null,"2"),"\u2009\u2014\u2009and a replacement as\nright-hand side\u2009\u2014\u2009here: ",(0,l.kt)("em",{parentName:"p"},"a"),(0,l.kt)("sup",null,"2")," + 2 ",(0,l.kt)("em",{parentName:"p"},"ab")," + ",(0,l.kt)("em",{parentName:"p"},"b"),(0,l.kt)("sup",null,"2"),". Given a value and a set of rewrite rules the\npatterns are tried on every subpart of the value and replacements are made if a match is successful. This is repeated as\nlong as some pattern matches."),(0,l.kt)("p",null,"Rascal has ancestors, notably ",(0,l.kt)("a",{parentName:"p",href:"http://www.meta-environment.org/"},"ASF+SDF"),", where rewriting was the most important\ncomputation mechanism. In Rascal, rewriting can be achieved using pattern-directed invocation, see ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#function"},"Function\nDeclaration"),", possibly combined with a ",(0,l.kt)("a",{parentName:"p",href:"/docs/Rascal#visit"},"Visit")," statement."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Examples.")),(0,l.kt)("p",null,"In a package for symbolic differentiation it is desirable to keep expressions in simplified form in order to avoid\nintermediate results like ",(0,l.kt)("inlineCode",{parentName:"p"},"add(product(con(1), x), mul(con(0), y))")," that can be simplified to ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),". The following\ndefinitions achieve this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},"Exp simp(add(con(n), con(m))) = con(n + m);   \nExp simp(mul(con(n), con(m))) = con(n * m);\n\nExp simp(mul(con(1), Exp e))  = e;\nExp simp(mul(Exp e, con(1)))  = e;\nExp simp(mul(con(0), Exp e))  = con(0);\nExp simp(mul(Exp e, con(0)))  = con(0);\n\nExp simp(add(con(0), Exp e))  = e;\nExp simp(add(Exp e, con(0)))  = e;\n\ndefault Exp simp(Exp e)       = e;            \n\nExp simplify(Exp e){                          \n  return bottom-up visit(e){\n           case Exp e1 => simp(e1)\n         }\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Definitions of the function ",(0,l.kt)("inlineCode",{parentName:"p"},"simp")," are given with different patterns as formal argument. Each definition is\nresponsible for one particular simplification (here is where the similarity with rewrite rules surfaces).")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"A default for ",(0,l.kt)("inlineCode",{parentName:"p"},"simp")," is given: if no other definition applies, the default one is used.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The actual ",(0,l.kt)("inlineCode",{parentName:"p"},"simplify")," function: it performs a bottom up visit of the expression, replacing each subexpression by a\nsimplified version."))),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes#derivative"},"Derivative")," for a full explanation of this example."))}d.isMDXComponent=!0},4867:function(e,t,a){t.Z=a.p+"assets/images/type-lattice-9a476acc338596237526acde1ad0c66b.png"}}]);