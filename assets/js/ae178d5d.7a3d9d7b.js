"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[25422],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var r=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,l=function(e,n){if(null==e)return{};var t,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,l=e.mdxType,a=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=s(t),d=l,f=u["".concat(c,".").concat(d)]||u[d]||m[d]||a;return t?r.createElement(f,o(o({ref:n},p),{},{components:t})):r.createElement(f,o({ref:n},p))}));function d(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var a=t.length,o=new Array(a);o[0]=u;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:l,o[1]=i;for(var s=2;s<a;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},14671:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>s});var r=t(87462),l=(t(67294),t(3905));const a={title:"Call Lifting"},o=void 0,i={unversionedId:"Recipes/Common/CallLifting/index",id:"Recipes/Common/CallLifting/index",title:"Call Lifting",description:"Synopsis",source:"@site/docs/Recipes/Common/CallLifting/index.md",sourceDirName:"Recipes/Common/CallLifting",slug:"/Recipes/Common/CallLifting/",permalink:"/docs/Recipes/Common/CallLifting/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Recipes/Common/CallLifting/index.md",tags:[],version:"current",frontMatter:{title:"Call Lifting"},sidebar:"tutorialSidebar",previous:{title:"Call Analysis",permalink:"/docs/Recipes/Common/CallAnalysis/"},next:{title:"Colored Trees",permalink:"/docs/Recipes/Common/ColoredTrees/"}},c={},s=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4}],p={toc:s};function m(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"synopsis"},"Synopsis"),(0,l.kt)("p",null,"Lift procedure calls to component calls."),(0,l.kt)("h4",{id:"description"},"Description"),(0,l.kt)("p",null,"A frequently occurring problem is that we know the call relation of a system but that we want to understand it at the component level rather than at the procedure level. If it is known to which component each procedure belongs, it is possible to lift the call relation to the component level. Actual lifting amounts to translating each call between procedures by a call between components. "),(0,l.kt)("h4",{id:"examples"},"Examples"),(0,l.kt)("p",null,"Consider the following figure:"),(0,l.kt)("p",null,"![null][parts.png]","(/assets/Recipes/Common/CallLifting/parts.png)"),(0,l.kt)("p",null,"(a) Shows the calls between procedures;\n(b) shows how procedures are part of a system component.\n(c) shows how the call relation given in (a) can be lifted to the component level."),(0,l.kt)("p",null,"The situation can be characterized by:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A call relation between procedures"),(0,l.kt)("li",{parentName:"ul"},"A partOf relation between procedures and components")),(0,l.kt)("p",null,"The problem is now to lift the call relation using the information in the partOf relation.\nIn other words: a call between two procedures will be lifted to\na call between the components to which each procedure belongs."),(0,l.kt)("p",null,"Here is a solution:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'\nmodule demo::common::Lift\n\n\n\nalias proc = str;\nalias comp = str;\n\nrel[comp,comp] lift(rel[proc,proc] aCalls, rel[proc,comp] aPartOf){\n    return { <C1, C2> | <proc P1, proc P2> <- aCalls, \n                        <comp C1, comp C2> <- aPartOf[P1] * aPartOf[P2] };\n}\n\n// Test set-up\n\nrel[proc,proc] Calls = {<"main", "a">, <"main", "b">, <"a", "b">, <"a", "c">, <"a", "d">, \n                        <"b", "d">};        \n\nrel[proc, comp] PartOf = {<"main", "Appl">, <"a", "Appl">, <"b", "DB">, \n                          <"c", "Lib">, <"d", "Lib">};\n\nrel[comp,comp] ComponentCalls = lift(Calls, PartOf);\n\n')),(0,l.kt)("p",null,"And we can use it as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rascal>import demo::common::Lift;\nok\n")),(0,l.kt)("p",null,"Encode the call relation and partOf relation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},'rascal>calls = {<"main", "a">, <"main", "b">, <"a", "b">, <"a", "c">, <"a", "d">, <"b", "d">};        \nrel[str,str]: {\n  <"b","d">,\n  <"a","b">,\n  <"a","c">,\n  <"a","d">,\n  <"main","a">,\n  <"main","b">\n}\nrascal>partOf = {<"main", "Appl">, <"a", "Appl">, <"b", "DB">, <"c", "Lib">, <"d", "Lib">};\nrel[str,str]: {\n  <"a","Appl">,\n  <"b","DB">,\n  <"c","Lib">,\n  <"d","Lib">,\n  <"main","Appl">\n}\n')),(0,l.kt)("p",null,"and do the lifting:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},'rascal>lift(calls, partOf);\nrel[str,str]: {\n  <"DB","Lib">,\n  <"Appl","Lib">,\n  <"Appl","Appl">,\n  <"Appl","DB">\n}\n')),(0,l.kt)("p",null,"Please verify that this corresponds exactly to (c) in the figure above."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},"")))}m.isMDXComponent=!0}}]);