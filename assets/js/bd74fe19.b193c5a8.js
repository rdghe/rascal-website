"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[44667],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},67595:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(83117),r=(n(67294),n(3905));const o={authors:["jvinju"],title:"The Language Interaction Design of Concrete Syntax"},s=void 0,i={permalink:"/blog/2013/08/02/the-language-interaction-design-of-concrete-syntax",editUrl:"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2013-08-02-the-language-interaction-design-of-concrete-syntax.md",source:"@site/blog/2013-08-02-the-language-interaction-design-of-concrete-syntax.md",title:"The Language Interaction Design of Concrete Syntax",description:"This post dives into some of the design decisions regarding the manipulation of parse trees and abstract syntax trees in Rascal using concrete syntax notation.",date:"2013-08-02T00:00:00.000Z",formattedDate:"August 2, 2013",tags:[],readingTime:3.22,hasTruncateMarker:!1,authors:[{name:"Jurgen Vinju",title:"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team",url:"http://homepages.cwi.nl/~jurgenv",imageURL:"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg",key:"jvinju"}],frontMatter:{authors:["jvinju"],title:"The Language Interaction Design of Concrete Syntax"},prevItem:{title:"From imperative programming to functional programming",permalink:"/blog/2015/03/02/from-imperative-to-functional"},nextItem:{title:"A DSL in 36 lines of code",permalink:"/blog/2013/07/29/dsl-in-36-lines-of-code"}},l={authorsImageUrls:[void 0]},c=[{value:"Definitions",id:"definitions",level:2},{value:"Concrete syntax",id:"concrete-syntax",level:3},{value:"Lisp S-expressions",id:"lisp-s-expressions",level:3},{value:"XML",id:"xml",level:3},{value:"YAML/JSON",id:"yamljson",level:3},{value:"Meta Variables",id:"meta-variables",level:2},{value:"History",id:"history",level:2},{value:"Quotes",id:"quotes",level:2},{value:"Types",id:"types",level:2},{value:"Rascal",id:"rascal",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This post dives into some of the design decisions regarding the manipulation of parse trees and abstract syntax trees in Rascal using ",(0,r.kt)("em",{parentName:"p"},"concrete syntax")," notation. "),(0,r.kt)("h2",{id:"definitions"},"Definitions"),(0,r.kt)("p",null,"What we call ",(0,r.kt)("em",{parentName:"p"},"concrete syntax")," is a notation for syntax trees that is embedded into the expression notation of meta programming languages. This notation should be equal, or mostly equal, to the surface syntax of the language that is represented by the syntax trees, ",(0,r.kt)("em",{parentName:"p"},"and the expressions are still syntactically and statically checked for correctness"),". As far as notations for syntax trees go, concrete syntax is a clear winner. Let's compare some expressions representing a piece of C code."),(0,r.kt)("h3",{id:"concrete-syntax"},"Concrete syntax"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if (a && b) { \n  println("a and b"); \n}\n')),(0,r.kt)("h3",{id:"lisp-s-expressions"},"Lisp S-expressions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'(if ((and (id "a") (id "b")) \n    (block \n      ((call (id "println") (args (strconst "a and b")))\n    )\n)\n')),(0,r.kt)("h3",{id:"xml"},"XML"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<if>\n  <and>\n    <id>a</id>\n    <id>b</id>\n  </and>\n  <block>\n    <call>\n      <id>println</id>\n      <args>\n        <strconst>a and b</strconst>\n      </args>\n    </call>\n  </block>\n</if>\n")),(0,r.kt)("h3",{id:"yamljson"},"YAML/JSON"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"if:\n  - and:\n     - id: a\n     - id: b\n  - block:\n     - call:\n        - id: println\n        - args:\n          - strconst: a and b \n")),(0,r.kt)("p",null,"For the degenerate case of a single node with no children, of course any abstract notation wins. As soon as we have nesting, even marginally interesting code snippets, however, concrete syntax wins by landslide in terms of brevity and cognitive overload."),(0,r.kt)("h2",{id:"meta-variables"},"Meta Variables"),(0,r.kt)("p",null,"The above examples showed only literal program fragments. One distinguishing feature, however, of concrete syntax is ..."),(0,r.kt)("h2",{id:"history"},"History"),(0,r.kt)("p",null,"The concrete syntax feature appeared first, as far as I know and please correct me if I am wrong, in the early 1980's in experimental meta programming systems and  algebraic specification systems. There was a concept of ",(0,r.kt)("em",{parentName:"p"},"mix fix")," operator syntax where algebraic operators would not only be exclusively prefix, postfix or infix, but all at the same time. This would allow, for example, to define readable algebraic operators with arity larger than two such as ",(0,r.kt)("inlineCode",{parentName:"p"},"if _ then _ else _"),". Some systems started to use BNF to define mix fix functions, and concrete syntax was born. In extreme cases, such as ASF+SDF any context-free grammar rule was allowed to be an operator, while in other systems more restrictions could apply. "),(0,r.kt)("p",null,"If you are interested in what this all looked like, also in the years after that, the following is a list of names of systems that used or use mixfix operators or concrete syntax in some form or another:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ASF+SDF"),(0,r.kt)("li",{parentName:"ul"},"TXL"),(0,r.kt)("li",{parentName:"ul"},"StrategoXT"),(0,r.kt)("li",{parentName:"ul"},"Maude"),(0,r.kt)("li",{parentName:"ul"},"ELAN"),(0,r.kt)("li",{parentName:"ul"},"OBJ"),(0,r.kt)("li",{parentName:"ul"},"Smarttools"),(0,r.kt)("li",{parentName:"ul"},"Repleo"),(0,r.kt)("li",{parentName:"ul"},"SugarJ"),(0,r.kt)("li",{parentName:"ul"},"K")),(0,r.kt)("p",null,"People that I know by heart who published on the concrete syntax feature are Annika Aasa, Kent Petersson, Dan Synek, Chris Verhoef, Paul Klint, Eelco Visser, Peter Borovansky, Jan Rekers, Martin Bravenboer, Rob Vermaas, Radu Mereuta, Dorel Lucanu, Jeroen Arnoldus, and yours truly. There must be more."),(0,r.kt)("p",null,"Concrete syntax should not be confused with string or file templates, such as found in PHP-like template expanders. The difference is that such templates are flat strings that are not statically checked or parsed. With concrete syntax you can not write a pattern that will never match, and you can not write a pattern that will construct a syntactically incorrect output."),(0,r.kt)("p",null,"Concrete syntax is also strongly related to the older concept of ",(0,r.kt)("em",{parentName:"p"},"syntax macros")," (1970's). The similarity is that with syntax macros the user can also define the syntax of functions. The difference is that syntax macros are always expanded into the host language, while with concrete syntax the objects can be manipulated in an arbitrary way, often not to expand into the host language but rather to output a transformed output form.  "),(0,r.kt)("p",null,"So, concrete syntax is not new or novel in any way. It is a good idea nevertheless, and it comes with interesting language usability trade-offs."),(0,r.kt)("h2",{id:"quotes"},"Quotes"),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("h2",{id:"rascal"},"Rascal"))}u.isMDXComponent=!0}}]);