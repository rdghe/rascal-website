"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[90960],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(t),d=l,g=m["".concat(s,".").concat(d)]||m[d]||u[d]||r;return t?a.createElement(g,i(i({ref:n},c),{},{components:t})):a.createElement(g,i({ref:n},c))}));function d(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},99714:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(87462),l=(t(67294),t(3905));const r={title:"Compile"},i=void 0,o={unversionedId:"Recipes/Languages/Pico/Compile/index",id:"Recipes/Languages/Pico/Compile/index",title:"Compile",description:"Synopsis",source:"@site/docs/Recipes/Languages/Pico/Compile/index.md",sourceDirName:"Recipes/Languages/Pico/Compile",slug:"/Recipes/Languages/Pico/Compile/",permalink:"/docs/Recipes/Languages/Pico/Compile/",draft:!1,tags:[],version:"current",frontMatter:{title:"Compile"},sidebar:"tutorialSidebar",previous:{title:"Assembly",permalink:"/docs/Recipes/Languages/Pico/Assembly/"},next:{title:"ControlFlow",permalink:"/docs/Recipes/Languages/Pico/ControlFlow/"}},s={},p=[{value:"Synopsis",id:"synopsis",level:4},{value:"Examples",id:"examples",level:4}],c={toc:p};function u(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h4",{id:"synopsis"},"Synopsis"),(0,l.kt)("p",null,"Compile a Pico program to assembly language."),(0,l.kt)("h4",{id:"examples"},"Examples"),(0,l.kt)("p",null,"The Pico compiler translates Pico programs to ",(0,l.kt)("a",{parentName:"p",href:"/docs/Recipes/Languages/Pico/Assembly/"},"Assembly")," language programs."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal"},'module demo::lang::Pico::Compile\n\nimport Prelude;\nimport demo::lang::Pico::Abstract;\nimport demo::lang::Pico::Assembly;\nimport demo::lang::Pico::Load;\n\nalias Instrs = list[Instr]; \n\n\n// highlight-next-line\nInstrs compileExp(natCon(int N)) = [pushNat(N)]; \n\nInstrs compileExp(strCon(str S)) = [pushStr(substring(S,1,size(S)-1))];\n\nInstrs compileExp(id(PicoId Id)) = [rvalue(Id)];\n\n// highlight-next-line\nInstrs compileExp(add(EXP E1, EXP E2)) \n  = [*compileExp(E1), *compileExp(E2), add2()];\n\nInstrs compileExp(sub(EXP E1, EXP E2)) \n  = [*compileExp(E1), *compileExp(E2), sub2()];\n\nInstrs compileExp(conc(EXP E1, EXP E2)) \n  = [*compileExp(E1), *compileExp(E2), conc2()];\n  \n// highlight-next-line\nprivate int nLabel = 0; \n\n\nprivate str nextLabel() {\n  nLabel += 1;\n  return "L<nLabel>";\n}\n\n\nInstrs compileStat(asgStat(PicoId Id, EXP Exp)) \n  = [lvalue(Id), *compileExp(Exp), assign()];\n    \n// highlight-next-line\nInstrs compileStat(ifElseStat(EXP Exp, \n                              list[STATEMENT] Stats1,\n                              list[STATEMENT] Stats2)){\n  \n  elseLab = nextLabel();\n  endLab = nextLabel();  \n  return [*compileExp(Exp), \n          gofalse(elseLab), \n          *compileStats(Stats1),  \n          go(endLab), \n          label(elseLab), \n          *compileStats(Stats2), \n          label(endLab)];\n}\n\nInstrs compileStat(whileStat(EXP Exp, \n                             list[STATEMENT] Stats1)) {\n  entryLab = nextLabel();\n  endLab = nextLabel();\n  return [label(entryLab), \n          *compileExp(Exp), \n          gofalse(endLab), \n          *compileStats(Stats1), \n          go(entryLab), \n          label(endLab)];\n}\n\n\nInstrs compileStats(list[STATEMENT] Stats1) \n// highlight-next-line\n  = [ *compileStat(S) | S <- Stats1 ];\n  \n\nInstrs compileDecls(list[DECL] Decls) =\n// highlight-next-line\n  [ ((tp == natural()) ? dclNat(Id) : dclStr(Id)) |      \n    decl(PicoId Id, TYPE tp) <- Decls\n  ];\n\n\n// highlight-next-line\nInstrs compileProgram(PROGRAM P){ \n  nLabel = 0;\n  if (program(list[DECL] Decls, list[STATEMENT] Series) := P) {\n     return [*compileDecls(Decls), *compileStats(Series)];\n  } else {\n    throw "Cannot happen";\n  }\n}\n\nInstrs compileProgram(str txt) = compileProgram(load(txt));\n\n')),(0,l.kt)("p",null,"Notes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We introduce ",(0,l.kt)("inlineCode",{parentName:"li"},"Instrs")," as an alias for a list of assembly language instructions."),(0,l.kt)("li",{parentName:"ul"},"The compiler consists of the functions ",(0,l.kt)("inlineCode",{parentName:"li"},"compileExp"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"compileStat"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"compileStats"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"compileDecls")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"compileProgram"),".\nThey all have a program fragment as argument and return the corresponding list of instructions."),(0,l.kt)("li",{parentName:"ul"},"When compiling expressions, note how ",(0,l.kt)("em",{parentName:"li"},"list splicing")," (see ","[Rascal:Values/List]",") is used to insert the instructions that are generated for the operands of an operator into the list of instructions for the whole expression."),(0,l.kt)("li",{parentName:"ul"},"In order to conveniently write code generators for statements, we introduce a unique label generator. The global variable ",(0,l.kt)("inlineCode",{parentName:"li"},"nLabel")," contains\nthe index of the last generated label and ",(0,l.kt)("inlineCode",{parentName:"li"},"nextLabel")," uses this to generate a new, unique label."),(0,l.kt)("li",{parentName:"ul"},"Consider code generation for an if-the-else statement:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Two fresh labels mark the start of the code for the else part (",(0,l.kt)("inlineCode",{parentName:"li"},"elseLab"),") and the end of the whole statement (",(0,l.kt)("inlineCode",{parentName:"li"},"endLab"),")."),(0,l.kt)("li",{parentName:"ul"},"The code that is generated consists of the following:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Code for the test."),(0,l.kt)("li",{parentName:"ul"},"A gofalse to the code for the else-part."),(0,l.kt)("li",{parentName:"ul"},"Code for the then-part and a jump to the end of the statement."),(0,l.kt)("li",{parentName:"ul"},"Code for the else-part that starts with the label ",(0,l.kt)("inlineCode",{parentName:"li"},"elsePart"),"."),(0,l.kt)("li",{parentName:"ul"},"The label ",(0,l.kt)("inlineCode",{parentName:"li"},"endLab")," that marks the end of the code for the if-then-else statement."))))),(0,l.kt)("li",{parentName:"ul"},"Compiling a list of statements conveniently uses a list comprehension and list splicing."),(0,l.kt)("li",{parentName:"ul"},"Compiling declarations allocates memory locations of the appropriate type for each declared variable."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"compileProgram")," compiles a gives Pico program to assembly language.")),(0,l.kt)("p",null,"Here is an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>import demo::lang::Pico::Compile;\nok\nrascal>compileProgram("begin declare x : natural; x := 47 end");\nlist[Instr]: [\n  dclStr("x"),\n  lvalue("x"),\n  pushNat(47),\n  assign()\n]\n')),(0,l.kt)("p",null,"Here is the compilation of the factorial program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},'rascal>compileProgram("begin declare input : natural,  \n>>>>>>>               \'              output : natural,           \n>>>>>>>               \'             repnr : natural,\n>>>>>>>               \'              rep : natural;\n>>>>>>>               \'      input := 14;\n>>>>>>>               \'      output := 1;\n>>>>>>>               \'      while input - 1 do        \n>>>>>>>               \'          rep := output;\n>>>>>>>               \'          repnr := input;\n>>>>>>>               \'          while repnr - 1 do\n>>>>>>>               \'             output := output + rep;\n>>>>>>>               \'             repnr := repnr - 1\n>>>>>>>               \'          od;\n>>>>>>>               \'          input := input - 1\n>>>>>>>               \'      od\n>>>>>>>               \'end");\nlist[Instr]: [\n  dclStr("input"),\n  dclStr("output"),\n  dclStr("repnr"),\n  dclStr("rep"),\n  lvalue("input"),\n  pushNat(14),\n  assign(),\n  lvalue("output"),\n  pushNat(1),\n  assign(),\n  label("L1"),\n  rvalue("input"),\n  pushNat(1),\n  sub2(),\n  gofalse("L2"),\n  lvalue("rep"),\n  rvalue("output"),\n  assign(),\n  lvalue("repnr"),\n  rvalue("input"),\n  assign(),\n  label("L3"),\n  rvalue("repnr"),\n  pushNat(1),\n  sub2(),\n  gofalse("L4"),\n  lvalue("output"),\n  rvalue("output"),\n  rvalue("rep"),\n  add2(),\n  assign(),\n  lvalue("repnr"),\n  rvalue("repnr"),\n  pushNat(1),\n  sub2(),\n  assign(),\n  go("L3"),\n  label("L4"),\n  lvalue("input"),\n  rvalue("input"),\n  pushNat(1),\n  sub2(),\n  assign(),\n  go("L1"),\n  label("L2")\n]\n')))}u.isMDXComponent=!0}}]);