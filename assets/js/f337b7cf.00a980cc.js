"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[70679],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),c=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),f=n,m=d["".concat(s,".").concat(f)]||d[f]||u[f]||l;return a?r.createElement(m,i(i({ref:t},p),{},{components:a})):r.createElement(m,i({ref:t},p))}));function f(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var c=2;c<l;c++)i[c]=a[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},52549:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var r=a(87462),n=(a(67294),a(3905));const l={title:"Algebraic Data Type"},i=void 0,o={unversionedId:"Rascalopedia/AlgebraicDataType/index",id:"Rascalopedia/AlgebraicDataType/index",title:"Algebraic Data Type",description:"Synopsis",source:"@site/docs/Rascalopedia/AlgebraicDataType/index.md",sourceDirName:"Rascalopedia/AlgebraicDataType",slug:"/Rascalopedia/AlgebraicDataType/",permalink:"/docs/Rascalopedia/AlgebraicDataType/",draft:!1,tags:[],version:"current",frontMatter:{title:"Algebraic Data Type"},sidebar:"tutorialSidebar",previous:{title:"Abstract Syntax Tree",permalink:"/docs/Rascalopedia/AbstractSyntaxTree/"},next:{title:"Compiler",permalink:"/docs/Rascalopedia/Compiler/"}},s={},c=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4},{value:"Benefits",id:"benefits",level:4},{value:"Pitfalls",id:"pitfalls",level:4}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h4",{id:"synopsis"},"Synopsis"),(0,n.kt)("p",null,'An Algebraic Data Type (ADT) is a composite type, defined by a number of "constructors" for each type, and each constructor has a number of (typed) fields.'),(0,n.kt)("h4",{id:"description"},"Description"),(0,n.kt)("p",null,"First things first: algebraic data types are not to be confused with ",(0,n.kt)("a",{parentName:"p",href:"/docs/Rascalopedia/AbstractDataType/"},"abstract data type"),'s, which are definitions of data-structures that clearly separate the external interface from the (hidden) implementation of the data structure. Both sare the abbreviation "ADT".'),(0,n.kt)("p",null,'In functional languages, and also in Rascal, algebraic datatypes\nare used to define new structured data types of arbitrary complexity. A algebraic data type consists of alternative "constructors" (tree nodes) that each have a number of "fields" of a given type. By combining algebraic data-types (using them as fields of others), you can construct arbitrarily complex hierarchical structures, such as:'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"the abstract syntax of logical formulas"),(0,n.kt)("li",{parentName:"ul"},"representations of complex run-time or static types"),(0,n.kt)("li",{parentName:"ul"},"abstract syntax trees of programming languages and domain specific languages")),(0,n.kt)("p",null,"See ",(0,n.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/AlgebraicDataType/"},"Algebraic Data Types")," and\n",(0,n.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Values/Constructor/"},"Constructors")," in the ",(0,n.kt)("a",{parentName:"p",href:"/docs/Rascal/"},"Rascal Language Reference"),"."),(0,n.kt)("h4",{id:"examples"},"Examples"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"An algebraic type for trees with integer leafs and labeled internal nodes:")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rascal"},"data MyTree \n   = leaf(int n) \n   | tree(str name, MyTree left, MyTree right);\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"An algebraic type for boolean formulas :")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rascal"},"data Formula \n   = and(Formula l, Formula r)\n   | or(Formula l, Formula r)\n   | not(Formula n)\n   | \\true()\n   | \\false()\n   ;\n")),(0,n.kt)("h4",{id:"benefits"},"Benefits"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"ADTs are a very general way of constructing hierarchical data-types. You can model almost anything with them."),(0,n.kt)("li",{parentName:"ul"},"ADTs instances are typically ",(0,n.kt)("inlineCode",{parentName:"li"},"immutable"),", so you can share them among different parts of a meta-program without interference")),(0,n.kt)("h4",{id:"pitfalls"},"Pitfalls"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"To model cycles and cross-edges, typically an ADT is not sufficient. It is possible to model such things on top of ADTs but it gets complex quickly with the use of closures. Better use ",(0,n.kt)("a",{parentName:"li",href:"/docs/Rascalopedia/Relation/"},"./Relation"),"s for those graph-like structures.")))}u.isMDXComponent=!0}}]);