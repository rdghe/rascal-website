"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[24038],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||s;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},95424:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const s={title:"Comprehensions"},i=void 0,o={unversionedId:"RascalConcepts/Comprehensions/index",id:"RascalConcepts/Comprehensions/index",title:"Comprehensions",description:"Synopsis",source:"@site/docs/RascalConcepts/Comprehensions/index.md",sourceDirName:"RascalConcepts/Comprehensions",slug:"/RascalConcepts/Comprehensions/",permalink:"/docs/RascalConcepts/Comprehensions/",draft:!1,tags:[],version:"current",frontMatter:{title:"Comprehensions"},sidebar:"tutorialSidebar",previous:{title:"Equation Solving",permalink:"/docs/RascalConcepts/EquationSolving/"},next:{title:"Static Typing",permalink:"/docs/RascalConcepts/StaticTyping/"}},l={},p=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4},{value:"Benefits",id:"benefits",level:4},{value:"Pitfalls",id:"pitfalls",level:4}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"synopsis"},"Synopsis"),(0,r.kt)("p",null,"Comprehensions for generating values."),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Comprehensions are a notation inspired by mathematical ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Set-builder_notation"},"set-builder notation"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/List_comprehension"},"list comprehensions"),"\nthat help to write succinct definitions of lists and sets. They also resemble ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT")," queries as found in a language like SQL quite a bit."),(0,r.kt)("p",null,"Rascal generalizes comprehensions in various ways. Comprehensions exist for lists, sets and maps, and even for general values.\nA comprehension consists of an expression that determines the successive elements to be included in the\nresult and a list of enumerators and tests (boolean expressions).\nThe enumerators produce values and the tests filter them. "),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Comprehensions/"},"Comprehensions"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Values/List/Comprehension/"},"List Comprehension"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Values/Set/Comprehension/"},"Set Comprehension"),", and\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Values/Map/Comprehension/"},"Map Comprehension")," for details. Have a look at ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Reducer/"},"Reducer")," to use a comprehesion to construct anything else but a list, set or map."),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"A standard example is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rascal>{ x * x | int x <- [1 .. 10], x % 3 == 0 }\nset[int]: {9,81,36}\n")),(0,r.kt)("p",null,"i.e., the squares of the integers in the range ",(0,r.kt)("inlineCode",{parentName:"p"},"[ 1 .. 10 ]")," that\nare divisible by 3. A more intriguing example (that we do not give in full detail) is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"{name | /asgStat(Id name, _) <- P}\n")),(0,r.kt)("p",null,"which traverses program ",(0,r.kt)("inlineCode",{parentName:"p"},"P")," (using the ",(0,r.kt)("em",{parentName:"p"},"descendant match")," operator ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),", see ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Patterns/Node/"},"Patterns"),")\nand constructs a set of all identifiers that occur on the left hand\nside of assignment statements in ",(0,r.kt)("inlineCode",{parentName:"p"},"P"),"."),(0,r.kt)("h4",{id:"benefits"},"Benefits"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using comprehensions and pattern matching you can ",(0,r.kt)("inlineCode",{parentName:"li"},"query")," any tree-like object and turn it into a graph or relation")),(0,r.kt)("h4",{id:"pitfalls"},"Pitfalls"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Comprehensions can be arbitrarily nested, but that does not improve the readability of your code. Better split complex queries up into separate lines or even separate functions.")))}u.isMDXComponent=!0}}]);