"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[719],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>d});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),d=r,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return a?n.createElement(h,s(s({ref:t},c),{},{components:a})):n.createElement(h,s({ref:t},c))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},22531:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const i={title:"Visit",keywords:["visit","case","default","top-down","top-down-break","bottom-up","bottom-up-break","innermost","outermost"]},s=void 0,o={unversionedId:"Rascal/Expressions/Visit/index",id:"Rascal/Expressions/Visit/index",title:"Visit",description:"Synopsis",source:"@site/docs/Rascal/Expressions/Visit/index.md",sourceDirName:"Rascal/Expressions/Visit",slug:"/Rascal/Expressions/Visit/",permalink:"/docs/Rascal/Expressions/Visit/",draft:!1,tags:[],version:"current",frontMatter:{title:"Visit",keywords:["visit","case","default","top-down","top-down-break","bottom-up","bottom-up-break","innermost","outermost"]},sidebar:"tutorialSidebar",previous:{title:"Void",permalink:"/docs/Rascal/Expressions/Values/Void/"},next:{title:"Pattern With Action",permalink:"/docs/Rascal/Expressions/Visit/PatternWithAction/"}},l={},p=[{value:"Synopsis",id:"synopsis",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4}],c={toc:p};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"synopsis"},"Synopsis"),(0,r.kt)("p",null,"Visit the elements in a tree or value."),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Strategy visit ( _Exp_ ) {\ncase _PatternWithAction\u2081_;\ncase _PatternWithAction\u2082_;\n...\ndefault: ...\n}\n")),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Visiting, recursively traversing, the nodes in a deeply nested data-structure is a very common task in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/WhyRascal/EASY/"},"EASY")," domain.\nIn many cases (but certainly not all) this data-structure is a syntax tree of some source code file\nand the nodes correspond to expressions or statements. "),(0,r.kt)("p",null,"The visit expression/statement allows to focus on the points of interest in the data-structure while automating the search over the other parts for the programmer."),(0,r.kt)("p",null,"Computing metrics or refactoring are examples of tasks that require a tree visit.\nThere are three frequently occurring scenarios:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Accumulator: traverse the tree and collect information (fold).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Transformer: traverse the tree and transform it into another tree (map).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Accumulating Transformer: traverse the tree, collect information and also transform the tree."))),(0,r.kt)("p",null,"The visit expression in Rascal can accommodate all these (and more) use cases."),(0,r.kt)("p",null,"Given a subject term (the current value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),") and a list of cases\n(consisting of a sequence of ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Visit/PatternWithAction/"},"Pattern with Action"),"s, it traverses the term.\nDepending on the precise actions it may perform replacement (mimicking a transformer),\nupdate local variables (mimicking an accumulator) or a combination of these two (accumulating transformer).\nIf ",(0,r.kt)("em",{parentName:"p"},"any")," of the actions contains an ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Statements/Insert/"},"Insert")," statement,\nthe value of the visit expression is a new value that is obtained by successive insertions in the subject\nterm by executing one or more cases. Otherwise, the original value of the subject term is returned."),(0,r.kt)("p",null,"The visit expression is optionally preceded by one of the following strategy indications that\ndetermine the traversal order of the subject:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"top-down"),": visit the subject from root to leaves.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"top-down-break"),": visit the subject from root to leaves, but stop at the current path when a case matches.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bottom-up"),": visit the subject from leaves to root (this is the default).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"bottom-up-break"),": visit the subject from leaves to root, but stop at the current path when a case matches.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"innermost"),": repeat a bottom-up traversal as long as a case matches.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"outermost"),": repeat a top-down traversal as long as a case matches."))),(0,r.kt)("p",null,"The execution of the cases has the following effect:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A PatternWithAction of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern => Exp")," replaces the current subtree of the subject by the value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),".\nNote that a copy of the subject is created at the start of the visit statement and all replacements are made in this copy.\nAs a consequence, modifications made during the visit cannot influence matches later on.\nThe modified copy of the subject is ultimately returned by the visit expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A PatternWithAction of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern : Statement")," executes ",(0,r.kt)("inlineCode",{parentName:"p"},"Statement")," and this should lead to one of the following:"),(0,r.kt)("p",{parentName:"li"},"** Execution of an Insert statement of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"insert Exp\u2082"),".\nThe value of ",(0,r.kt)("em",{parentName:"p"},"Exp"),"\u2082 replaces the subtree of the subject that is currently being visited.\nOnce again, this modification takes place in a copy of the original subject (see above).\nNote that:"),(0,r.kt)("p",{parentName:"li"},"   *** An insert statement may only occur in a PatternWithAction in a visit expression or a rule."),(0,r.kt)("p",{parentName:"li"},"   *** ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern => Exp")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"Pattern : insert Exp;"),"."),(0,r.kt)("p",{parentName:"li"},"** Execution of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Statements/Fail/"},"Fail")," statement: the next case is tried."),(0,r.kt)("p",{parentName:"li"},"** Execution of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Statements/Return/"},"Return")," statement that returns a value from the enclosing function."))),(0,r.kt)("p",null,"The precise behaviour of the visit expression depends on the type of the subject:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For type node or ADT, all nodes of the tree are visited (in the order determined by the strategy).\nConcrete patterns and abstract patterns directly match tree nodes.\nRegular expression patterns match only values of type string.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For other structured types (list, set, map, tuple, rel), the elements of the structured type are visited and\nmatched against the cases.\nWhen inserts are made, a new structured value is created. In these cases a strategy does not have any effect."))),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Visit a value and increment a counter for pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"leaf(int N)")," matches:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"visit(t) {\n     case leaf(int N): c = c + N;   \n   };\n")),(0,r.kt)("p",null,"Replace all values that match the pattern ",(0,r.kt)("inlineCode",{parentName:"p"},"red(l, r)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"visit(t) {\n     case red(l, r) => green(l, r)   \n   };\n")),(0,r.kt)("p",null,"Do a bottom-up visit of an expression and apply the function ",(0,r.kt)("inlineCode",{parentName:"p"},"simp")," to each subexpression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"bottom-up visit(e){\n           case Exp e1 => simp(e1)\n         }\n")),(0,r.kt)("p",null,"More examples can, for instance, be found in Recipes, see ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes/Common/ColoredTrees/"},"ColoredTrees"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes/Common/WordReplacement/"},"WordReplacement"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes/Common/CountConstructors/"},"CountConstructors"),",\nand ",(0,r.kt)("a",{parentName:"p",href:"/docs/Recipes/Common/Derivative/"},"Derivative"),"."))}m.isMDXComponent=!0}}]);