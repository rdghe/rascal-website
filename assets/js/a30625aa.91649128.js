"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[51197],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},23012:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const o={authors:["jvinju"],title:"From functions to term rewriting and back in Rascal"},i=void 0,l={permalink:"/blog/2013/05/15/from-functions-to-term-rewriting-and-back",editUrl:"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2013-05-15-from-functions-to-term-rewriting-and-back.md",source:"@site/blog/2013-05-15-from-functions-to-term-rewriting-and-back.md",title:"From functions to term rewriting and back in Rascal",description:"Here's a nifty design element from Rascal that I personally like: functions are actually rewrite rules. The bottom line here is that pattern matching drives dynamic dispatch which results in openly extensible meta programs.",date:"2013-05-15T00:00:00.000Z",formattedDate:"May 15, 2013",tags:[],readingTime:5.335,hasTruncateMarker:!1,authors:[{name:"Jurgen Vinju",title:"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team",url:"http://homepages.cwi.nl/~jurgenv",imageURL:"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg",key:"jvinju"}],frontMatter:{authors:["jvinju"],title:"From functions to term rewriting and back in Rascal"},prevItem:{title:"A DSL in 36 lines of code",permalink:"/blog/2013/07/29/dsl-in-36-lines-of-code"}},s={authorsImageUrls:[void 0]},u=[{value:"Complete functions",id:"complete-functions",level:2},{value:"Functions with normal forms",id:"functions-with-normal-forms",level:2},{value:"Modularity by open extensibility",id:"modularity-by-open-extensibility",level:2},{value:"Pattern matching galore",id:"pattern-matching-galore",level:2},{value:"From unlabeled to labeled rules",id:"from-unlabeled-to-labeled-rules",level:2},{value:"Higher order functions are higher-order rewrite rules",id:"higher-order-functions-are-higher-order-rewrite-rules",level:2},{value:"A note on types",id:"a-note-on-types",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Here's a nifty design element from Rascal that I personally like: functions are actually rewrite rules. The bottom line here is that pattern matching drives dynamic dispatch which results in openly extensible meta programs."),(0,r.kt)("p",null,"The design choice seems obvious for people who have been programming in ASF+SDF, Stratego and TXL who argue that rewrite rules and strategies were actually just functions."),(0,r.kt)("h2",{id:"complete-functions"},"Complete functions"),(0,r.kt)("p",null,"In Rascal we write functions in a Java/C/C# like syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int fac(int n) {\n  if (n == 0)\n    return 1;\n  else\n    return n * f(n - 1);\n }\n")),(0,r.kt)("p",null,"Or slightly shorter and more elegant we could write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int f(int n) = n == 0 ? 1 : n * f(n - 1);\n")),(0,r.kt)("p",null,"In fact, function definitions are just rewrite rules with a funny syntax, the ",(0,r.kt)("inlineCode",{parentName:"p"},"int n")," is actually a pattern that matches integers only and binds them to the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),". This means we can write more concrete patterns and separate the case distinction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int f(0) = 1;\ndefault int f(int n) = n * f(n - 1);\n")),(0,r.kt)("p",null,"The default keyword here indicates to try this alternative only after the other ones, which is obligatory here since Rascal's rules are statically mutually non-overlapping."),(0,r.kt)("h2",{id:"functions-with-normal-forms"},"Functions with normal forms"),(0,r.kt)("p",null,"So far we have written a function which is total, i.e. it has to provide a result for all elements of the parameter types. To make this more rewriting-like, where we have normal forms, consider the interaction with constructor functions in the following example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"data Bool\n  = t()\n  | f()\n  | and(Bool l, Bool r)\n  |   or(Bool l, Bool r)\n  ;\n  \nBool and(f(), Bool _) = f();\nBool and(t(), Bool b) = b;\n")),(0,r.kt)("p",null,"Here we see the ",(0,r.kt)("inlineCode",{parentName:"p"},"and")," function defined for two cases, where the first argument matches either ",(0,r.kt)("inlineCode",{parentName:"p"},"t()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"f()"),". It is not defined for any other cases, for example the first argument could be an ",(0,r.kt)("inlineCode",{parentName:"p"},"or(t(),t())"),", so in this sense it is partial. However, the data definition provides a ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," case for the and function, namely to construct the ",(0,r.kt)("inlineCode",{parentName:"p"},"and")," term."),(0,r.kt)("p",null,"For those of us who are used to rewrite rules, we see rules that are labeled by the sort of the terms that are being rewritten.\nHere are some example expressions executed in the console:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rascal>and(t(),t())\nBool: t();\nrascal>and(f(),t())\nBool: f();\nrascal>and(or(t(),t()),t())\nBool: and(or(t(),t()),t())\n")),(0,r.kt)("h2",{id:"modularity-by-open-extensibility"},"Modularity by open extensibility"),(0,r.kt)("p",null,'The key benefit of being able to use pattern matching for dynamic dispatch, is extensibility. Suppose we add "maybe" to our logical language in a separate module. This is possible since data signatures are extensible:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"data Bool = maybe();\n")),(0,r.kt)("p",null,"Now we need to reconsider the semantics of the ",(0,r.kt)("inlineCode",{parentName:"p"},"and")," function, and without changing the original definitions for ",(0,r.kt)("inlineCode",{parentName:"p"},"and")," we simply type these extensions to implement three-valued logic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Bool and(maybe(), maybe()) = maybe()\nBool and(maybe(), true()) = maybe()\nBool and(maybe(), false()) = false()\n")),(0,r.kt)("h2",{id:"pattern-matching-galore"},"Pattern matching galore"),(0,r.kt)("p",null,"In Rascal we have a powerful pattern matching operator suite, including:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"list matching (associative), for example: ",(0,r.kt)("inlineCode",{parentName:"li"},"[*_, elem, _*, elem, _*]")),(0,r.kt)("li",{parentName:"ul"},"set matching (commutative, associative, idempotent), for example: ",(0,r.kt)("inlineCode",{parentName:"li"},"f({e,*other, f({e,*nested})})")),(0,r.kt)("li",{parentName:"ul"},"deep matching (recursive), as in ",(0,r.kt)("inlineCode",{parentName:"li"},"/t()")," "),(0,r.kt)("li",{parentName:"ul"},"negative matching, as in ",(0,r.kt)("inlineCode",{parentName:"li"},"!and(_,_)")),(0,r.kt)("li",{parentName:"ul"},"non-linear matching (see above list matching example)"),(0,r.kt)("li",{parentName:"ul"},"etc.")),(0,r.kt)("p",null,"These operators may occur in the parameter positions of function definitions, just as they can in switch, visit, {list,set,map} comprehensions, loops, conditionals, etc. As such they give a very broad means to the programmer on how to dispatch between cases. This is only limited by the rule that patterns needs to be mutually exclusive for a certain function."),(0,r.kt)("p",null,"Here is a function to remove double elements from a list, term rewriting style:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"list[value] dup([*value a, value e, *value b, e, *value c]) = dup([*a, e, *b, *c])\ndefault list[value] dup(list[value] l) = l;\n")),(0,r.kt)("p",null,"And here is the same function but type parametrized:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"list[&T] dup([*&T a, &T e, *&T b, e, *&T c]) = dup([*a, e, *b, *c])\ndefault list[&T] dup(list[&T] l) = l\n")),(0,r.kt)("h2",{id:"from-unlabeled-to-labeled-rules"},"From unlabeled to labeled rules"),(0,r.kt)("p",null,"The big issue with rewrite rules is that they are applied automatically and this is sometimes cumbersome. Functions do not have this issue. Perhaps we should not have defined the boolean semantics so directly, and have wrapped it in a function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"data Bool\n  = t()\n  | f()\n  | and(Bool l, Bool r)\n  | or(Bool l, Bool r)\n  ;\n  \nBool eval(and(f(), Bool _)) = f();\nBool eval(and(t(), Bool b)) = b;\n")),(0,r.kt)("p",null,'This reads as labeled rules, we have two rules called "eval" that could be applied but will never be applied automatically unless somebody calls them as a function.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rascal>eval(and(f(),t()))\nBool: f()\n")),(0,r.kt)("p",null,"Or, if we wish to apply this rule bottom-up through an entire boolean expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"rascal>visit (and(and(f(),t()),t())) { case Bool b => eval(b); }\nBool: f();\n")),(0,r.kt)("p",null,"In the above we used visit to automate the recursion, but we could have manually implemented the recursion as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Bool eval(and(t(), Bool b)) = eval(b);\n")),(0,r.kt)("h2",{id:"higher-order-functions-are-higher-order-rewrite-rules"},"Higher order functions are higher-order rewrite rules"),(0,r.kt)("p",null,'Since our "rules" are actually just functions, we can pass them and combine them just like in any other language that supports higher-order functions. This brings us dangerously close to the expressive power of what term rewriting people call strategies. Anonymous functions (lambdas) can use pattern matching just as any other function by the way.\nSo we can write expressions such as ',(0,r.kt)("inlineCode",{parentName:"p"},"(f + g)(x)")," where we non-deterministically choose between applying ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"g")," using pattern matching."),(0,r.kt)("h2",{id:"a-note-on-types"},"A note on types"),(0,r.kt)("p",null,"Rascal is a statically typed language, supporting type inference only within the body of functions. We made this choice in order to help keep bodies of functions slim, but without introducing difficult to understand error messages that can be caused by a too smart type inference algorithm. "),(0,r.kt)("p",null,"This is the reason why all pattern variables in function definitions need to be typed while in normal patterns (nested in the bodies of functions) the types of pattern variables is inferred."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"These were some thoughts on the correspondence between functions and rewrite rules as we put it into Rascal.  We came from a term rewriting world and wanted to keep using their power of pattern matching and open extensibility. Now we are in a world of functional and imperative programming where we can control their application with the flick of a for loop."))}p.isMDXComponent=!0}}]);