"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[69995],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>y});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),s=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=s(a),y=n,m=d["".concat(l,".").concat(y)]||d[y]||u[y]||i;return a?r.createElement(m,o(o({ref:t},c),{},{components:a})):r.createElement(m,o({ref:t},c))}));function y(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=d;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p.mdxType="string"==typeof e?e:n,o[1]=p;for(var s=2;s<i;s++)o[s]=a[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},32384:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var r=a(83117),n=(a(67294),a(3905));const i={title:"Type Parameters",keywords:["&"]},o=void 0,p={unversionedId:"Rascal/Declarations/StaticTyping/TypeParameters/index",id:"Rascal/Declarations/StaticTyping/TypeParameters/index",title:"Type Parameters",description:"Synopsis",source:"@site/docs/Rascal/Declarations/StaticTyping/TypeParameters/index.md",sourceDirName:"Rascal/Declarations/StaticTyping/TypeParameters",slug:"/Rascal/Declarations/StaticTyping/TypeParameters/",permalink:"/docs/Rascal/Declarations/StaticTyping/TypeParameters/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Rascal/Declarations/StaticTyping/TypeParameters/index.md",tags:[],version:"current",frontMatter:{title:"Type Parameters",keywords:["&"]},sidebar:"tutorialSidebar",previous:{title:"Type Constraints",permalink:"/docs/Rascal/Declarations/StaticTyping/TypeConstraints/"},next:{title:"Syntax Definition",permalink:"/docs/Rascal/Declarations/SyntaxDefinition/"}},l={},s=[{value:"Synopsis",id:"synopsis",level:4},{value:"Syntax",id:"syntax",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4}],c={toc:s};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h4",{id:"synopsis"},"Synopsis"),(0,n.kt)("p",null,"Type parameters enable parameterized types."),(0,n.kt)("h4",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"& Name")),(0,n.kt)("h4",{id:"description"},"Description"),(0,n.kt)("p",null,"A type parameter may occur at every syntactic position where a type is required and turns an ordinary type into a parameterized type.\nParameterized types are used to define polymorphic functions and data types, i.e., functions and data types that are applicable for more than one type. Type parameters are bound to an actual type when the function or data type is applied and further uses of the type parameter are consistently replaced by the actual type."),(0,n.kt)("p",null,"The following syntactic positions are ",(0,n.kt)("em",{parentName:"p"},"binding occurrences")," for type parameters:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Type parameters in the type declaration of a function are bound to the types of the actual parameters in the call of that function. Type parameters that occur in the body of the function are replaced by the corresponding actual types.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The left-hand side of an alias. The type parameters are bound when the alias is used and occurrences of type parameters in the right hand side are replaced by corresponding actual types.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The alternatives of a data type. Binding and replacement is identical to that of function declarations."))),(0,n.kt)("p",null,"All other occurrences of type parameters are ",(0,n.kt)("em",{parentName:"p"},"using occurrences"),". The following rules apply:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"When the same type parameter is used at different binding occurrences it should be bound to the same actual type.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"For every using occurrence of a type parameter there should be a binding occurrence of a type parameter with the same name."))),(0,n.kt)("h4",{id:"examples"},"Examples"),(0,n.kt)("p",null,"Let\\'s consider a small example of the use of function parameters in a function declaration, see ",(0,n.kt)("a",{parentName:"p",href:"../../../../Rascal/Declarations/Function"},"Function"),"\nfor more details on function declarations.\nThe following function ",(0,n.kt)("inlineCode",{parentName:"p"},"swap")," returns a tuple in which its arguments are swapped and can be applied to arbitrary values\nin a type safe manner:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>tuple[&B, &A] swap(&A a, &B b) { return <b, a>; }\ntuple[&B,&A] (&A, &B): function(|prompt:///|(0,49,<1,0>,<1,49>))\nrascal>swap(1,2);\ntuple[int,int]: <2,1>\nrascal>swap("abc", 3);\ntuple[int,str]: <3,"abc">\n')),(0,n.kt)("p",null,"Observe that the type parameters that are used in the return type should be defined in the declarations of the formal parameter of the function."),(0,n.kt)("p",null,"An ",(0,n.kt)("a",{parentName:"p",href:"../../../../Rascal/Declarations/Alias"},"Alias")," declaration may also be parameterized. So we can generalize graphs as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rascal"},'alias Graph[&Node] = rel[&Node, &Node];\nGraph[int] GI = {<1,2>, <3,4>, <4,1>};\nGraph[str] GS = {<"a", "b">, <"c","d">, <"d", "a">};\n')),(0,n.kt)("p",null,"The type parameters that are used in the type in the right part of the alias declaration\nshould be defined in the left part of the alias definition."))}u.isMDXComponent=!0}}]);