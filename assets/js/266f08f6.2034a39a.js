"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[17117],{3905:(e,a,t)=>{t.d(a,{Zo:()=>m,kt:()=>g});var r=t(67294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var c=r.createContext({}),s=function(e){var a=r.useContext(c),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},m=function(e){var a=s(e.components);return r.createElement(c.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},d=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,l=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),d=s(t),g=n,p=d["".concat(c,".").concat(g)]||d[g]||u[g]||l;return t?r.createElement(p,o(o({ref:a},m),{},{components:t})):r.createElement(p,o({ref:a},m))}));function g(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var l=t.length,o=new Array(l);o[0]=d;var i={};for(var c in a)hasOwnProperty.call(a,c)&&(i[c]=a[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var s=2;s<l;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},81775:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var r=t(83117),n=(t(67294),t(3905));const l={title:"module lang::rascal::grammar::ConcreteSyntax"},o=void 0,i={unversionedId:"Library/lang/rascal/grammar/ConcreteSyntax",id:"Library/lang/rascal/grammar/ConcreteSyntax",title:"module lang::rascal::grammar::ConcreteSyntax",description:"Usage",source:"@site/docs/Library/lang/rascal/grammar/ConcreteSyntax.md",sourceDirName:"Library/lang/rascal/grammar",slug:"/Library/lang/rascal/grammar/ConcreteSyntax",permalink:"/docs/Library/lang/rascal/grammar/ConcreteSyntax",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Library/lang/rascal/grammar/ConcreteSyntax.md",tags:[],version:"current",frontMatter:{title:"module lang::rascal::grammar::ConcreteSyntax"},sidebar:"tutorialSidebar",previous:{title:"module lang::rascal::grammar::Bootstrap",permalink:"/docs/Library/lang/rascal/grammar/Bootstrap"},next:{title:"module lang::rascal::grammar::Lookahead",permalink:"/docs/Library/lang/rascal/grammar/Lookahead"}},c={},s=[{value:"Usage",id:"usage",level:4},{value:"function addHoles",id:"lang-rascal-grammar-ConcreteSyntax-addHoles",level:2},{value:"function holes",id:"lang-rascal-grammar-ConcreteSyntax-holes",level:2},{value:"function createHole",id:"lang-rascal-grammar-ConcreteSyntax-createHole",level:2},{value:"function denormalize",id:"lang-rascal-grammar-ConcreteSyntax-denormalize",level:2},{value:"function getTargetSymbol",id:"lang-rascal-grammar-ConcreteSyntax-getTargetSymbol",level:2},{value:"function quotable",id:"lang-rascal-grammar-ConcreteSyntax-quotable",level:2}],m={toc:s};function u(e){let{components:a,...t}=e;return(0,n.kt)("wrapper",(0,r.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h4",{id:"usage"},"Usage"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"import lang::rascal::grammar::ConcreteSyntax;")),(0,n.kt)("p",null,"  This module provides functionality for merging the Rascal grammar and arbitrary user-defined grammars"),(0,n.kt)("h2",{id:"lang-rascal-grammar-ConcreteSyntax-addHoles"},"function addHoles"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"Grammar addHoles(Grammar object)"))),(0,n.kt)("h2",{id:"lang-rascal-grammar-ConcreteSyntax-holes"},"function holes"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"set[Production] holes(Grammar object)"))),(0,n.kt)("p",null,"  For every non-terminal in the grammar we create a rule that can recognize its hole syntax. Each hole\nis specific for a non-terminal (using its name as a literal), such that no ambiguity can arise. When parsing\na fragment, the Rascal evaluator will generate a string that matches this generated syntax. It does so based on\nknowing the type of the variable, which is either declared internally in the '<...>' syntax, or derived by the\ntype checker."),(0,n.kt)("p",null,"  List types are treated differently. The are added as alternatives to the element type, such that an\narbitrary number of list variables can be elements of list patterns. To retrieve their original type, we store\nthe list symbol as one of the attributes of the generated production."),(0,n.kt)("p",null,"  Another exception is made for lexicals. Since currently the type checker is not inline yet, we can not see at parse time\nwhich nonterminal names are lexical and which are not. Since nonterminal names are unique between lex and normal nonterminals\nwe make sure that the literal that is generated is first normalized to remove all lex names.   "),(0,n.kt)("h2",{id:"lang-rascal-grammar-ConcreteSyntax-createHole"},"function createHole"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"str createHole(ConcretePart hole, int idx)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"str createHole(ConcreteHole hole, int idx)"))),(0,n.kt)("p",null,"  This function is called by the Rascal interpreter to generate a string that can be parsed by the rules generated by the\nholes function in this module."),(0,n.kt)("h2",{id:"lang-rascal-grammar-ConcreteSyntax-denormalize"},"function denormalize"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"Symbol denormalize(Symbol s)"))),(0,n.kt)("p",null,"  In Rascal programs with type literals, it's hard to see easily if it is a lex or sort, so we \"denormalize\" here.\nThe same goes for the introduction of layout non-terminals in lists. We do not know which non-terminal is introduced,\nso we remove this here to create a canonical 'source-level' type."),(0,n.kt)("h2",{id:"lang-rascal-grammar-ConcreteSyntax-getTargetSymbol"},"function getTargetSymbol"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"Symbol getTargetSymbol(Symbol sym)"))),(0,n.kt)("p",null,"This is needed such that list variables can be repeatedly used as elements of the same list"),(0,n.kt)("h2",{id:"lang-rascal-grammar-ConcreteSyntax-quotable"},"function quotable"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"bool quotable(Symbol x)"))),(0,n.kt)("p",null,"This decides for which part of the grammar we can write anti-quotes"))}u.isMDXComponent=!0}}]);