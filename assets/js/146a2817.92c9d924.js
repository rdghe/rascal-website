"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[40811],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(a),m=r,y=u["".concat(o,".").concat(m)]||u[m]||d[m]||i;return a?n.createElement(y,s(s({ref:t},c),{},{components:a})):n.createElement(y,s({ref:t},c))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},51880:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=a(87462),r=(a(67294),a(3905));const i={title:"module ParseTree"},s=void 0,l={unversionedId:"Library/ParseTree",id:"Library/ParseTree",title:"module ParseTree",description:"Usage",source:"@site/docs/Library/ParseTree.md",sourceDirName:"Library",slug:"/Library/ParseTree",permalink:"/docs/Library/ParseTree",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Library/ParseTree.md",tags:[],version:"current",frontMatter:{title:"module ParseTree"},sidebar:"tutorialSidebar",previous:{title:"module Node",permalink:"/docs/Library/Node"},next:{title:"module Prelude",permalink:"/docs/Library/Prelude"}},o={},p=[{value:"Usage",id:"usage",level:4},{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4},{value:"Pitfalls",id:"pitfalls",level:4},{value:"data Tree",id:"ParseTree-Tree",level:2},{value:"Synopsis",id:"synopsis-1",level:4},{value:"Description",id:"description-1",level:4},{value:"data Production",id:"ParseTree-Production",level:2},{value:"Synopsis",id:"synopsis-2",level:4},{value:"Description",id:"description-2",level:4},{value:"data Production",id:"ParseTree-Production",level:2},{value:"data Attr",id:"ParseTree-Attr",level:2},{value:"Synopsis",id:"synopsis-3",level:4},{value:"Description",id:"description-3",level:4},{value:"data Associativity",id:"ParseTree-Associativity",level:2},{value:"Synopsis",id:"synopsis-4",level:4},{value:"Description",id:"description-4",level:4},{value:"data CharRange",id:"ParseTree-CharRange",level:2},{value:"Synopsis",id:"synopsis-5",level:4},{value:"Description",id:"description-5",level:4},{value:"alias CharClass",id:"ParseTree-CharClass",level:2},{value:"data Symbol",id:"ParseTree-Symbol",level:2},{value:"Synopsis",id:"synopsis-6",level:4},{value:"Description",id:"description-6",level:4},{value:"data Symbol",id:"ParseTree-Symbol",level:2},{value:"data Symbol",id:"ParseTree-Symbol",level:2},{value:"data Symbol",id:"ParseTree-Symbol",level:2},{value:"data Symbol",id:"ParseTree-Symbol",level:2},{value:"function subtype",id:"ParseTree-subtype",level:2},{value:"data Condition",id:"ParseTree-Condition",level:2},{value:"Synopsis",id:"synopsis-7",level:4},{value:"Description",id:"description-7",level:4},{value:"function priority",id:"ParseTree-priority",level:2},{value:"Synopsis",id:"synopsis-8",level:4},{value:"function associativity",id:"ParseTree-associativity",level:2},{value:"Synopsis",id:"synopsis-9",level:4},{value:"Description",id:"description-8",level:4},{value:"function parse",id:"ParseTree-parse",level:2},{value:"Synopsis",id:"synopsis-10",level:4},{value:"Description",id:"description-9",level:4},{value:"Examples",id:"examples-1",level:4},{value:"function parser",id:"ParseTree-parser",level:2},{value:"Synopsis",id:"synopsis-11",level:4},{value:"Description",id:"description-10",level:4},{value:"function parsers",id:"ParseTree-parsers",level:2},{value:"Synopsis",id:"synopsis-12",level:4},{value:"Description",id:"description-11",level:4},{value:"function firstAmbiguity",id:"ParseTree-firstAmbiguity",level:2},{value:"Description",id:"description-12",level:4},{value:"function unparse",id:"ParseTree-unparse",level:2},{value:"Synopsis",id:"synopsis-13",level:4},{value:"Description",id:"description-13",level:4},{value:"Examples",id:"examples-2",level:4},{value:"function printSymbol",id:"ParseTree-printSymbol",level:2},{value:"function implode",id:"ParseTree-implode",level:2},{value:"Synopsis",id:"synopsis-14",level:4},{value:"Description",id:"description-14",level:4},{value:"Examples",id:"examples-3",level:4},{value:"data TreeSearchResult",id:"ParseTree-TreeSearchResult",level:2},{value:"Synopsis",id:"synopsis-15",level:4},{value:"function treeAt",id:"ParseTree-treeAt",level:2},{value:"Synopsis",id:"synopsis-16",level:4},{value:"Description",id:"description-15",level:4},{value:"function sameType",id:"ParseTree-sameType",level:2},{value:"function isNonTerminalType",id:"ParseTree-isNonTerminalType",level:2},{value:"Synopsis",id:"synopsis-17",level:4}],c={toc:p};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"usage"},"Usage"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"import ParseTree;")),(0,r.kt)("h4",{id:"synopsis"},"Synopsis"),(0,r.kt)("p",null,"Library functions for parse trees."),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"concrete syntax tree")," or ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Parse_tree"},"parse tree")," is an ordered, rooted tree that\nrepresents the syntactic structure of a string according to some formal grammar. "),(0,r.kt)("p",null,"Most Rascal users will encounter parse trees in the form of concrete values.\nExpert users may find the detailed description here useful when writing generic functions on parse trees. "),(0,r.kt)("p",null,"In Rascal parse trees, the interior nodes are labeled by rules of the grammar,\nwhile the leaf nodes are labeled by terminals (characters) of the grammar. "),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," is the universal parse tree data type in Rascal and can be used to represent parse trees for any language."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Tree")," is a subtype of the type ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Expressions/Values/Node/"},"node"),"."),(0,r.kt)("li",{parentName:"ul"},"All types (non-terminals) declared in ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"syntax definitions")," are sub-types of ",(0,r.kt)("inlineCode",{parentName:"li"},"Tree"),"."),(0,r.kt)("li",{parentName:"ul"},"All ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Expressions/ConcreteSyntax/"},"concrete syntax expressions")," produce parse trees with a type corresponding to a non-terminals."),(0,r.kt)("li",{parentName:"ul"},"Trees can be annotated in various ways, see features for ",(0,r.kt)("a",{parentName:"li",href:"/docs/RascalConcepts/IDEConstruction/"},"IDE construction"),".\nMost importantly the ",(0,r.kt)("inlineCode",{parentName:"li"},"\\loc")," annotation always points to the source location of any (sub) parse tree.")),(0,r.kt)("p",null,"Parse trees are usually analyzed and constructed using\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/ConcreteSyntax/"},"concrete syntax expressions"),"\nand ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Patterns/Concrete/"},"concrete syntax patterns"),"."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Advanced users")," may want to create tools that analyze any parse tree, regardless of the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"syntax definition")," that generated it, you can manipulate them on the abstract level."),(0,r.kt)("p",null,"A parse tree is of type ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-Tree"},"Tree")," using the auxiliary types\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-Production"},"Production"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-Symbol"},"Symbol"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-Condition"},"Condition"),",\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-Attr"},"Attr"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-Associativity"},"Associativity"),", ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-CharRange"},"CharRange"),".\nEffectively, a parse tree is a nested tree structure of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),". "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Most internal nodes are applications (",(0,r.kt)("inlineCode",{parentName:"p"},"appl"),") of a ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," to a list of children ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," nodes.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," is the abstract representation of a rule in a\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"syntax definition"),",\nwhich consists of a definition of an alternative for a ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," by a list of ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbols"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The leaves of a parse tree are always\ncharacters (",(0,r.kt)("inlineCode",{parentName:"p"},"char"),"), which have an integer index in the UTF8 table. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Some internal nodes encode ambiguity (",(0,r.kt)("inlineCode",{parentName:"p"},"amb"),") by pointing to a set of\nalternative ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," nodes."))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," types are an abstract notation for rules in\n",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Declarations/SyntaxDefinition/"},"syntax definitions"),",\nwhile the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," type is the actual notation for parse trees. "),(0,r.kt)("p",null,"Parse trees are called parse forests when they contain ",(0,r.kt)("inlineCode",{parentName:"p"},"amb")," nodes."),(0,r.kt)("p",null,"You can analyze and manipulate parse trees in three ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Directly on the ",(0,r.kt)("inlineCode",{parentName:"li"},"Tree")," level, just like any other ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/AlgebraicDataType/"},"algebraic data type"),"."),(0,r.kt)("li",{parentName:"ul"},"Using ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Expressions/ConcreteSyntax/"},"concrete syntax expressions"),"\nand ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Patterns/Concrete/"},"concrete syntax patterns"),"."),(0,r.kt)("li",{parentName:"ul"},"Using ",(0,r.kt)("a",{parentName:"li",href:"/docs/Rascal/Declarations/SyntaxDefinition/Action/"},"actions"),".")),(0,r.kt)("p",null,"The type of a parse tree is the symbol that it's production produces, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},'appl(prod(sort("A"),[],{}),[])')," has type ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),". Ambiguity nodes\nEach such a non-terminal type has ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," as its immediate super-type."),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("p",null,"// the following definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>import ParseTree;\nok\nrascal>syntax A = "a";\nok\n')),(0,r.kt)("p",null,"will make the following succeed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>parse(#A,"a") == \n>>>>>>>appl(\n>>>>>>>  prod(\n>>>>>>>    sort("A"),\n>>>>>>>    [lit("a")],\n>>>>>>>    {}),\n>>>>>>>  [appl(\n>>>>>>>      prod(\n>>>>>>>        lit("a"),\n>>>>>>>        [\\char-class([range(97,97)])],\n>>>>>>>        {}),\n>>>>>>>      [char(97)])]);\nbool: false\n')),(0,r.kt)("p",null,"You see that the defined non-terminal A ends up as the production for the outermost node.\nAs the only child is the tree for recognizing the literal a, which is defined to be a single a from the character-class ",(0,r.kt)("inlineCode",{parentName:"p"},"[ a ]"),"."),(0,r.kt)("p",null,"When we use labels in the definitions, they also end up in the trees.\nThe following definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>import ParseTree;\nok\nrascal>lexical B= myB:"b";\nok\nrascal>lexical C = myC:"c" B bLabel;\nok\n')),(0,r.kt)("p",null,"Will make the following succeed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>parse(#C,"cb") == \n>>>>>>>appl(\n>>>>>>>  prod(\n>>>>>>>    label(\n>>>>>>>      "myC",\n>>>>>>>      lex("C")),\n>>>>>>>    [\n>>>>>>>      lit("c"),\n>>>>>>>      label(\n>>>>>>>        "bLabel",\n>>>>>>>        lex("B"))\n>>>>>>>    ],\n>>>>>>>    {}),\n>>>>>>>  [appl(\n>>>>>>>      prod(\n>>>>>>>        lit("c"),\n>>>>>>>        [\\char-class([range(99,99)])],\n>>>>>>>        {}),\n>>>>>>>      [char(99)]),appl(\n>>>>>>>      prod(\n>>>>>>>        label(\n>>>>>>>          "myB",\n>>>>>>>          lex("B")),\n>>>>>>>        [lit("b")],\n>>>>>>>        {}),\n>>>>>>>      [appl(\n>>>>>>>          prod(\n>>>>>>>            lit("b"),\n>>>>>>>            [\\char-class([range(98,98)])],\n>>>>>>>            {}),\n>>>>>>>          [char(98)])])]);\nbool: false\n')),(0,r.kt)("p",null,"Here you see that the alternative name is a label around the first argument of ",(0,r.kt)("inlineCode",{parentName:"p"},"prod")," while argument labels become\nlabels in the list of children of a ",(0,r.kt)("inlineCode",{parentName:"p"},"prod"),"."),(0,r.kt)("h4",{id:"pitfalls"},"Pitfalls"),(0,r.kt)("p",null,'For historical reasons the name of the annotation is "loc" and this interferes with the Rascal keyword ',(0,r.kt)("inlineCode",{parentName:"p"},"loc"),"\nfor the type of ",(0,r.kt)("a",{parentName:"p",href:"/docs/Rascal/Expressions/Values/Location/"},"source locations"),".\nTherefore the annotation name has to be escaped as ",(0,r.kt)("inlineCode",{parentName:"p"},"\\loc")," when it is declared or used."),(0,r.kt)("p",null,"The following functions and data types are declared for ParseTrees:"),(0,r.kt)("h2",{id:"ParseTree-Tree"},"data Tree"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Tree  \n     = appl(Production prod, list[Tree] args)\n     | cycle(Symbol symbol, int cycleLength)\n     | amb(set[Tree] alternatives)\n     | char(int character)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-1"},"Synopsis"),(0,r.kt)("p",null,"The Tree data type as produced by the parser."),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," defines the trees normally found after parsing; additional constructors exist for execptional cases:"),(0,r.kt)("p",null,"<1> Parse tree constructor when parse succeeded.\n<2> Cyclic parsetree.\n<3> Ambiguous subtree.\n<4> A single character. "),(0,r.kt)("h2",{id:"ParseTree-Production"},"data Production"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Production  \n     = prod(Symbol def, list[Symbol] symbols, set[Attr] attributes)\n     | regular(Symbol def)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-2"},"Synopsis"),(0,r.kt)("p",null,"Production in ParseTrees "),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"Production")," is introduced in ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/Type"},"Type"),", see ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/Type#Type-Production"},"Production"),". Here we extend it with the symbols\nthat can occur in a ParseTree. We also extend productions with basic combinators allowing to\nconstruct ordered and un-ordered compositions, and associativity groups."),(0,r.kt)("p",null,"<1> A ",(0,r.kt)("inlineCode",{parentName:"p"},"prod")," is a rule of a grammar, with a defined non-terminal, a list\nof terminal and/or non-terminal symbols and a possibly empty set of attributes."),(0,r.kt)("p",null,"<2> A ",(0,r.kt)("inlineCode",{parentName:"p"},"regular")," is a regular expression, i.e. a repeated construct."),(0,r.kt)("p",null,"<3> ",(0,r.kt)("inlineCode",{parentName:"p"},"priority")," means operator precedence, where the order of the list indicates the binding strength of each rule;\n<4> ",(0,r.kt)("inlineCode",{parentName:"p"},"assoc"),"  means all alternatives are acceptable, but nested on the declared side;\n<5> ",(0,r.kt)("inlineCode",{parentName:"p"},"reference")," means a reference to another production rule which should be substituted there,\nfor extending priority chains and such."),(0,r.kt)("h2",{id:"ParseTree-Production"},"data Production"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Production  \n     = \\priority(Symbol def, list[Production] choices)\n     | \\associativity(Symbol def, Associativity \\assoc, set[Production] alternatives)\n     | \\reference(Symbol def, str cons)\n     ;\n")),(0,r.kt)("h2",{id:"ParseTree-Attr"},"data Attr"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Attr  \n     = \\bracket()\n     | \\assoc(Associativity \\assoc)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-3"},"Synopsis"),(0,r.kt)("p",null,"Attributes in productions."),(0,r.kt)("h4",{id:"description-3"},"Description"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"Attr")," (attribute) documents additional semantics of a production rule. Neither tags nor\nbrackets are processed by the parser generator. Rather downstream processors are\nactivated by these. Associativity is a parser generator feature though. "),(0,r.kt)("h2",{id:"ParseTree-Associativity"},"data Associativity"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Associativity  \n     = \\left()\n     | \\right()\n     | \\assoc()\n     | \\non-assoc()\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-4"},"Synopsis"),(0,r.kt)("p",null,"Associativity attribute. "),(0,r.kt)("h4",{id:"description-4"},"Description"),(0,r.kt)("p",null,"Associativity defines the various kinds of associativity of a specific production."),(0,r.kt)("h2",{id:"ParseTree-CharRange"},"data CharRange"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data CharRange  \n     = range(int begin, int end)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-5"},"Synopsis"),(0,r.kt)("p",null,"Character ranges and character class"),(0,r.kt)("h4",{id:"description-5"},"Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CharRange")," defines a range of characters."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},"CharClass")," consists of a list of characters ranges.")),(0,r.kt)("h2",{id:"ParseTree-CharClass"},"alias CharClass"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"list[CharRange]"))),(0,r.kt)("h2",{id:"ParseTree-Symbol"},"data Symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Symbol  \n     = \\start(Symbol symbol)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-6"},"Synopsis"),(0,r.kt)("p",null,"Symbols that can occur in a ParseTree"),(0,r.kt)("h4",{id:"description-6"},"Description"),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"Symbol")," is introduced in ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/Type"},"Type"),", see ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/Type#Type-Symbol"},"Symbol"),", to represent the basic Rascal types,\ne.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"rel"),". Here we extend it with the symbols that may occur in a ParseTree."),(0,r.kt)("p",null,"<1>  The ",(0,r.kt)("inlineCode",{parentName:"p"},"start")," symbol wraps any symbol to indicate that it is a start symbol of the grammar and\nmay occur at the root of a parse tree.\n<2>  Context-free non-terminal\n<3>  Lexical non-terminal\n<4>  Layout symbols\n<5>  Terminal symbols that are keywords\n<6>  Parameterized context-free non-terminal\n<7> Parameterized lexical non-terminal\n<8>  Terminal.\n<9>  Case-insensitive terminal.\n<10> Character class\n<11> Empty symbol\n<12> Optional symbol\n<13> List of one or more symbols without separators\n<14> List of zero or more symbols without separators\n<15> List of one or more symbols with separators\n<16> List of zero or more symbols with separators\n<17> Alternative of symbols\n<18> Sequence of symbols\n<19> Conditional occurrence of a symbol."),(0,r.kt)("h2",{id:"ParseTree-Symbol"},"data Symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Symbol  \n     = \\sort(str name)\n     | \\lex(str name)\n     | \\layouts(str name)\n     | \\keywords(str name)\n     | \\parameterized-sort(str name, list[Symbol] parameters)\n     | \\parameterized-lex(str name, list[Symbol] parameters)\n     ;\n")),(0,r.kt)("h2",{id:"ParseTree-Symbol"},"data Symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Symbol  \n     = \\lit(str string)\n     | \\cilit(str string)\n     | \\char-class(list[CharRange] ranges)\n     ;\n")),(0,r.kt)("h2",{id:"ParseTree-Symbol"},"data Symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Symbol  \n     = \\empty()\n     | \\opt(Symbol symbol)\n     | \\iter(Symbol symbol)\n     | \\iter-star(Symbol symbol)\n     | \\iter-seps(Symbol symbol, list[Symbol] separators)\n     | \\iter-star-seps(Symbol symbol, list[Symbol] separators)\n     | \\alt(set[Symbol] alternatives)\n     | \\seq(list[Symbol] symbols)\n     ;\n")),(0,r.kt)("h2",{id:"ParseTree-Symbol"},"data Symbol"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Symbol  \n     = \\conditional(Symbol symbol, set[Condition] conditions)\n     ;\n")),(0,r.kt)("h2",{id:"ParseTree-subtype"},"function subtype"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'bool subtype(Symbol::\\sort(_), Symbol::\\adt("Tree", _))'))),(0,r.kt)("h2",{id:"ParseTree-Condition"},"data Condition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Condition  \n     = \\follow(Symbol symbol)\n     | \\not-follow(Symbol symbol)\n     | \\precede(Symbol symbol)\n     | \\not-precede(Symbol symbol)\n     | \\delete(Symbol symbol)\n     | \\at-column(int column)\n     | \\begin-of-line()\n     | \\end-of-line()\n     | \\except(str label)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-7"},"Synopsis"),(0,r.kt)("p",null,"Datatype for declaring preconditions and postconditions on symbols"),(0,r.kt)("h4",{id:"description-7"},"Description"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Condition")," can be attached to a symbol; it restricts the applicability\nof that symbol while parsing input text. For instance, ",(0,r.kt)("inlineCode",{parentName:"p"},"follow")," requires that it\nis followed by another symbol and ",(0,r.kt)("inlineCode",{parentName:"p"},"at-column")," requires that it occurs\nat a certain position in the current line of the input text."),(0,r.kt)("h2",{id:"ParseTree-priority"},"function priority"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Production priority(Symbol s, [*Production a, priority(Symbol _, list[Production] b), *Production c])"))),(0,r.kt)("h4",{id:"synopsis-8"},"Synopsis"),(0,r.kt)("p",null,"Nested priority is flattened."),(0,r.kt)("h2",{id:"ParseTree-associativity"},"function associativity"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Production associativity(Symbol s, Associativity as, {*Production a, choice(Symbol t, set[Production] b)})")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Production associativity(Symbol rhs, Associativity a, {associativity(rhs, Associativity b, set[Production] alts), *Production rest})")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Production associativity(Symbol s, Associativity as, {*Production a, priority(Symbol t, list[Production] b)})")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Production associativity(Symbol rhs, Associativity a, set[Production] rest)"))),(0,r.kt)("h4",{id:"synopsis-9"},"Synopsis"),(0,r.kt)("p",null,"Normalization of associativity."),(0,r.kt)("h4",{id:"description-8"},"Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("a",{parentName:"li",href:"/docs/Library/Type#Type-choice"},"choice")," constructor under associativity is flattened."),(0,r.kt)("li",{parentName:"ul"},"Nested (equal) associativity is flattened."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/Library/ParseTree#ParseTree-priority"},"priority")," under an associativity group defaults to choice.")),(0,r.kt)("h2",{id:"ParseTree-parse"},"function parse"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&T<:Tree parse(type[&T<:Tree] begin, str input, bool allowAmbiguity=false, bool hasSideEffects=false, set[Tree(Tree)] filters={})")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&T<:Tree parse(type[&T<:Tree] begin, str input, loc origin, bool allowAmbiguity=false, bool hasSideEffects=false, set[Tree(Tree)] filters={})")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&T<:Tree parse(type[&T<:Tree] begin, loc input, bool allowAmbiguity=false, bool hasSideEffects=false, set[Tree(Tree)] filters={})"))),(0,r.kt)("h4",{id:"synopsis-10"},"Synopsis"),(0,r.kt)("p",null,"Parse input text (from a string or a location) and return a parse tree."),(0,r.kt)("h4",{id:"description-9"},"Description"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Parse a string and return a parse tree."),(0,r.kt)("li",{parentName:"ul"},"Parse a string and return a parse tree, ",(0,r.kt)("inlineCode",{parentName:"li"},"origin")," defines the original location of the input."),(0,r.kt)("li",{parentName:"ul"},"Parse the contents of resource input and return a parse tree.")),(0,r.kt)("p",null,"The parse either throws ParseError exceptions or returns parse trees of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),". See [","[ParseTree]","]."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"allowAmbiguity")," flag dictates the behavior of the parser in the case of ambiguity. When ",(0,r.kt)("inlineCode",{parentName:"p"},"allowAmbiguity=true"),"\nthe parser will construct ambiguity clusters (local sets of parse trees where the input string is ambiguous). If it is ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\nthe parser will throw an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ambiguous")," exception instead. An ",(0,r.kt)("inlineCode",{parentName:"p"},"Ambiguous")," exception is comparable to a ParseError exception then.\nThe latter option terminates much faster, i.e. always in cubic time, and always linear in the size of the intermediate parse graph,\nwhile constructing ambiguous parse forests may grow to O(n^p+1), where p is the length of the longest production rule and n\nis the length of the input."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"filters"),' set contains functions which may be called optionally after the parse algorithm has finished and just before\nthe Tree representation is built. The set of functions contain alternative functions, only on of them is successfully applied\nto each node in a tree. If such a function fails to apply, the other ones are tried. There is no fixed-point computation, so\ncomposed filters must be added to the set of filters programmatically. Post-parse filtering is best done at this stage and\nnot later on the Tree representation for efficiency reasons. Namely, the size of the parse graph before Tree construction\nis still cubic due to "binarized" sharing of intermediate nodes, while after Tree construction the forest may obtain\na size in O(n^p+1) where n is the length of the input and p is the length of the longest syntax rule. Filtering using\nthe ',(0,r.kt)("inlineCode",{parentName:"p"},"filters")," parameter, on the other hand, may very well cut the forest quickly down to even a linear size and result in\nan efficient overall parsing algorithm."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"hasSideEffects")," flag is normally set to false. When the ",(0,r.kt)("inlineCode",{parentName:"p"},"filters")," functions have side-effects to\nremove ambiguity, this option must be set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," to ensure correct behavior. A side-effect of filter functions is\ntypically the construction of a symbol table and the removal (see [","[Statements/Filter]","]) of syntax trees which refer to\nundefined symbols. In such a case ",(0,r.kt)("inlineCode",{parentName:"p"},"hasSideEffects")," must be set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," for correctness' sake. If its set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"\nthen the algorithm assumes tree construction is context-free and it can memoize the results of shared intermediate graph nodes.\nThe tree construction algorithm is effectively always worst case\npolynomial in O(n^p+1) --p being the length of the longest syntax rule-- when ",(0,r.kt)("inlineCode",{parentName:"p"},"hasSideEffects")," is true, but may be linear when set\nto false. So this is quite an important flag to consider. "),(0,r.kt)("h4",{id:"examples-1"},"Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",error",",error":!0},"rascal>import demo::lang::Exp::Concrete::NoLayout::Syntax;\nok\nrascal>import ParseTree;\nok\n")),(0,r.kt)("p",null,"Seeing that ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," returns a parse tree:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue,error",",continue,error":!0},'rascal>parse(#Exp, "2+3");\nExp: (Exp) `2+3`\n')),(0,r.kt)("p",null,"Catching a parse error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue,error",",continue,error":!0},'rascal>import IO;\nok\nrascal>try {\n>>>>>>>  Exp e = parse(#Exp, "2@3");\n>>>>>>>}\n>>>>>>>catch ParseError(loc l): {\n>>>>>>>  println("I found a parse error at line <l.begin.line>, column <l.begin.column>");\n>>>>>>>}\nI found a parse error at line 1, column 1\nok\n')),(0,r.kt)("h2",{id:"ParseTree-parser"},"function parser"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&T (value input, loc origin) parser(type[&T] grammar, bool allowAmbiguity=false, bool hasSideEffects=false, bool firstAmbiguity=false, set[Tree(Tree)] filters={})"))),(0,r.kt)("h4",{id:"synopsis-11"},"Synopsis"),(0,r.kt)("p",null,"Generates a parser from an input grammar."),(0,r.kt)("h4",{id:"description-10"},"Description"),(0,r.kt)("p",null,"This builtin function wraps the Rascal parser generator by transforming a grammar into a parsing function."),(0,r.kt)("p",null,"The resulting parsing function has the following overloaded signature:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Tree parse(str input, loc origin);"),(0,r.kt)("li",{parentName:"ul"},"Tree parse(loc input, loc origin);")),(0,r.kt)("p",null,"So the parse function reads either directly from a str or via the contents of a loc. It also takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"origin")," parameter\nwhich leads to the prefix of the ",(0,r.kt)("inlineCode",{parentName:"p"},"src")," fields of the resulting tree."),(0,r.kt)("p",null,"The parse function behaves differently depending of the given keyword parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," *  `allowAmbiguity`: if true then no exception is thrown in case of ambiguity and a parse forest is returned. if false,\n *                    the parser throws an exception during tree building and produces only the first ambiguous subtree in its message.\n *                    if set to `false`, the parse constructs trees in linear time. if set to `true` the parser constructs trees in polynomial time.\n * \n *  `hasSideEffects`: if false then the parser is a lot faster when constructing trees, since it does not execute the parse _actions_ in an\n *                    interpreted environment to make side effects (like a symbol table) and it can share more intermediate results as a result.\n *  \n *  `firstAmbiguity`: if true, then the parser returns the subforest for the first (left-most innermost) ambiguity instead of a parse tree for\n *                    the entire input string. This is for grammar debugging purposes a much faster solution then waiting for an entire \n *                    parse forest to be constructed in polynomial time.\n")),(0,r.kt)("h2",{id:"ParseTree-parsers"},"function parsers"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&U (type[&U] nonterminal, value input, loc origin) parsers(type[&T] grammar, bool allowAmbiguity=false, bool hasSideEffects=false, bool firstAmbiguity=false,  set[Tree(Tree)] filters={})"))),(0,r.kt)("h4",{id:"synopsis-12"},"Synopsis"),(0,r.kt)("p",null,"Generates parsers from a grammar (reified type), where all non-terminals in the grammar can be used as start-symbol."),(0,r.kt)("h4",{id:"description-11"},"Description"),(0,r.kt)("p",null,"This parser generator behaves the same as the ",(0,r.kt)("inlineCode",{parentName:"p"},"parser")," function, but it produces parser functions which have an additional\nnonterminal parameter. This can be used to select a specific non-terminal from the grammar to use as start-symbol for parsing."),(0,r.kt)("h2",{id:"ParseTree-firstAmbiguity"},"function firstAmbiguity"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Tree firstAmbiguity(type[&T<:Tree] begin, str input)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Tree firstAmbiguity(type[&T<:Tree] begin, loc input)"))),(0,r.kt)("p",null,".Synopsis parse the input but instead of returning the entire tree, return the trees for the first ambiguous substring."),(0,r.kt)("h4",{id:"description-12"},"Description"),(0,r.kt)("p",null,"This function is similar to the [","[parse]","] function in its functionality. However, in case of serious ambiguity parse\ncould be very slow. This function is much faster, because it does not try to construct an entire forest and thus avoids\nthe cost of constructing nested ambiguity clusters. "),(0,r.kt)("p",null,"If the input sentence is not ambiguous after all, simply the entire tree is returned."),(0,r.kt)("h2",{id:"ParseTree-unparse"},"function unparse"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str unparse(Tree tree)"))),(0,r.kt)("h4",{id:"synopsis-13"},"Synopsis"),(0,r.kt)("p",null,"Yield the string of characters that form the leafs of the given parse tree."),(0,r.kt)("h4",{id:"description-13"},"Description"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"unparse")," is the inverse function of ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-parse"},"parse"),", i.e., for every syntactically correct string ",(0,r.kt)("em",{parentName:"p"},"TXT")," of\ntype ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),", the following holds:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"unparse(parse(#S, _TXT_)) == _TXT_\n")),(0,r.kt)("h4",{id:"examples-2"},"Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},"rascal>import demo::lang::Exp::Concrete::NoLayout::Syntax;\nok\nrascal>import ParseTree;\nok\n")),(0,r.kt)("p",null,"First parse an expression, this results in a parse tree. Then unparse this parse tree:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},'rascal>unparse(parse(#Exp, "2+3"));\nstr: "2+3"\n')),(0,r.kt)("h2",{id:"ParseTree-printSymbol"},"function printSymbol"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"str printSymbol(Symbol sym, bool withLayout)"))),(0,r.kt)("h2",{id:"ParseTree-implode"},"function implode"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&T<:value implode(type[&T<:value] t, Tree tree)"))),(0,r.kt)("h4",{id:"synopsis-14"},"Synopsis"),(0,r.kt)("p",null,"Implode a parse tree according to a given (ADT) type."),(0,r.kt)("h4",{id:"description-14"},"Description"),(0,r.kt)("p",null,"Given a grammar for a language, its sentences can be parsed and the result is a parse tree\n(or more precisely a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),"). For many applications this is sufficient\nand the results are achieved by traversing and matching them using concrete patterns."),(0,r.kt)("p",null,"In other cases, the further processing of parse trees is better done in a more abstract form.\nThe ",(0,r.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Abstract_syntax"},"abstract syntax")," for a language is a\ndata type that is used to represent programs in the language in an ",(0,r.kt)("em",{parentName:"p"},"abstract")," form.\nAbstract syntax has the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'It is "abstract" in the sense that it does not contain textual details such as parentheses,\nlayout, and the like.'),(0,r.kt)("li",{parentName:"ul"},"While a language has one grammar (also known as, ",(0,r.kt)("em",{parentName:"li"},"concrete syntax"),") it may have several abstract syntaxes\nfor different purposes: type analysis, code generation, etc.")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"implode")," bridges the gap between parse tree and abstract syntax tree.\nGiven a parse tree and a Rascal type it traverses them simultaneously and constructs\nan abstract syntax tree (a value of the given type) as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Literals, layout and empty (i.e. ()) nodes are skipped.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Regular */+ lists are imploded to ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),"s or ",(0,r.kt)("inlineCode",{parentName:"p"},"set"),"s depending on what is\nexpected in the ADT.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Ambiguities are imploded to ",(0,r.kt)("inlineCode",{parentName:"p"},"set"),"s.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the expected type is ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," the tree is unparsed into a string. This happens for both\nlexical and context-free parse trees.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a tree's production has no label and a single AST (i.e. non-layout, non-literal) argument\n(for instance, an injection), the tree node is skipped, and implosion continues\nwith the lone argument. The same applies to bracket productions, even if they\nare labeled.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a tree's production has no label, but more than one argument, the tree is imploded\nto a tuple (provided this conforms to the ADT).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Optionals are imploded to booleans if this is expected in the ADT.\nThis also works for optional literals, as shown in the example below.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An optional is imploded to a list with zero or one argument, iff a list\ntype is expected.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the argument of an optional tree has a production with no label, containing\na single list, then this list is spliced into the optional list.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For trees with (cons-)labeled productions, the corresponding constructor\nin the ADT corresponding to the non-terminal of the production is found in\norder to make the AST.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the provided type is ",(0,r.kt)("inlineCode",{parentName:"p"},"node"),", (cons-)labeled trees will be imploded to untyped ",(0,r.kt)("inlineCode",{parentName:"p"},"node"),"s.\nThis means that any subtrees below it will be untyped nodes (if there is a label), tuples of\nnodes (if a label is absent), and strings for lexicals. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'Unlabeled lexicals are imploded to str, int, real, bool depending on the expected type in\nthe ADT. To implode lexical into types other than str, the PDB parse functions for\nintegers and doubles are used. Boolean lexicals should match "true" or "false".\nNB: lexicals are imploded this way, even if they are ambiguous.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a lexical tree has a cons label, the tree imploded to a constructor with that name\nand a single string-valued argument containing the tree's yield."))),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"IllegalArgument")," exception is thrown if during implosion a tree is encountered that cannot be\nimploded to the expected type in the ADT. As explained above, this function assumes that the\nADT type names correspond to syntax non-terminal names, and constructor names correspond\nto production labels. Labels of production arguments do not have to match with labels\nin ADT constructors."),(0,r.kt)("p",null,"Finally, source location fields are propagated as keyword fields on constructor ASTs.\nTo access them, the user is required to explicitly declare a keyword field on all\nADTs used in implosion. In other words, for every ADT type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", add:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data T(loc location=|unknown);\n")),(0,r.kt)("h4",{id:"examples-3"},"Examples"),(0,r.kt)("p",null,"Here are some examples for the above rules."),(0,r.kt)("p",null,".Example for rule 5"),(0,r.kt)("p",null,"Given the grammar"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax IDTYPE = Id ":" Type;\nsyntax Decls = decls: "declare" {IDTYPE ","}* ";";\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Decls")," will be imploded as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Decls = decls(list[tuple[str,Type]]);\n")),(0,r.kt)("p",null,"(assuming Id is a lexical non-terminal).   "),(0,r.kt)("p",null,".Example for rule 6"),(0,r.kt)("p",null,"Given the grammar"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Formal = formal: "VAR"? {Id ","}+ ":" Type;\n')),(0,r.kt)("p",null,"The corresponding ADT could be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Formal = formal(bool, list[str], Type);\n")),(0,r.kt)("p",null,".Example for rule 8"),(0,r.kt)("p",null,"Given the grammar"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Tag = "[" {Modifier ","}* "]";\nsyntax Decl = decl: Tag? Signature Body;\n')),(0,r.kt)("p",null,"In this case, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Decl")," is imploded into the following ADT:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Decl = decl(list[Modifier], Signature, Body);  \n")),(0,r.kt)("p",null,".Example for rule 9"),(0,r.kt)("p",null,"Given the grammar"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'syntax Exp = left add: Exp "+" Exp;\n')),(0,r.kt)("p",null,"Can be imploded into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Exp = add(Exp, Exp);\n")),(0,r.kt)("h2",{id:"ParseTree-TreeSearchResult"},"data TreeSearchResult"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data TreeSearchResult[&T<:Tree]  \n     = treeFound(&T tree)\n     | treeNotFound()\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-15"},"Synopsis"),(0,r.kt)("p",null,"Tree search result type for ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-treeAt"},"tree at"),"."),(0,r.kt)("h2",{id:"ParseTree-treeAt"},"function treeAt"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TreeSearchResult[&T<:Tree] treeAt(type[&T<:Tree] t, loc l, Tree a:appl(_, _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default TreeSearchResult[&T<:Tree] treeAt(type[&T<:Tree] t, loc l, Tree root)"))),(0,r.kt)("h4",{id:"synopsis-16"},"Synopsis"),(0,r.kt)("p",null,"Select the innermost Tree of a given type which is enclosed by a given location."),(0,r.kt)("h4",{id:"description-15"},"Description"),(0,r.kt)("h2",{id:"ParseTree-sameType"},"function sameType"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool sameType(label(_,Symbol s),Symbol t)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool sameType(Symbol s,label(_,Symbol t))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool sameType(Symbol s,conditional(Symbol t,_))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool sameType(conditional(Symbol s,_), Symbol t)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool sameType(Symbol s, s)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default bool sameType(Symbol s, Symbol t)"))),(0,r.kt)("h2",{id:"ParseTree-isNonTerminalType"},"function isNonTerminalType"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\sort(str _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\lex(str _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\layouts(str _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\keywords(str _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\parameterized-sort(str _, list[Symbol] _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\parameterized-lex(str _, list[Symbol] _))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool isNonTerminalType(Symbol::\\start(Symbol s))")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default bool isNonTerminalType(Symbol s)"))),(0,r.kt)("h4",{id:"synopsis-17"},"Synopsis"),(0,r.kt)("p",null,"Determine if the given type is a non-terminal type."))}d.isMDXComponent=!0}}]);