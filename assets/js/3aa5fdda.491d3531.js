"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[34487],{3905:(n,e,t)=>{t.d(e,{Zo:()=>i,kt:()=>d});var r=t(67294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function c(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var l=r.createContext({}),m=function(n){var e=r.useContext(l),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},i=function(n){var e=m(n.components);return r.createElement(l.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},p=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,o=n.originalType,l=n.parentName,i=c(n,["components","mdxType","originalType","parentName"]),p=m(t),d=a,g=p["".concat(l,".").concat(d)]||p[d]||u[d]||o;return t?r.createElement(g,s(s({ref:e},i),{},{components:t})):r.createElement(g,s({ref:e},i))}));function d(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var o=t.length,s=new Array(o);s[0]=p;var c={};for(var l in e)hasOwnProperty.call(e,l)&&(c[l]=e[l]);c.originalType=n,c.mdxType="string"==typeof n?n:a,s[1]=c;for(var m=2;m<o;m++)s[m]=t[m];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},75070:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>m});var r=t(87462),a=(t(67294),t(3905));const o={title:"Load AST"},s=void 0,c={unversionedId:"Recipes/Languages/Func/LoadAST/index",id:"Recipes/Languages/Func/LoadAST/index",title:"Load AST",description:"Synopsis",source:"@site/docs/Recipes/Languages/Func/LoadAST/index.md",sourceDirName:"Recipes/Languages/Func/LoadAST",slug:"/Recipes/Languages/Func/LoadAST/",permalink:"/docs/Recipes/Languages/Func/LoadAST/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Recipes/Languages/Func/LoadAST/index.md",tags:[],version:"current",frontMatter:{title:"Load AST"},sidebar:"tutorialSidebar",previous:{title:"Eval3",permalink:"/docs/Recipes/Languages/Func/Eval3/"},next:{title:"Parse",permalink:"/docs/Recipes/Languages/Func/Parse/"}},l={},m=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4}],i={toc:m};function u(n){let{components:e,...t}=n;return(0,a.kt)("wrapper",(0,r.Z)({},i,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h4",{id:"synopsis"},"Synopsis"),(0,a.kt)("p",null,"Parse Func program from string or file and convert to an abstract syntax tree."),(0,a.kt)("h4",{id:"description"},"Description"),(0,a.kt)("p",null,"To simplify later processing, Func programs are converted to an abstract syntax tree."),(0,a.kt)("h4",{id:"examples"},"Examples"),(0,a.kt)("p",null,"The concrete syntax for Func is described in ",(0,a.kt)("a",{parentName:"p",href:"/docs/Recipes/Languages/Func/ConcreteSyntax/"},"ConcreteSyntax")," and its\nabstract syntax in ",(0,a.kt)("a",{parentName:"p",href:"/docs/Recipes/Languages/Func/AbstractSyntax/"},"AbstractSyntax"),".\nRather than manually writing conversion rules from Func parse trees to Func abstract syntax trees\nwe use our secret weapon: ",(0,a.kt)("a",{parentName:"p",href:"/docs/Library/ParseTree#ParseTree-implode"},"implode")," that performs the mapping for us.\nAs you see when you compare the concrete and abstract syntax, the ground work has already been done\nby appropriately labelling concrete rules with constructor names of the abstract syntax."),(0,a.kt)("p",null,"Here is the code for the ",(0,a.kt)("inlineCode",{parentName:"p"},"load")," funcion:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rascal"},"module demo::lang::Func::Load\n\nimport demo::lang::Func::Func;\nimport demo::lang::Func::AST;\nimport demo::lang::Func::Parse;\n\nimport ParseTree;\n\ndemo::lang::Func::AST::Prog implode(demo::lang::Func::Func::Prog p) = \n    implode(#demo::lang::Func::AST::Prog, p);\n\ndemo::lang::Func::AST::Prog load(loc l) = implode(parse(l));\ndemo::lang::Func::AST::Prog load(str s) = implode(parse(s));\n\n")),(0,a.kt)("p",null,"This looks simple but also slightly intimidating due to the many qualified names.\nThe issue is that the names in the concrete and abstract syntax are (on purpose) overloaded.\nA name like ",(0,a.kt)("inlineCode",{parentName:"p"},"Prog")," can be the one from the concrete syntax(i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"demo::lang::Func::Func::Prog"),")\nor the one from the abstract syntax (i.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"demo::lang::Func::AST::Prog"),")."),(0,a.kt)("p",null,"For instance, the local version of ",(0,a.kt)("inlineCode",{parentName:"p"},"implode")," defined here get a concrete ",(0,a.kt)("inlineCode",{parentName:"p"},"Prog")," as argument and returns an abstract one.\nBoth ",(0,a.kt)("inlineCode",{parentName:"p"},"load")," function return an abstract ",(0,a.kt)("inlineCode",{parentName:"p"},"Prog"),"."),(0,a.kt)("p",null,"Let's try this on example ",(0,a.kt)("inlineCode",{parentName:"p"},"F0"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rascal"},"fact(n) = if n <= 1 then\n             1 \n          else \n             n * fact(n-1)\n          end\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>import demo::lang::Func::Load;\nok\nrascal>import demo::lang::Func::programs::F0;\nok\nrascal>load(F0);\nProg: prog(\n  [func(\n      "fact",\n      ["n"],\n      cond(\n        leq(\n          var(\n            "n",\n            src=|unknown:///|(13,1,<1,13>,<1,14>),\n            comments=()),\n          nat(\n            1,\n            src=|unknown:///|(18,1,<1,18>,<1,19>),\n            comments=()),\n          src=|unknown:///|(13,6,<1,13>,<1,19>),\n          comments=()),\n        nat(\n          1,\n          src=|unknown:///|(38,1,<2,13>,<2,14>),\n          comments=()),\n        mul(\n          var(\n            "n",\n            src=|unknown:///|(70,1,<4,13>,<4,14>),\n            comments=()),\n          call(\n            "fact",\n            [sub(\n                var(\n                  "n",\n                  src=|unknown:///|(79,1,<4,22>,<4,23>),\n                  comments=()),\n                nat(\n                  1,\n                  src=|unknown:///|(81,1,<4,24>,<4,25>),\n                  comments=()),\n                src=|unknown:///|(79,3,<4,22>,<4,25>),\n                comments=())],\n            src=|unknown:///|(74,9,<4,17>,<4,26>),\n            comments=()),\n          src=|unknown:///|(70,13,<4,13>,<4,26>),\n          comments=()),\n        src=|unknown:///|(10,87,<1,10>,<5,13>),\n        comments=()),\n      src=|unknown:///|(0,97,<1,0>,<5,13>),\n      comments=())],\n  src=|unknown:///|(0,97,<1,0>,<5,13>),\n  comments=())\n')),(0,a.kt)("p",null,"We get the original program and its ",(0,a.kt)("strong",{parentName:"p"},"abstract syntax tree")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Prog")," back.\nIn case of doubt, compare this with the result in ",(0,a.kt)("a",{parentName:"p",href:"/docs/Recipes/Languages/Func/Parse/"},"Parse")," where we did obtain a parse tree.\nNext, we try the same from a file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rascal-shell",metastring:",continue",",continue":!0},'rascal>load(|std:///demo/lang/Func/programs/F0.func|);\nProg: prog(\n  [func(\n      "fact",\n      ["n"],\n      cond(\n        leq(\n          var(\n            "n",\n            src=|std:///demo/lang/Func/programs/F0.func|(13,1,<1,13>,<1,14>),\n            comments=()),\n          nat(\n            1,\n            src=|std:///demo/lang/Func/programs/F0.func|(18,1,<1,18>,<1,19>),\n            comments=()),\n          src=|std:///demo/lang/Func/programs/F0.func|(13,6,<1,13>,<1,19>),\n          comments=()),\n        nat(\n          1,\n          src=|std:///demo/lang/Func/programs/F0.func|(38,1,<2,13>,<2,14>),\n          comments=()),\n        mul(\n          var(\n            "n",\n            src=|std:///demo/lang/Func/programs/F0.func|(70,1,<4,13>,<4,14>),\n            comments=()),\n          call(\n            "fact",\n            [sub(\n                var(\n                  "n",\n                  src=|std:///demo/lang/Func/programs/F0.func|(79,1,<4,22>,<4,23>),\n                  comments=()),\n                nat(\n                  1,\n                  src=|std:///demo/lang/Func/programs/F0.func|(81,1,<4,24>,<4,25>),\n                  comments=()),\n                src=|std:///demo/lang/Func/programs/F0.func|(79,3,<4,22>,<4,25>),\n                comments=())],\n            src=|std:///demo/lang/Func/programs/F0.func|(74,9,<4,17>,<4,26>),\n            comments=()),\n          src=|std:///demo/lang/Func/programs/F0.func|(70,13,<4,13>,<4,26>),\n          comments=()),\n        src=|std:///demo/lang/Func/programs/F0.func|(10,87,<1,10>,<5,13>),\n        comments=()),\n      src=|std:///demo/lang/Func/programs/F0.func|(0,97,<1,0>,<5,13>),\n      comments=())],\n  src=|std:///demo/lang/Func/programs/F0.func|(0,97,<1,0>,<5,13>),\n  comments=())\n')))}u.isMDXComponent=!0}}]);