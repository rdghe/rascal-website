"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[7728],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),h=r,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||i;return a?n.createElement(d,s(s({ref:t},c),{},{components:a})):n.createElement(d,s({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1499:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var n=a(3117),r=a(102),i=(a(7294),a(3905)),s=["components"],o={sidebar_position:1,title:"Why Rascal?"},l=void 0,p={unversionedId:"WhyRascal",id:"WhyRascal",title:"Why Rascal?",description:"Synopsis.",source:"@site/docs/WhyRascal.md",sourceDirName:".",slug:"/WhyRascal",permalink:"/docs/WhyRascal",draft:!1,editUrl:"https://github.com/usethesource/rascal-website/tree/website-v2/docs/docs/WhyRascal.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Why Rascal?"},sidebar:"tutorialSidebar",next:{title:"Getting Started",permalink:"/docs/GettingStarted"}},c={},m=[{value:"Motivation",id:"motivation",level:2},{value:"The Extract-Analyze-SYnthesize (EASY) paradigm",id:"EASY",level:2},{value:"Concurrency",id:"concurrency",level:3},{value:"Forensics",id:"forensics",level:3},{value:"Model-Driven Engineering",id:"MDE",level:3},{value:"Renovation",id:"renovation",level:3},{value:"Security",id:"security",level:3},{value:"Solution Strategies",id:"solution-strategies",level:2},{value:"Extraction",id:"extraction",level:3},{value:"Analysis",id:"analysis",level:3},{value:"Synthesis",id:"synthesis",level:3},{value:"Comparison with other Paradigms",id:"comparison",level:2},{value:"ASF+SDF",id:"asf-sdf",level:3},{value:"Object-Oriented and Imperative Languages",id:"oo",level:3}],u={toc:m};function h(e){var t=e.components,o=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"What is the motivation for Rascal and which problems can you solve with it?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"We give various answers to these questions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In ",(0,i.kt)("a",{parentName:"p",href:"#motivation"},"Motivation")," we summarize the distinguishing features of Rascal and describe some\napplication domains.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#EASY"},"The Extract-Analyze-SYnthesize (EASY) paradigm")," can be used in many Rascal applications.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We have also collected ",(0,i.kt)("a",{parentName:"p",href:"#solution-strategies"},"Solution Strategies")," for a wide range of problems.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Last but not least we give a quick ",(0,i.kt)("a",{parentName:"p",href:"#comparison"},"Comparison with other Paradigms"),"."))),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"The distinguishing features of Rascal and how they solve real problems."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Meta-programs")," are programs that analyze, transform or generate other programs. Ordinary programs work on data;\nmeta-programs work on programs."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"range of programs")," to which meta-programming can be applied is large: from programs in standard languages like C\nand Java to domain-specific languages for describing high-level system models or applications in specialized areas like\ngaming or finance. In some cases, even test results or performance data are used as input for meta-programs."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"range of kinds of meta programs")," that can be applied is also large. There are simple meta programs that generate\nboilerplate code from a list of items. There are complex meta programs that reverse engineer and statically analyse a\nbig software system before visualizing the results. The point of Rascal is that in all these kinds of meta programs one\nneeds similar operations and similar data-types."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"point of Rascal")," is to provide a reusable set of primitives to build and manipulate program representations. The\npoint is ",(0,i.kt)("em",{parentName:"p"},"not")," to be or provide a unified representation of programs to let generic algorithms operate on. In meta\nprogramming the devil is often in the details. Rascal makes sure to not a priori abstract from the important details\nprogramming language syntax and semantics."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Rascal is a domain specific programming language"),". We emphasize programming here because Rascal is intended as an\nengineering tool for programmers that need to construct meta programs. Rascal programs allow running, inspecting,\ndebugging, tracing, profiling, etc. just as normal programs do. The skills of any good programmer are enough to easily\nwrite good Rascal programs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Examples.")),(0,i.kt)("p",null,"Typical applications of Rascal are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Refactoring of Java source code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Analyzing PHP code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Searching for buffer overflows in C code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Analyzing the version history of a large software project.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Implementing a ",(0,i.kt)("em",{parentName:"p"},"domain-specific language")," (DSL) for describing games or business processes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Writing compilers."))),(0,i.kt)("p",null,"All these cases involve a form of meta-programming: software programs (in a wide sense) are the objects-of-interest that\nare being analyzed, transformed or generated. Rascal can be applied in domains ranging from compiler construction and\nimplementing domain-specific languages to constraint solving and software renovation."),(0,i.kt)("p",null,"Since representation of information is central to the approach, Rascal provides a rich set of built-in data types. To\nsupport extraction and analysis, parsing and advanced pattern matching are provided. High-level control structures make\nanalysis and synthesis of complex data structures simple."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Familiar syntax")," in a ",(0,i.kt)("em",{parentName:"p"},"what-you-see is-what-you-get")," style is used even for sophisticated concepts and this makes\nthe language easy to learn and easy to use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Sophisticated built-in data types")," provide standard solutions for many meta-programming problems.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Safety")," is achieved by finding most errors before the program is executed and by making common errors like missing\ninitializations or invalid pointers impossible.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Local type inference")," makes local variable declarations redundant.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Pattern matching")," can be used to analyze all complex data structures.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Syntax definitions")," make it possible to define new and existing languages and to write tools for them.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Visiting")," makes it easy to traverse data structures and to extract information from them or to synthesize results.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Templates")," enable easy code generation.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Functions as values")," permit programming styles with high re-use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Generic types")," allow writing functions that are applicable for many different types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Eclipse integration")," makes Rascal programming a breeze. All familiar tools are at your fingertips."))),(0,i.kt)("h2",{id:"EASY"},"The Extract-Analyze-SYnthesize (EASY) paradigm"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Rascal excels in supporting the Extract-Analyze-SYnthesize (EASY) paradigm."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"easy workflow",src:a(748).Z,width:"768",height:"751"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"Many meta-programming problems follow a fixed pattern. Starting with some input system (a black box that we usually call\n",(0,i.kt)("em",{parentName:"p"},"system-of-interest"),"), first relevant information is extracted from it and stored in an internal representation. This\ninternal representation is then analyzed and used to synthesize results. If the synthesis indicates this, these steps\ncan be repeated over and over again. These steps are shown in the figure. This is an abstract view on solving\nmeta-programming problems, but is rather common."),(0,i.kt)("p",null,"Rascal has been designed to fully support problem solving that fits the EASY paradigm. We will discuss the following use\ncases represented by different ",(0,i.kt)("em",{parentName:"p"},"personas"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#concurrency"},"Concurrency"),": Concurrency analysis.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#forensics"},"Forensics"),": Domain-specific language for forensics research.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#MDE"},"Model-Driven Engineering"),": Tools for Model-Driven Engineering.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#renovation"},"Renovation"),": System renovation.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#security"},"Security"),": Security analysis."))),(0,i.kt)("h3",{id:"concurrency"},"Concurrency"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Concurrency analysis."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Daniel")," is a concurrency researcher at one of the largest hardware manufacturers worldwide. He is working from an\noffice in the Bay Area. Concurrency is the big issue for his company: it is becoming harder and harder to make CPUs\nfaster, therefore more and more of them are bundled on a single chip. Programming these multi-core chips is difficult\nand many programs that worked fine on a single CPU contain hard to detect concurrency errors due to subtle differences\nin the order of execution that results from executing the code on more than one CPU. Here is where Daniel enters the\npicture. He is working on tools for finding concurrency errors. First he extracts facts from the code that are relevant\nfor concurrency problems and have to do with calls, threads, shared variables and locks. Next, he analyzes these facts\nand synthesizes an abstract model that captures the essentials of the concurrency behaviour of the program. Finally he\nruns a third-party verification tool with this model as input to do the actual verification."),(0,i.kt)("h3",{id:"forensics"},"Forensics"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Domain-specific language for forensics research."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Bernd")," is a senior software engineer working at the Berlin headquarters of a forensic investigation lab of the German\ngovernment. His daily work is to find common patterns in files stored on digital media that have been confiscated during\ncriminal investigations. Text, audio and video files are stored in zillions of different data formats and each data\nformat requires its own analysis technique. For each new investigation ad hoc combinations of tools are used. This makes\nthe process very labour-intensive and error-prone. Bernd convinces his manager that designing a new domain-specific\nlanguage (DSL) for forensic investigations may relieve the pressure on their lab. After designing the DSL---let\u2019s call\nit DERRICK---he makes an EASY implementation for it. Given a DERRICK program for a specific case under investigation, he\nfirst extracts relevant information from it and analyzes it: which media formats are relevant? Which patterns to look\nfor? How should search results be combined? Given this new information, Java code is synthesized that uses the various\nexisting tools and combines their results."),(0,i.kt)("h3",{id:"MDE"},"Model-Driven Engineering"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Tools for Model-Driven Engineering."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Elisabeth")," is a software architect at a large airplane manufacturer and her concern is reliability and dependability of\nairplane control software. She and her team have designed a UML model of the control software and have extended it with\nannotations that describe the reliability of individual components. She will use this annotated model in two ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"to extract relevant information from it to synthesize input for a statistical tool that will compute overall system\nreliability from the reliability of individual components;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"to generate executable code that takes the reliability issues into account."))),(0,i.kt)("h3",{id:"renovation"},"Renovation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"System renovation."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Extract-Analyze-View Paradigm",src:a(9146).Z,width:"679",height:"614"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Charlotte")," is software engineer at a large financial institution in Paris and she is looking for options to connect an\nold and dusty software system to a web interface."),(0,i.kt)("p",null,"She will need to analyze the sources of that system to understand how it can be changed to meet the new requirements.\nThe objects-of-interest are in this case the source files, documentation, test scripts and any other available\ninformation. They have to be parsed in some way in order to extract relevant information, say the calls between various\nparts of the system. The call information can be represented as a binary relation between caller and callee (the\ninternal representation in this example). This relation with 1-step calls is analyzed and further extended with 2-step\ncalls, 3-step calls and so on. In this way call chains of arbitrary length become available. With this new information,\nwe can synthesize results by determining the entry points of the software system, i.e., the points where calls from the\noutside world enter the system."),(0,i.kt)("p",null,"Having completed this first cycle, Charlotte may be interested in which procedures can be called from the entry points\nand so on and so forth. Results will be typically represented as pictures that display the relationships that were\nfound. In the case of source code analysis, a variation of our workflow scheme is quite common. It is then called the\nextract-analyze-view paradigm and is shown in the figure."),(0,i.kt)("h3",{id:"security"},"Security"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Security analysis."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Alice")," is system administrator of a large online marketplace and she is looking for security breaches in her system.\nThe objects-of-interest are the system\u2019s log files. First relevant entries are extracted. This will include, for\ninstance, messages from the SecureShell demon that reports failed login attempts. From each entry login name and\noriginating IP address are extracted and put in a table (the internal representation in this example). These data are\nanalyzed by detecting duplicates and counting frequencies. Finally results are synthesized by listing the most\nfrequently used login names and IP addresses."),(0,i.kt)("h2",{id:"solution-strategies"},"Solution Strategies"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Strategies to solve problems in various domains using Rascal."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Problem Solving Workflow",src:a(7282).Z,width:"458",height:"725"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"Before you study more complicated examples, it is useful to discuss some general problem solving strategies that are\nrelevant in Rascal\u2019s application domain."),(0,i.kt)("p",null,"To appreciate these general strategies, it is good to keep some specific problem areas in mind:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Documentation generation"),": extract facts from source code and use them to generate textual documentation. A typical\nexample is generating web-based documentation for legacy languages like Cobol and PL/I.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Metrics calculation"),": extract facts from source code (and possibly other sources like test runs) and use them to\ncalculate code metrics. Examples are cohesion and coupling of modules and test coverage.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Model extraction"),": extract facts from source code and use them to build an abstract model of the source code. An\nexample is extracting lock and unlock calls from source code and to build an automaton that guarantees that\nlock/unlock occurs in pairs along every control flow path.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Model-based code generation"),": given a high-level model of a software system, described in UML or some other\nmodelling language, transform this model into executable code. UML-to-Java code generation falls in this category.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Source-to-source transformation"),": large-scale, fully automated, source code transformation with certain objectives\nlike removing deprecated language features, upgrading to newer APIs and the like.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"Interactive refactoring"),": given known ",(0,i.kt)("em",{parentName:"p"},"code smells")," a user can interactively indicate how these smells should be\nremoved. The refactoring features in Eclipse and Visual Studio are examples."))),(0,i.kt)("p",null,"With these examples in mind, we can study the overall problem solving workflow as shown in the figure above.\nIt consists of three optional phases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Is extraction needed to solve the problem, then define the extraction phase, see\n",(0,i.kt)("a",{parentName:"p",href:"#extraction"},"Extraction"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Is analysis needed, then define the analysis phase, see ",(0,i.kt)("a",{parentName:"p",href:"#analysis"},"Analysis"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Is synthesis needed, then define the synthesis phase, see ",(0,i.kt)("a",{parentName:"p",href:"#synthesis"},"Synthesis"),"."))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Validation Workflow",src:a(2461).Z,width:"553",height:"436"})),(0,i.kt)("p",null,"Each phase is subject to a validation and improvement workflow as shown in the second figure\nabove. Each individual phase as well as the combination of phases may introduce errors\nand has thus to be carefully validated. In combination with the detailed strategies for each phase, this forms a\ncomplete approach for problem solving and validation using Rascal."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Requirements Workflow",src:a(8625).Z,width:"515",height:"355"})),(0,i.kt)("p",null,"A major question in every problem solving situation is how to determine the requirements for each phase of the solution.\nFor instance, how do we know what to extract from the source code if we do not know what the desired end results of the\nproject are? The standard solution is to use a workflow for requirements gathering that is the inverse of the phases\nneeded to solve the complete problem. This is shown in the third figure above and\namounts to the phases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Requirements of the synthesis phase. This amounts to making an inventory of the desired results of the whole project\nand may include generated source code, abstract models, or visualizations.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Requirements of the analysis phase. Once these results of the synthesis phase are known, it is possible to list the\nanalysis results that are needed to synthesize desired results. Possible results of the analysis phase include type\ninformation, structural information of the original source.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Requirements of the extraction phase. As a last step, one can make an inventory of the facts that have to be\nextracted to form the starting point for the analysis phase. Typical facts include method calls, inheritance\nrelations, control flow graphs, usage patterns of specific library functions or language constructs."))),(0,i.kt)("p",null,"You will have no problem in identifying requirements for each phase when you apply them to a specific example from the\nlist given earlier."),(0,i.kt)("p",null,"When these requirements have been established, it becomes much easier to actually carry out the project using the three\nphases of the first figure above."),(0,i.kt)("p",null,"We will discuss:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#extraction"},"Extraction"),": Strategies to extract facts from software systems.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#analysis"},"Analysis"),": Strategies to analyze software systems.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#synthesis"},"Synthesis"),": Strategies to synthesise results."))),(0,i.kt)("h3",{id:"extraction"},"Extraction"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Strategies to extract facts from software systems."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Extraction Workflow",src:a(5237).Z,width:"714",height:"1008"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"How can we extract facts from the ",(0,i.kt)("em",{parentName:"p"},"System under Investigation")," (SUI) that we are interested in? The extraction workflow\nis shown in the figure above and consists of the following steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"First and foremost we have to determine which facts we need. This sounds trivial, but it is not. The problem is that\nwe have to anticipate which facts will be needed in the next---not yet defined---analysis phase. A common approach\nis to use look-ahead and to sketch the queries that are likely to be used in the analysis phase and to determine\nwhich facts are needed for them. Start with extracting these facts and refine the extraction phase when the analysis\nphase is completely defined.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If relevant facts are already available (and they are reliable","!",") then we are done. This may happen when you are\nworking on a system that has already been analyzed by others.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise you need the source code of the SUI. This requires:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Checking that all sources are available (and can be compiled by the host system on which they are usually\ncompiled and executed). Due to missing or unreliable configuration management on the original system this may be\na labour-intensive step that requires many iterations.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Determining in which languages the sources are written. In larger systems it is common that three or more\ndifferent languages are being used.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If there are reliable third-party extraction tools available for this language mix, then we only have to apply them\nand we are done. Here again, validation is needed that the extracted facts are as expected.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The extraction may require syntax analysis. This is the case when more structural properties of the source code are\nneeded such as the flow-of-control, nesting of declarations, and the like. There two approaches here:")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use a third-party parser, convert the source code to parse trees and do the further processing of these parse trees\nin Rascal. The advantage is that the parser can be re-used, the disadvantage is that data conversion is needed to\nadapt the generated parse tree to Rascal. Validate that the parser indeed accepts the language the SUI is written\nin, since you will not be the first who has been bitten by the language dialect monster when it turns out that the\nSUI uses a local variant that slightly deviates from a mainstream language.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use an existing syntax definition of the source language or write your own definition. Be aware, however, that\nwriting a grammar for a non-trivial language is a major undertaking and may require weeks to month of work. Whatever\napproach you choose, validate that the resulting grammar is compliant with the original grammar of the source\nlanguage.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The extraction phase may only require lexical analysis. This happens when more superficial, textual, facts have to\nbe extracted like procedure calls, counts of certain statements and the like. Use Rascal\u2019s full regular expression\nfacilities to do the lexical analysis."))),(0,i.kt)("p",null,"It may happen that the facts extracted from the source code are ",(0,i.kt)("em",{parentName:"p"},"wrong"),". Typical error classes are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Extracted facts are ",(0,i.kt)("em",{parentName:"p"},"wrong"),": the extracted facts incorrectly state that procedure P calls procedure Q but this is\ncontradicted by a source code inspection. This may happen when the fact extractor uses a conservative approximation\nwhen precise information is not statically available. In the language C, when procedure P performs an indirect call\nvia a pointer variable, the approximation may be that P calls all procedures in the procedures.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Extracted facts are ",(0,i.kt)("em",{parentName:"p"},"incomplete"),": the inheritance between certain classes in Java code is missing."))),(0,i.kt)("p",null,"The strategy to validate extracted facts differ per case but here are three strategies:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Post process the extracted facts (using Rascal, of course) to obtain trivial facts about the source code such as\ntotal lines of source code and number of procedures, classes, interfaces and the like. Next validate these trivial\nfacts with tools like wc (word and line count), grep (regular expression matching) and others.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Do a manual fact extraction on a small subset of the code and compare this with the automatically extracted facts.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use another tool on the same source and compare results whenever possible. A typical example is a comparison of a\ncall relation extracted with different tools."))),(0,i.kt)("p",null,"The Rascal features that are most frequently used for extraction are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Regular expression patterns to extract textual facts from source code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Syntax definitions and concrete patterns to match syntactic structures in source code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Pattern matching (used in many Rascal statements).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Visits to traverse syntax trees and to locally extract information.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The repertoire of built-in datatypes (like lists, maps, sets and relations) to represent the extracted facts."))),(0,i.kt)("h3",{id:"analysis"},"Analysis"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Strategies to analyze software systems."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Analysis Workflow",src:a(3976).Z,width:"714",height:"361"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"The analysis workflow is shown in the figure above and consists of two steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Determine the results that are needed for the synthesis phase.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Write the Rascal code to perform the analysis. This may amount to:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Reordering extracted facts to make them more suitable for the synthesis phase.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Enriching extracted facts. Examples are computing transitive closures of extracted facts (e.g., A may call B in\none or more calls), or performing data reduction by abstracting aways details (i.e., reducing a program to a\nfinite automaton).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Combining enriched, extracted, facts to create new facts."))))),(0,i.kt)("p",null,"As before, validate, validate and validate the results of analysis. Essentially the same approach can be used as for\nvalidating the facts. Manual checking of answers on random samples of the SUI may be mandatory. It also happens\nfrequently that answers inspire new queries that lead to new answers, and so on."),(0,i.kt)("p",null,"The Rascal features that are frequently used for analysis are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"List, set and map comprehensions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The built-in operators and library functions, in particular for lists, maps, sets and relations.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Pattern matching (used in many Rascal statements).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Visits and switches to further process extracted facts.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The solve statement for constraint solving.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rewrite rules to simplify results and to enforce constraints."))),(0,i.kt)("h3",{id:"synthesis"},"Synthesis"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Strategies to synthesise results."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Synthesis Workflow",src:a(7756).Z,width:"745",height:"870"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"Results are synthesized as shown in the figure above. This consists of the\nfollowing steps:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Determine the results of the synthesis phase. Wide range of results is possible including:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generated source code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generated abstract representations, like finite automata or other formals models that capture properties of the\nSUI.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generated data for visualizations that will be used by visualization tools.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If source code is to be generated, there are various options."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Print strings with embedded variables.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Convert abstract syntax trees to strings (perhaps using forms of pretty printing).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use a grammar of the target source language, also for code generation. Note that this approach guarantees the\ngeneration of syntactically correct source code as opposed to code generation using print statements or string\ntemplates.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If other output is needed (e.g., an automaton or other formal structure) write data declarations to represent that\noutput.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Finally, write functions and rewrite rules that generate the desired results."))),(0,i.kt)("p",null,"The Rascal features that are frequently used for synthesis are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Syntax definitions or data declarations to define output formats.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Pattern matching (used in many Rascal statements).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Visits of datastructures and on-the-fly code generation.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rewrite rules."))),(0,i.kt)("h2",{id:"comparison"},"Comparison with other Paradigms"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Rascal compared with the imperative, object-oriented and algebraic paradigms"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"Rascal provides both familiar and unfamiliar features. These will be appreciated differently by programmers that are\nexpert in other language paradigms. We provide the following comparisons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#asf-sdf"},"ASF+SDF"),": Rascal explained for ASF+SDF programmers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#oo"},"Object-Oriented and Imperative Languages"),": Rascal explained for OO and imperative\nprogrammers."))),(0,i.kt)("h3",{id:"asf-sdf"},"ASF+SDF"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Rascal explained for ASF+SDF programmers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"Rascal is the successor of the specification language ASF+SDF that is part of the ",(0,i.kt)("a",{parentName:"p",href:"http://www.meta-environment.org"},"ASF+SDF\nMeta-Environment"),"."),(0,i.kt)("p",null,"What are the differences between ASF+SDF and Rascal? What are the commonalities?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal has all the high level features of ASF+SDF and some more. Regarding functionality, old ASF+SDF specifications\ncould, in principle, be transformed into Rascal programs using a conversion tool. We do not provide such a tool\nsince it turns out to be better to redesign your specification from scratch to profit most from all the new features\nin Rascal.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal uses its own syntax definition notation that is richer than SDF. It also uses its own parser generation and\nparsing technology. Parser generation is currently somewhat slower than for SDF, the generated parsers are, however,\nsubstantially faster than SDF-based parsers. SDF specification can be automatically converted to Rascal, but here\nagain, manual conversion leads to better results.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Like in ASF+SDF, Rascal has modules that introduce a namespace scope for variables and functions, which can be\neither private or public. Modules can have type parameters as in SDF, which are instantiated by import statements.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In Rascal, patterns and variables in concrete syntax may optionally be quoted and escaped, and explicit declaration\nof the top non-terminal is supported to solve ambiguity.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal does not support rewrite rules. Instead pattern-directed function definition and invocation can be used.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Unlike ASF+SDF, Rascal has native, efficient, implementations for lists, sets, relations and maps.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Unlike ASF+SDF, Rascal can be used without parsing or concrete syntax, supporting for example regular expressions\nand abstract data types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal has native support for functions, which have a fixed syntax, always return a value and have a body consisting\nof imperative control flow statements. Adding a function will not trigger the need for regenerating parse tables as\nis the case in the ASF+SDF implementation. Function types can be polymorphic in their parameters and also allow\nfunctions as arguments to implement reusable algorithms.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The imperative nature of Rascal allows you to factor out common code and nest conditionals, unlike in ASF+SDF where\nalternative control flow paths have to be encoded by enumerating equations with non-overlapping conditions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is an imperative language, which natively supports I/O and other side-effects without the workarounds that\nare needed in ASF+SDF to achieve this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal has native support for traversals, instead of the add-on it used to be in ASF+SDF. The visit statement is\ncomparable to a traversal function in ASF+SDF, and is as type-safe as the traversal function, but it is more\nprogrammeable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of accumulator values of traversal functions in ASF+SDF, Rascal simply supports lexically scoped variables\nthat can be updated using assignments.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal natively supports specific expressions and datatypes for relational calculus, all borrowed directly from\nRScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When programming using Rascal functions, instead of rules, the control flow of a program becomes easily traceable\nand debuggable. It is simply like stepping through well structured code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is based on a Java interpreter, or a Java run-time when compiled. So the code is more portable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is supported by a modern, Eclipse-based, IDE, unlike the simple IDE of the ASF+SDF Meta-Environment. IDE\nservices like keyword highlighting, outlining, and more are available for the Rascal programmer."))),(0,i.kt)("h3",{id:"oo"},"Object-Oriented and Imperative Languages"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Synopsis.")),(0,i.kt)("p",null,"Rascal explained for OO and imperative programmers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Description.")),(0,i.kt)("p",null,"Rascal is an imperative domain-specific language (DSL) for meta-programming. It provides high level statements and\nexpressions specifically targeted at the domain of analysis and transformation of source code."),(0,i.kt)("p",null,"How does Rascal differ from an OO language or an imperative language?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Unlike OO languages, Rascal does not provide classes. Rascal has modules which can best be compared with a static\nclass in Java.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Objects in an OO language (class instances) can have mutable local state (i.e, each object can have instance\nvariables that can be modified after object creation). In Rascal all values are immutable after creation. Sharing a\nvalue does not introduce a coupling like in OO, simply because changes are only visible to the code that changes the\nvalues. Without mutability it is easy to combine stages of programs that perform different tasks.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal does provide a mechanism for introducing user-defined types. An ",(0,i.kt)("em",{parentName:"p"},"Algebraic Data Type")," introduces a new type\nand is defined by a number of ",(0,i.kt)("em",{parentName:"p"},"constructor functions"),' to construct values of that type. The constructed values are\nimmutable. Although they are both called "constructors" there is a big difference between constructors in OO\nlanguages and in Rascal. The former create mutable objects while the latter create immutable values.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Variables can, however, be associated with different immutable values during their lifetime. This is why we say that\nRascal is a weakly imperative language. Rascal is, however, closer, to functional languages than to OO languages or\nimperative languages.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is safe: there are no null values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is even more safe: it has a type system that prevents casting exceptions and other run-time failures. Still\nthe type system specifically allows many kinds of combinations. For example, unlike in Java a set of integers is a\nsubtype of a set of numbers (co-variance), which allows you to reuse algorithm for sets of numbers on sets of\nintegers. It also provides true polymorphic and functions (no erasure), and functions can safely be parameters to\nother functions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal supports unchecked exceptions, throw and catch statements are available, but exceptions do not ",(0,i.kt)("em",{parentName:"p"},"have")," to be\ndeclared in function headers (but they ",(0,i.kt)("em",{parentName:"p"},"may")," be declared for documentation purposes).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal provides high-level statements and expressions for:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Visitors in all kinds of orders, expressed very concisely, and type safe.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Pattern matching and construction (with and without concrete syntax","!",").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Equation/constraint solving.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Relational calculus.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rewrite rules for normalization/canonicalization of any kind of data-structure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Support for parser generation and parsing using context-free grammars.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"(De)Serialization of values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Communication with databases.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal provides typed data constructors for common mathematical structures, such as:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Terms (a.k.a. tree nodes or abstract data types).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Parse trees (derivations of context-free grammars, for concrete syntax and direct manipulation of source code).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Lists, tuples, maps, sets, relations, and graphs.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In Rascal you can implement high-fidelity source-to-source transformations. Without too much overhead, programs can\ndo extensive rewriting of the source code without the loss of particular layout standards or source code comments.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is syntax-safe. When you use Rascal to generate or transform source code, it statically detects whether the\nresulting source code is syntactically correct.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rascal is executed by an interpreter written in Java, or it can be compiled to Java classes."))))}h.isMDXComponent=!0},3976:function(e,t,a){t.Z=a.p+"assets/images/define-analysis-e475ec1a02621a48c955412b801ef4f8.png"},5237:function(e,t,a){t.Z=a.p+"assets/images/define-extraction-05557091ab296ece0b761172a7016639.png"},7756:function(e,t,a){t.Z=a.p+"assets/images/define-synthesis-75080d2b5bb9551f574415fdfdcc0131.png"},748:function(e,t,a){t.Z=a.p+"assets/images/easy-workflow-0249a107066e7e1ec8eda72986161b23.png"},9146:function(e,t,a){t.Z=a.p+"assets/images/extract-analyze-view-paradigm-16afa89916cdd851b56731a9212b709d.png"},7282:function(e,t,a){t.Z=a.p+"assets/images/problem-solving-e29c50811d2d2b35826e529643e1931c.png"},8625:function(e,t,a){t.Z=a.p+"assets/images/requirements-bac17528df86b048ac961830abe79ba0.png"},2461:function(e,t,a){t.Z=a.p+"assets/images/validation-9d9656edaf7509c7eeeba74043f09382.png"}}]);