"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[3122],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return u}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=s(a),u=l,k=m["".concat(p,".").concat(u)]||m[u]||d[u]||r;return a?n.createElement(k,i(i({ref:t},c),{},{components:a})):n.createElement(k,i({ref:t},c))}));function u(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=a.length,i=new Array(r);i[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2290:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return u},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return d}});var n=a(3117),l=a(102),r=(a(7294),a(3905)),i=["components"],o={sidebar_position:9,title:"TypePal"},p=void 0,s={unversionedId:"TypePal",id:"TypePal",title:"TypePal",description:"Synopsis.",source:"@site/docs/TypePal.md",sourceDirName:".",slug:"/TypePal",permalink:"/docs/TypePal",draft:!1,editUrl:"https://github.com/usethesource/rascal-website/tree/main/packages/create-docusaurus/templates/shared/docs/TypePal.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"TypePal"},sidebar:"tutorialSidebar",previous:{title:"Rascal Shell",permalink:"/docs/RascalShell"},next:{title:"Runtime Errors",permalink:"/docs/RunTimeErrors"}},c={},d=[{value:"Overview",id:"overview",level:2},{value:"A Calculator Language",id:"a-calculator-language",level:2},{value:"Syntax of Calc",id:"syntax-of-calc",level:3},{value:"Typechecking Calc",id:"typechecking-calc",level:3},{value:"Begin of type checker module for Calc",id:"begin-of-type-checker-module-for-calc",level:3},{value:"Extend AType",id:"extend-atype",level:3},{value:"Collecting facts and constraints",id:"collecting-facts-and-constraints",level:3},{value:"Check Declaration",id:"check-declaration",level:5},{value:"Check Exp: Id",id:"check-exp-id",level:5},{value:"Check Exp: Boolean and Integer constants",id:"check-exp-boolean-and-integer-constants",level:5},{value:"Check Exp: parentheses",id:"check-exp-parentheses",level:5},{value:"Check Exp: addition",id:"check-exp-addition",level:5},{value:"Check Exp: multiplication",id:"check-exp-multiplication",level:5},{value:"Check Exp: conditional expression",id:"check-exp-conditional-expression",level:5},{value:"Testing the Calc typechecker",id:"testing-the-calc-typechecker",level:3},{value:"Getting started",id:"getting-started",level:3},{value:"Manual testing",id:"manual-testing",level:3},{value:"Automated testing",id:"automated-testing",level:3},{value:"Concepts and Definitions",id:"concepts-and-definitions",level:2},{value:"Identifier",id:"identifier",level:3},{value:"Tree",id:"tree",level:3},{value:"Scope",id:"scope",level:3},{value:"Scope Graph",id:"scope-graph",level:3},{value:"Identifier definition",id:"identifier-definition",level:3},{value:"Identifier Use",id:"identifier-use",level:3},{value:"Path",id:"path",level:3},{value:"Name Resolution",id:"name-resolution",level:3},{value:"Role",id:"role",level:3},{value:"Identifier Role",id:"identifier-role",level:3},{value:"Scope Role",id:"scope-role",level:3},{value:"Path Role",id:"path-role",level:3},{value:"Types",id:"types",level:3},{value:"DefInfo",id:"definfo",level:3},{value:"Architecture of TypePal",id:"architecture-of-typepal",level:2},{value:"Reporting",id:"reporting",level:2},{value:"Collector",id:"collector",level:2},{value:"LifeCycle of Collector",id:"lifecycle-of-collector",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Scoping",id:"scoping",level:3},{value:"Scope Info",id:"scope-info",level:3},{value:"Nested Info",id:"nested-info",level:3},{value:"Composition",id:"composition",level:3},{value:"Reporting",id:"reporting-1",level:3},{value:"Add Path",id:"add-path",level:3},{value:"Add a path to a definition",id:"add-a-path-to-a-definition",level:3},{value:"Add a path to a qualified definition",id:"add-a-path-to-a-qualified-definition",level:3},{value:"Add a path to a type",id:"add-a-path-to-a-type",level:3},{value:"Define",id:"define",level:3},{value:"Use",id:"use",level:3},{value:"Use an unqualified name",id:"use-an-unqualified-name",level:3},{value:"Use a qualified name",id:"use-a-qualified-name",level:3},{value:"Use a name via another type",id:"use-a-name-via-another-type",level:3},{value:"UseLub",id:"uselub",level:3},{value:"Inference",id:"inference",level:3},{value:"Fact",id:"fact",level:3},{value:"Calculate",id:"calculate",level:3},{value:"Require",id:"require",level:3},{value:"Solver",id:"solver",level:2},{value:"Lifecycle of Solver",id:"lifecycle-of-solver",level:3},{value:"Fact",id:"fact-1",level:3},{value:"Calculate",id:"calculate-1",level:3},{value:"equal",id:"equal",level:3},{value:"subtype",id:"subtype",level:3},{value:"comparable",id:"comparable",level:3},{value:"unify",id:"unify",level:3},{value:"lub",id:"lub",level:3},{value:"Require",id:"require-1",level:3},{value:"requireEqual",id:"requireequal",level:3},{value:"requireSubType",id:"requiresubtype",level:3},{value:"requireCompare",id:"requirecompare",level:3},{value:"requireUnify",id:"requireunify",level:3},{value:"requireTrue and requireFalse",id:"requiretrue-and-requirefalse",level:3},{value:"Types",id:"types-1",level:3},{value:"getType",id:"gettype",level:3},{value:"getTypeInScope",id:"gettypeinscope",level:3},{value:"getTypeInScopeFromName",id:"gettypeinscopefromname",level:3},{value:"getTypeInType",id:"gettypeintype",level:3},{value:"getAllDefinedInType",id:"getalldefinedintype",level:3},{value:"Inference",id:"inference-1",level:3},{value:"instantiate",id:"instantiate",level:3},{value:"isFullyInstantiated",id:"isfullyinstantiated",level:3},{value:"Reporting",id:"reporting-2",level:3},{value:"Global Info",id:"global-info",level:3},{value:"getConfig",id:"getconfig",level:3},{value:"getFacts",id:"getfacts",level:3},{value:"getStore",id:"getstore",level:3},{value:"TypePal Configuration",id:"typepal-configuration",level:2},{value:"Name Resolution &amp; Overloading",id:"name-resolution--overloading",level:3},{value:"isAcceptableSimple",id:"isacceptablesimple",level:3},{value:"isAcceptableQualified",id:"isacceptablequalified",level:3},{value:"isAcceptablePath",id:"isacceptablepath",level:3},{value:"mayOverload",id:"mayoverload",level:3},{value:"Operations on Types",id:"operations-on-types",level:3},{value:"isSubType",id:"issubtype",level:3},{value:"getLub",id:"getlub",level:3},{value:"getMinAType",id:"getminatype",level:3},{value:"getMaxAType",id:"getmaxatype",level:3},{value:"instantiateTypeParameters",id:"instantiatetypeparameters",level:3},{value:"Retrieval of Types",id:"retrieval-of-types",level:3},{value:"getTypeNamesAndRole",id:"gettypenamesandrole",level:3},{value:"getTypeInTypeFromDefine",id:"gettypeintypefromdefine",level:3},{value:"getTypeInNamelessType",id:"gettypeinnamelesstype",level:3},{value:"Extension Points",id:"extension-points",level:3},{value:"preSolver",id:"presolver",level:3},{value:"postSolver",id:"postsolver",level:3},{value:"Miscellaneous",id:"miscellaneous",level:3},{value:"unescapeName",id:"unescapename",level:3},{value:"validateConstraints",id:"validateconstraints",level:3},{value:"Verbosity",id:"verbosity",level:3},{value:"showTimes",id:"showtimes",level:3},{value:"showSolverSteps",id:"showsolversteps",level:3},{value:"showSolverIterations",id:"showsolveriterations",level:3},{value:"showAttempts",id:"showattempts",level:3},{value:"showTModel",id:"showtmodel",level:3},{value:"Utilities",id:"utilities",level:2},{value:"collectAndSolve",id:"collectandsolve",level:3},{value:"getUseDef",id:"getusedef",level:3},{value:"getVocabulary",id:"getvocabulary",level:3},{value:"getFacts",id:"getfacts-1",level:3},{value:"getMessages",id:"getmessages",level:3},{value:"Examples of Typecheckers",id:"examples-of-typecheckers",level:2},{value:"Calc",id:"calc",level:3},{value:"Pico",id:"pico",level:3},{value:"QL",id:"ql",level:3},{value:"Fun",id:"fun",level:3},{value:"ModFun",id:"modfun",level:3},{value:"Struct",id:"struct",level:3},{value:"Aliases",id:"aliases",level:3},{value:"StaticFields",id:"staticfields",level:3},{value:"StructParameters",id:"structparameters",level:3},{value:"SmallOO",id:"smalloo",level:3},{value:"FWJava",id:"fwjava",level:3},{value:"Pascal",id:"pascal",level:3},{value:"UntypedFun",id:"untypedfun",level:3}],m={toc:d};function u(e){var t=e.components,o=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"TypePal is a framework for name analysis, type checking and type inference"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Many type checkers have already been written in Rascal with good results. However, type checkers for different languages\nhave a lot in common and address similar questions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to handle declarations of names, in particular their scope and uses?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to distinguish the roles names can play, e.g., names of functions, data types, labels, constants or variables?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to handle imports and multiple name spaces?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to associate requirements/constraints relevant for type checking with the syntax definition of the language\nbeing type checked?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to represent the types that occur in a program?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to handle global or local type inference?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to handle overloading?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to give precise error messages (and avoid spurious messages)?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to extract information that is useful for later compiler stages or the IDE for, e.g., code generation, use-def\ninformation or name completion?"))),(0,r.kt)("p",null,"TypePal is a Rascal framework that addresses the above questions and we describe here all its concepts, architecture and\nfeatures and also show some examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Overview"},"Overview"),": An overview of TypePal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-PocketCalculator"},"A Calculator Language"),": Calc illustraties the basic facilities of TypePal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-ConceptsAndDefinitions"},"Concepts and Definitions"),": The concepts and definitions used in TypePal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Architecture"},"Architecture of TypePal"),": Architectural overview of TypePal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Reporting"},"Reporting"),": How to format and report errors, warnings and info messages.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Collector"},"Collector"),": A ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," collects constraints from source code and produces an initial\n",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Solver"},"Solver"),": A ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," tries to solve the constraints in a ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),"; unsolved constraints produce\nerror messages.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),": Configuration options for TypePal.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Utilities"},"Utilities"),": Some utility functions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("a",{parentName:"p",href:"#TypePal-Examples"},"Examples of Typecheckers"),": Examples of type checkers built with TypePal."))),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"An overview of TypePal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"TypePal is a declarative framework that operates on a model of the program to be type checked that consisting of"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"facts")," that some source code fragment has a known type, e.g., an integer literal is of type integer, or that its\ntype is equal to the type of another source code fragment, e.g., the type of the expression in parentheses ",(0,r.kt)("inlineCode",{parentName:"p"},"( e )"),"\nis equal to the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"e"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"calculators")," that compute the type of a source code fragment and create new facts; this computation may also need\nthe types of one or more other source code fragments, e.g., computing the type of the addition operator is based on\nthe types of its operands.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"requirements")," that are imposed on a source code fragment by the type system being used; a requirement may need the\ntypes of one or more other source code fragments, e.g., if the expression on the right-hand side of an assignment\nhas type integer, then the type of the variable on the left-hand side should be compatible with the type integer."))),(0,r.kt)("p",null,"We call this model the ",(0,r.kt)("em",{parentName:"p"},"TModel"),' (for "Type Model") of the program: facts describe elementary observations and equalities\nbetween types, calculators compute new type facts, and requirements impose restrictions on the types of program\nfragments. A requirement or calculator may detect a type violation and will then generate an error message. When a\nrequirement is satisfied or a calculator computes a new type, this leads to the creation of new facts that may trigger\nthe computation of other requirements and calculators.'),(0,r.kt)("p",null,"Technically, TypePal uses ",(0,r.kt)("em",{parentName:"p"},"scope graphs")," for expressing definition and use of names (including their role, scope, name\nspace, and visibility), and ",(0,r.kt)("em",{parentName:"p"},"constraints")," to describe facts, requirements and calculators. These constraints are such\nthat they can express either type checking or type inference, or a mixture thereof. Under the hood, these constraints\nare solved in an efficient, data-driven, fashion."),(0,r.kt)("p",null,"TypePal is highly parameterized and can be adapted to specific type checking needs."),(0,r.kt)("h2",{id:"a-calculator-language"},"A Calculator Language"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Calc illustraties the basic facilities of TypePal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"By developing a type checker for ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Calc")),", a tiny pocket calculator language, we illustrate elementary usage of\nTypePal. The full source code of Calc can be found at\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/calc"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/calc"),". See ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Examples"},"Examples of Typecheckers"),"\nfor a list of all available type checker examples."),(0,r.kt)("h3",{id:"syntax-of-calc"},"Syntax of Calc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'module lang::calc::Syntax\n\nextend lang::CommonLex;     \n\nstart syntax Calc\n    = Decl+                 \n    ;\n\nsyntax Decl\n    = "var" Id "=" Exp ";"  \n    ;\n\nsyntax Exp\n   = Id                             \n   | Integer                        \n   | Boolean                        \n   | bracket "(" Exp ")"            \n   > left Exp "*" Exp               \n   > left Exp "+" Exp               \n   > "if" Exp "then" Exp "else" Exp \n   ;\n\nkeyword Reserved\n    = "var" | "if" | "then" | "else"\n    ;\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For brevity we use some common lexical definitions in ",(0,r.kt)("inlineCode",{parentName:"p"},"lang::CommonLex"),". They take, amongst others, care of\nwhitespace, comments and definitions for integer and Boolean constants (",(0,r.kt)("inlineCode",{parentName:"p"},"Integer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Boolean"),") as well as\nidentifiers (",(0,r.kt)("inlineCode",{parentName:"p"},"Id"),").")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A Calc program consists of one or more declarations (",(0,r.kt)("inlineCode",{parentName:"p"},"Decl"),").")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Each declaration introduces a new variable and binds it to the value of an expression.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"An expression can be an identifier (that should have been introduced in a preceding declaration), or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"an integer constant, or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a Boolean constant, or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"be surrounded by parentheses, or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a multiplication (arguments should have the same type), or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"an addition (arguments should have the same type), or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a conditional expression (the first expression should have type Boolean, the other two should have the same type)."))),(0,r.kt)("h3",{id:"typechecking-calc"},"Typechecking Calc"),(0,r.kt)("p",null,"Type checking Calc amounts to checking the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Every name that is used in an expression should have been defined in a declaration and has the type of the\nexpression in that declaration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Addition or multiplication on integers yields an integer type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Addition or multiplication on Booleans yields a Boolean type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The condition in a condional expression should be Boolean.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The then and else part of a conditional expression should have the same type; that type becomes the type of the\nconditional expression."))),(0,r.kt)("p",null,"Let\u2019s now move to the Calc type checker described in ",(0,r.kt)("inlineCode",{parentName:"p"},"lang::calc::Checker"),". We break it up in parts and describe the\nparts as we go. You should be explicitly aware of the fact that type checking consists of two phases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Collecting facts and constraints"),": this is all about formulating constraints and attaching them to parts of the\nsource program. In this phase types are unknown and constraints can only be created but not yet solved. All\ncomputations on types have therefore to be postponed until the solving phase. We will see how in a minute.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Solving constraints"),": constraints are solved (if possible) and types are assigned to parts of the source program."))),(0,r.kt)("h3",{id:"begin-of-type-checker-module-for-calc"},"Begin of type checker module for Calc"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"module lang::calc::Checker\n\nimport lang::calc::Syntax;                  // The Calc syntax\nextend analysis::typepal::TypePal;          // TypePal\n")),(0,r.kt)("p",null,"We import the Calc syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"lang::calc::Syntax")," and then we ",(0,r.kt)("em",{parentName:"p"},"extend")," the TypePal ",(0,r.kt)("inlineCode",{parentName:"p"},"analysis::typepal::TypePal"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"There is a technical reason why we have to extend TypePal rather than import it. Some data types (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"AType"),") and\nfunctions (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"collect"),") are already defined in TypePal itself and they are being extended in each type checker.")),(0,r.kt)("h3",{id:"extend-atype"},"Extend AType"),(0,r.kt)("p",null,"TypePal has a built-in data type to represent types: ",(0,r.kt)("inlineCode",{parentName:"p"},"AType"),". This data type can be extended to represent\nlanguage-specific types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'data AType\n    = boolType()\n    | intType()\n    ;\n\nstr prettyAType(boolType()) = "bool";\nstr prettyAType(intType()) = "int";\n')),(0,r.kt)("p",null,"The values in Calc are Booleans and integers and we create two ",(0,r.kt)("inlineCode",{parentName:"p"},"AType")," constants ",(0,r.kt)("inlineCode",{parentName:"p"},"boolType()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"intType()")," to\nrepresent these types. ",(0,r.kt)("inlineCode",{parentName:"p"},"prettyAType")," converts them back to a string representation; this is used in error reporting."),(0,r.kt)("h3",{id:"collecting-facts-and-constraints"},"Collecting facts and constraints"),(0,r.kt)("p",null,"Writing a type checker in TypePal amounts to collecting facts and constaints from a source program to be checked. This\nis achieved by the ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," function that has the form"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: syntactic pattern, Collector c){ ... }`\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("em",{parentName:"p"},"syntactic pattern")," corresponds with a rule from the language syntax, in this case ",(0,r.kt)("inlineCode",{parentName:"p"},"lang::calc::Syntax"),". The\n",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," argument provides methods to add facts and constraints."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"One ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," declaration is needed per alternative in the syntax but some rules (i.e., chain rules) are handled\nautomatically.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"By convention the syntactic pattern is named ",(0,r.kt)("inlineCode",{parentName:"p"},"current")," and the Collector is named ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),".")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Warning")),(0,r.kt)("p",{parentName:"blockquote"},"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," declaration is responsible for calling ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," on relevant subparts (a run-time error is given for a\nmissing ",(0,r.kt)("inlineCode",{parentName:"p"},"collect"),").")),(0,r.kt)("h5",{id:"check-declaration"},"Check Declaration"),(0,r.kt)("p",null,"A declaration introduces a new name and associates the type of the righthand side expression with it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Decl) `var <Id name> = <Exp exp> ;`, Collector c){\n    c.define("<name>", variableId(), current, defType(exp));\n    collect(exp, c);\n}\n')),(0,r.kt)("p",null,"Here we define ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," as a variable and define its type as the same type as ",(0,r.kt)("inlineCode",{parentName:"p"},"exp"),". Let\u2019s digest this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"c.define(\u2026\u200b)")," calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"define")," function in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," and adds this definition to the internal state of the\nCollector.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"name")," is a parse tree for the lexical syntax rule ",(0,r.kt)("inlineCode",{parentName:"p"},"Id"),". ",(0,r.kt)("inlineCode",{parentName:"p"},'"<name>"')," reduces this tree to a string and this is how\nthe variable can be used later on.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"variableId()")," defines that the role of this name (",(0,r.kt)("inlineCode",{parentName:"p"},"IdRole"),") is a variable. ",(0,r.kt)("inlineCode",{parentName:"p"},"variableId")," is a built-in role\n",(0,r.kt)("inlineCode",{parentName:"p"},"IdRole"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"current")," is the parse tree of the whole declaration, we use it as unique identification of the definition of\n",(0,r.kt)("inlineCode",{parentName:"p"},"name"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"defType")," is used to define the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and it comes in several flavours. Here, we use another parse tree\nfragment ",(0,r.kt)("inlineCode",{parentName:"p"},"exp")," as argument. ",(0,r.kt)("inlineCode",{parentName:"p"},"defType(exp)")," should be read as ",(0,r.kt)("em",{parentName:"p"},"the same type as")," ",(0,r.kt)("inlineCode",{parentName:"p"},"exp")," and the effect is that ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),"\nis defined having the same type as ",(0,r.kt)("inlineCode",{parentName:"p"},"exp"),". This implies that the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," can only be known when the type of\n",(0,r.kt)("inlineCode",{parentName:"p"},"exp")," is known."))),(0,r.kt)("h5",{id:"check-exp-id"},"Check Exp: Id"),(0,r.kt)("p",null,"An expression consisting of a single identifier, refers to a name introduced in another declaration and gets the type\nintroduced in that declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: (Exp) `<Id name>`, Collector c){\n    c.use(name, {variableId()});\n}\n")),(0,r.kt)("p",null,"An expression consisting of a single identifier represents a ",(0,r.kt)("em",{parentName:"p"},"use")," of that identifier. ",(0,r.kt)("inlineCode",{parentName:"p"},"c.use(name, roles)")," records\nthis. There are then two possibilities:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a matching define is found for one of the given roles: use and definition are connected to each other.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"no matching define is found and an error is reported."))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"In larger languages names may be defined in different scopes. Scopes do not play a role in Cal.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"We do not enforce ",(0,r.kt)("em",{parentName:"p"},"define-before-use")," in this example, but see ",(0,r.kt)("a",{parentName:"p",href:"#XXX"},"???")," how to achieve this.")),(0,r.kt)("h5",{id:"check-exp-boolean-and-integer-constants"},"Check Exp: Boolean and Integer constants"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: (Exp) `<Boolean boolean>`, Collector c){\n    c.fact(current, boolType());\n}\n\nvoid collect(current: (Exp) `<Integer integer>`, Collector c){\n    c.fact(current, intType());\n}\n")),(0,r.kt)("p",null,"When encountering a Boolean or integer constant we record their type using ",(0,r.kt)("inlineCode",{parentName:"p"},"c.fact(current, its type)"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note")),(0,r.kt)("p",{parentName:"blockquote"},"The second argument of ",(0,r.kt)("inlineCode",{parentName:"p"},"fact")," maybe an ",(0,r.kt)("inlineCode",{parentName:"p"},"AType"),", an arbitrary parse tree (in which case the type of that tree will be\nused), or a function that returns a type.")),(0,r.kt)("h5",{id:"check-exp-parentheses"},"Check Exp: parentheses"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: (Exp) `( <Exp e> )`, Collector c){\n    c.fact(current, e);\n    collect(e, c);\n}\n")),(0,r.kt)("p",null,"The type of an expression enclosed by parentheses is the same as the same of the enclosed expression."),(0,r.kt)("p",null,"A final, essential, step is to collect constraints from the subpart ",(0,r.kt)("inlineCode",{parentName:"p"},"e"),"."),(0,r.kt)("h5",{id:"check-exp-addition"},"Check Exp: addition"),(0,r.kt)("p",null,"Addition of integers given an integer result and addition of Booleans gives a Boolean result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Exp) `<Exp e1> + <Exp e2>`, Collector c){\n     c.calculate("addition", current, [e1, e2],\n        AType (Solver s) {\n            switch(<s.getType(e1), s.getType(e2)>){\n                case <intType(), intType()>: return intType();\n                case <boolType(), boolType()>: return boolType();\n                default:\n                    s.report(error(current, "`+` not defined for %t and %t", e1, e2));\n            }\n        });\n      collect(e1, e2, c);\n}\n')),(0,r.kt)("p",null,"Checking addition is more complex since we need the type of sub expressions ",(0,r.kt)("inlineCode",{parentName:"p"},"e1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"e2")," in order to do our job. The\ntype of an arbitrary parse tree can be computed using"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"c.calculate(informative label, current, list of dependencies, AType(Solver s) { \u2026\u200b }"),"."),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"informative label")," is a label that can be used in error messages and log files.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"current")," is the parse tree for which we are computing a type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"list of dependencies")," is a list of other parse trees whose type is needed in the computation of the type of\n",(0,r.kt)("inlineCode",{parentName:"p"},"current"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"AType(Solver s) { \u2026\u200b }")," performs the type computation:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it is only called when the types of all dependencies are known.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it has a ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," as argument: a ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," manages the constraint solving process and is aware of all facts and\nsolved constraints so far and knows, for instance, about the existence of type information for some parse tree.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"it either returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"AType")," or reports an error."))))),(0,r.kt)("p",null,"The above code could be paraphrased as follows: ",(0,r.kt)("em",{parentName:"p"},"The type of ",(0,r.kt)("inlineCode",{parentName:"em"},"current")," can only be computed when the types of ",(0,r.kt)("inlineCode",{parentName:"em"},"e1")," and\n",(0,r.kt)("inlineCode",{parentName:"em"},"e2")," are known. When known, get their types (using ",(0,r.kt)("inlineCode",{parentName:"em"},"s.getType"),") and distinguish cases: two integer arguments give an\ninteger result type and two Boolean arguments a Boolean result type; otherwise report an error.")),(0,r.kt)("p",null,"A final, essential, step is to collect constraints from the subparts ",(0,r.kt)("inlineCode",{parentName:"p"},"e1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"e2"),"."),(0,r.kt)("h5",{id:"check-exp-multiplication"},"Check Exp: multiplication"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Exp) `<Exp e1> * <Exp e2>`, Collector c){\n     c.calculate("multiplication", current, [e1, e2],\n        AType (Solver s) {\n            switch(<s.getType(e1), s.getType(e2)>){\n                case <intType(), intType()>: return intType();\n                case <boolType(), boolType()>: return boolType();\n                default:\n                    s.report(error(current, "`*` not defined for %t and %t", e1, e2));\n            }\n        });\n      collect(e1, e2, c);\n}\n')),(0,r.kt)("p",null,"Checking multiplication follows exactly the same pattern as checking addition. Even in this simple example we see\nrepetition of code that could be factored out."),(0,r.kt)("h5",{id:"check-exp-conditional-expression"},"Check Exp: conditional expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Exp) `if <Exp cond> then <Exp e1> else <Exp e2>`, Collector c){\n    c.calculate("if Exp", current, [cond, e1, e2],\n        AType(Solver s){\n            s.requireEqual(cond, boolType(),\n                           error(cond, "Condition should be Boolean, found %t", cond));\n            s.requireEqual(e1, e2,\n                           error(current, "Equal types required, found %t and %t", e1, e2));\n            return s.getType(e1);\n        });\n    collect(cond, e1, e2, c);\n}\n')),(0,r.kt)("p",null,"Checking a conditional expression amounts to checking that the condition has type Boolean and that the then and else\nbranch have the same type (which also becomes the type of the conditional expression as a whole). In the above code we\nsee ",(0,r.kt)("inlineCode",{parentName:"p"},"s.requireEqual(arg1, arg2, message)"),". Here ",(0,r.kt)("em",{parentName:"p"},"arg1")," and ",(0,r.kt)("em",{parentName:"p"},"arg2")," may either be a subtree (in which case its type is\nused) or an ",(0,r.kt)("inlineCode",{parentName:"p"},"AType"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEqual")," requires that both types are equal or reports an error."),(0,r.kt)("p",null,"A final, essential, step is to collect constraints from the subparts ",(0,r.kt)("inlineCode",{parentName:"p"},"cond"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"e1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"e2"),"."),(0,r.kt)("h3",{id:"testing-the-calc-typechecker"},"Testing the Calc typechecker"),(0,r.kt)("h3",{id:"getting-started"},"Getting started"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"module lang::calc::Test\n\nextend lang::calc::Checker;\nextend analysis::typepal::TestFramework;    // TypePal test utilities\nimport ParseTree;                           // In order to parse tests\n")),(0,r.kt)("p",null,"We need three ingredients for testing:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"lang::calc::Checker"),", the Calc type checker we have just completed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"analysis::typepal::TestFramework"),", the TypePal test framework which enables test automation.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ParseTree")," that provides parsing functionality that is needed to parse Calc source text."))),(0,r.kt)("h3",{id:"manual-testing"},"Manual testing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"TModel calcTModelFromTree(Tree pt){\n    return collectAndSolve(pt);\n}\n")),(0,r.kt)("p",null,"Given a parse tree ",(0,r.kt)("inlineCode",{parentName:"p"},"pt")," for a Calc program, we apply ",(0,r.kt)("a",{parentName:"p",href:"#_collectandsolve"},"collectAndSolve")," to it. This creates a\nCollector, uses it to collect constraints from ",(0,r.kt)("inlineCode",{parentName:"p"},"pt")," and then creates a Solver to solve all constraints. The result is a\n",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"calcTModelFromTree")," will also be used during automated testing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"TModel calcTModelFromStr(str text){\n    pt = parse(#start[Calc], text).top;\n    return calcTModelFromTree(pt);\n}\n")),(0,r.kt)("p",null,"In order to obtain a parse tree, we need to parse it as shown above."),(0,r.kt)("p",null,"TModels contain much information but here we are only interested in the messages that have been generated during\nconstraint solving. They are contained in the ",(0,r.kt)("inlineCode",{parentName:"p"},"messsages")," field of a TModel."),(0,r.kt)("p",null,"With the above machinery in place we can perform some experiments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'calcTModelFromStr("var x = 3;"),messages')," gives no messages.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},'calcTModelFromStr("var x = 3+true;").messsages')," reports that addition of integer and Boolean is illegal."))),(0,r.kt)("h3",{id:"automated-testing"},"Automated testing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"bool calcTests() {\n     return runTests([|project://typepal-examples/src/lang/calc/tests.ttl|],\n                     #Calc, calcTModelFromTree);\n}\n")),(0,r.kt)("p",null,"TypePal\u2019s testing framework enables scripting of tests. Each script is written in TTL (TypePal Testing Language). Use\n",(0,r.kt)("inlineCode",{parentName:"p"},"runtests(list of TTL files, start non-terminal, function to create a TModel)")," to execute the scripts."),(0,r.kt)("p",null,"Here is a sample script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-TTL"},'test Ok1 [[ var x = 1; ]]\n\ntest Ok2 [[ var x = 1; var y = x + 2; ]]\n\ntest Undef1 [[ var x = y; ]]\nexpect { "Undefined variable `y`" }\n\ntest Add1 [[ var x = 1 + 2; ]]\n\ntest Add2 [[ var x = true + false; ]]\n\ntest Add3 [[ var x = 1 + true; ]]\nexpect { "`+` not defined for `int` and `bool`" }\n\ntest If1 [[ var x = if true then 1 else 2;\n            var y = x + 1;]]\ntest If2 [[ var x = if true then 1 else false; ]]\nexpect { "Equal types required, found `int` and `bool`" }\n\ntest If3 [[ var x = if 1 then 2 else 3; ]]\nexpect { "Condition should be Boolean, found `int`" }\n')),(0,r.kt)("p",null,"and here is the produced output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Test Ok1: true\nTest Ok2: true\nTest Undef1: true\nTest Add1: true\nTest Add2: true\nTest Add3: true\nTest If1: true\nTest If2: true\nTest If3: true\nTest summary: 9 tests executed, 9 succeeded, 0 failed\n")),(0,r.kt)("h2",{id:"concepts-and-definitions"},"Concepts and Definitions"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"The concepts and definitions used in TypePal."),(0,r.kt)("h3",{id:"identifier"},"Identifier"),(0,r.kt)("p",null,"The syntax of a source language may impose various restrictions on the identifiers that can occur in a program. They\namount to including or excluding specific characters for various occurrences of names in the program. One example is the\nrequirement in Java that class names start with an upper case letter. TypePal is agnostic of such conventions and\nrepresents each name as a string. ",(0,r.kt)("em",{parentName:"p"},"Qualified names")," are also supported and are represented by a list of strings."),(0,r.kt)("h3",{id:"tree"},"Tree"),(0,r.kt)("p",null,"The Rascal data type ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," (REF) is used to represent all parse trees that can be generated for any syntax described in\nRascal. ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," is also a super type of any syntactic construct that may occur in a parse tree. In TypePal we\ninterchangeably use ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," and the source area (a source location) associated with it to uniquely identify program\nparts, definitions, uses and scopes."),(0,r.kt)("h3",{id:"scope"},"Scope"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"scope")," is a region of a program that delimits where definitions of identifier are applicable. An identifier is\ndefined in the scope where it is defined and in all nested subscopes, unless one of these subscopes redefines that same\nidentifier. In that case, the inner definition applies inside that nested scope (and its subscopes). Scopes are\nidentified by the subtree of the parse tree that introduces them such as, for instance, a module, a function declaration\nor a block. Special rules may apply such as ",(0,r.kt)("em",{parentName:"p"},"define-before-use")," or ",(0,r.kt)("em",{parentName:"p"},"scopes-with-holes"),"."),(0,r.kt)("h3",{id:"scope-graph"},"Scope Graph"),(0,r.kt)("p",null,"The scope graph is one of the the oldest methods to describe the scope of names in a program. We use a version of scope\ngraphs as described by Kastens & Waite, ",(0,r.kt)("em",{parentName:"p"},"Name analysis for modern languages: a general solution"),", SP\\&E, 2017. This\nmodel uses text ranges in the source text (happily represented by Rascal\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"loc")," data type) to identify and define all\naspects of names. A scope graph provides lookup operations on names that take both syntactic nesting and semantic\nlinking (via ",(0,r.kt)("em",{parentName:"p"},"paths"),") into account, as well as the specific roles of identifiers and paths (described below)."),(0,r.kt)("h3",{id:"identifier-definition"},"Identifier definition"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"definition")," of an identifier is inside TypePal characterized by a ",(0,r.kt)("inlineCode",{parentName:"p"},"Define"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"alias Define  = tuple[loc scope, str id, IdRole idRole, loc defined, DefInfo defInfo];\n")),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scope")," is the scope in which the definition occurs;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"id")," is the text representation of the identifier;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRole")," is the role in which the identifier is defined, see ",(0,r.kt)("a",{parentName:"p",href:"#_identifier_role"},"Identifier Role"),";")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"defined")," is source code area of the definition;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"defInfo")," is any additional information associated with this definition, see ",(0,r.kt)("a",{parentName:"p",href:"#_definfo"},"DefInfo"),","))),(0,r.kt)("h3",{id:"identifier-use"},"Identifier Use"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"use")," of an identifier is characterized by a ",(0,r.kt)("inlineCode",{parentName:"p"},"Use"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Use\n    = use(str id, loc occ, loc scope, set[IdRole] idRoles)\n    | useq(list[str] ids, loc occ, loc scope, set[IdRole] idRoles, set[IdRole] qualifierRoles)\n    ;\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"use")," represents the use of a simple name and ",(0,r.kt)("inlineCode",{parentName:"p"},"useq")," that of a qualified name. In the latter case, a list of\nstrings is given; the last string is a simple name in given ",(0,r.kt)("inlineCode",{parentName:"p"},"idRoles")," and the preceeding strings are its qualifiers in\n",(0,r.kt)("inlineCode",{parentName:"p"},"qualifierRoles"),"."),(0,r.kt)("h3",{id:"path"},"Path"),(0,r.kt)("p",null,"TypePal is based on scope graphs that are not only based on syntactic containment of scopes but can also express\nsemantic connections between parse trees. While scopes are strictly determined by the hierarchical structure of a\nprogram (i.e., its parse tree), ",(0,r.kt)("em",{parentName:"p"},"paths")," provide an escape from this restriction and define a semantic connection between\nsyntactic entities that are not hierarchically related and may even be part of different syntax trees. Connections\nbetween syntactic entities are paths labelled with user-defined roles. Paths are represented by the Rascal datatype\n",(0,r.kt)("inlineCode",{parentName:"p"},"PathRole"),". An example is the import of a module ",(0,r.kt)("em",{parentName:"p"},"M")," into another module ",(0,r.kt)("em",{parentName:"p"},"N")," that makes the entities in ",(0,r.kt)("em",{parentName:"p"},"M")," known inside\n",(0,r.kt)("em",{parentName:"p"},"N"),". Here is an example of a path role to mark an import path between two parse trees."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data PathRole\n    = importPath()\n    ;\n")),(0,r.kt)("p",null,"Paths are, amongst others, used in the resolution of qualified names."),(0,r.kt)("h3",{id:"name-resolution"},"Name Resolution"),(0,r.kt)("p",null,"Name resolution is based on the principle: ",(0,r.kt)("em",{parentName:"p"},"syntactic resolution first, semantic resolution second"),". This means that we\nfirst search for a definition in the current parse tree and only when that fails we follow semantic path to other trees\n(either in the current tree or in other trees):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"First the current scope in which the name is used is searched for a definition.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If this fails surrounding scopes are searched.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If this fails semantic paths in the same parse tree or to other parse trees are searched, such as, for instance,\nprovided by an import statement."))),(0,r.kt)("p",null,"This is illustrated below, where a name occurrence ",(0,r.kt)("em",{parentName:"p"},"O")," can be resolved to definitions ",(0,r.kt)("em",{parentName:"p"},"D1")," (syntactic resolution), ",(0,r.kt)("em",{parentName:"p"},"D2"),"\n(semantic resolution) and/or ",(0,r.kt)("em",{parentName:"p"},"D3")," (semantic resolution)."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"400",src:a(7943).Z,width:"471",height:"468"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Important")),(0,r.kt)("p",{parentName:"blockquote"},"Name resolution need not have a unique solution. Therefore the author of a TypePal-based type checker can provide\nfunctions to (a) filter valid solutions; (b) determine which identifiers may be overloaded.")),(0,r.kt)("h3",{id:"role"},"Role"),(0,r.kt)("p",null,"Identifiers, scopes and path can play different ",(0,r.kt)("em",{parentName:"p"},"roles")," that determine how they will be handled. They are represented by\nvarious Rascal datatypes that can be extended by the author of a typechecker."),(0,r.kt)("h3",{id:"identifier-role"},"Identifier Role"),(0,r.kt)("p",null,"Identifier roles are modelled by the data type ",(0,r.kt)("inlineCode",{parentName:"p"},"IdRole"),". Here is an example where roles are introduced for constants,\nvariables, formal parameters and functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data IdRole\n    = constantId()\n    | variableId()\n    | formalId()\n    | functionId()\n    ;\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("em",{parentName:"p"},"defining")," an identifier, the specific role of that identifier has to be given, e.g. as ",(0,r.kt)("inlineCode",{parentName:"p"},"constantId()"),". When\n",(0,r.kt)("em",{parentName:"p"},"using")," an identifier, the set of acceptables roles has to be given. For instance, an identifier used in an expression\nmay accept the roles ",(0,r.kt)("inlineCode",{parentName:"p"},"{ constantId(), variableId(), formalId() }"),"."),(0,r.kt)("h3",{id:"scope-role"},"Scope Role"),(0,r.kt)("p",null,"Scope roles are modelled by the data type ",(0,r.kt)("inlineCode",{parentName:"p"},"ScopeRole")," and are used to distinguish different kinds of scopes. Later (REF)\nwe will see that this can be used, for instance, to search for the innermost scope with a specific role, say the\ninnermost function scope. Here is an example that introduces scopes for functions and loops:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data ScopeRole\n    = functionScope()\n    | loopScope()\n    ;\n")),(0,r.kt)("h3",{id:"path-role"},"Path Role"),(0,r.kt)("p",null,"Path roles are modelled by the data type ",(0,r.kt)("inlineCode",{parentName:"p"},"PathRole"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data PathRole\n    = importPath()\n    | extendPath()\n    ;\n")),(0,r.kt)("h3",{id:"types"},"Types"),(0,r.kt)("p",null,"The type to be associated with names varies widely for different programming languages and has to be provided by the\ntypechecker author. TypePal provides the data type ",(0,r.kt)("inlineCode",{parentName:"p"},"AType")," that provides already some built-in constructors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data AType\n   = tvar(loc tname)                                    \n   | atypeList(list[AType] atypes)                      \n   | overloadedAType(rel[loc, IdRole, AType] overloads) \n   | lazyLub(list[AType] atypes)                        \n   ;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"tvar")," represents a type variable (used for type inference) and is only used internally.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"atypeList")," represents a list of ","`","AType","`","s and is used both internally in TypePal but can also be used in\ntypechecker definitions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"overloadedAType")," represents overloaded types.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"lazyLub")," represents a lazily computed LUB of a list of types."))),(0,r.kt)("p",null,"AType that has to be extended with language-specific types."),(0,r.kt)("p",null,"The typechecker author also has to provide a function to convert ",(0,r.kt)("inlineCode",{parentName:"p"},"AType")," to string (it is used create readable error\nmessages):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"str prettyAType(AType atype);\n")),(0,r.kt)("h3",{id:"definfo"},"DefInfo"),(0,r.kt)("p",null,"When defining a name, we usually want to associate information with it such as the type of the defined name. TypePal\nprovides the data type ",(0,r.kt)("inlineCode",{parentName:"p"},"DefInfo")," for this purpose:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data DefInfo\n    = noDefInfo()                                                                           \n    | defType(value contrib)                                                                \n    | defTypeCall(list[loc] dependsOn, AType(Solver s) getAType)                            \n    | defTypeLub(list[loc] dependsOn, list[loc] defines, list[AType(Solver s)] getATypes)   \n    ;\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"No information associated with this definition.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Explicitly given AType contribution associated with this definition. ",(0,r.kt)("inlineCode",{parentName:"p"},"contrib")," can either be an ",(0,r.kt)("inlineCode",{parentName:"p"},"AType"),", or a\n",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),". In the latter case, the type of that tree is used (when it becomes available) for the current definition.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Type of this definition depends on the type of the entities given in ",(0,r.kt)("inlineCode",{parentName:"p"},"dependsOn"),", when those are known, ",(0,r.kt)("inlineCode",{parentName:"p"},"getAType"),"\ncan construct the type of this definition. ",(0,r.kt)("inlineCode",{parentName:"p"},"getAType")," will only be called by TypePal during constraint solving.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Refine a set of definitions by taking their LUB, mostly used for local type inference."))),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Solver"},"Solver")," argument of ",(0,r.kt)("inlineCode",{parentName:"p"},"getAType")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getATypes")," is the current constraint solver being used."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Warning")),(0,r.kt)("p",{parentName:"blockquote"},"noDefInfo may be removed.")),(0,r.kt)("h2",{id:"architecture-of-typepal"},"Architecture of TypePal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Architectural overview of TypePal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Type checking using TypePal proceeds in the following stages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Parse")," the program to be analyzed using its syntax definition, the result is a parse tree;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Collect")," constraints (facts, calculators, and requirements) from the parsed program and build an initial ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),"\nusing these collected constraints;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Solve")," the constraints, the result is a validated and further enriched ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),". This amounts to executing\ncalculators and requirements when the types on which they depend become available. This also involves resolving the\nsemantic links between program parts as introduced by, e.g., import statements."))),(0,r.kt)("p",null,"This approach is very flexible, since each of the stages can be called separately, enabeling a pipeline with\nuser-defined model transformations inbetween."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"900",src:a(2866).Z,width:"1105",height:"788"})),(0,r.kt)("p",null,"This whole process starts with a syntax for the language we want to analyze (let\u2019s call that language ",(0,r.kt)("em",{parentName:"p"},"L")," for now). The\n",(0,r.kt)("em",{parentName:"p"},"L")," syntax is used to parse the ",(0,r.kt)("em",{parentName:"p"},"L")," program we want to type check. The result is a parse tree."),(0,r.kt)("p",null,"Collecting constraints from the resulting parse tree is based on the builder pattern: first a new\n",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Collector"},"Collector")," is created (using ",(0,r.kt)("inlineCode",{parentName:"p"},"newCollector"),") and that enables the author of the type checker to add\nfacts, requirements and calculators to the ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel")," depending on the specific input program. The Collector calls\nuser-defined ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," functions for each language construct. This collection process is strictly ",(0,r.kt)("em",{parentName:"p"},"local")," and based on\nthe nested structure of the parse tree and the result is an initial ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),"."),(0,r.kt)("p",null,"After the Collector phase, a ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel")," is available whose constraints can be solved (or not). This is done by creating a\nnew ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Solver"},"Solver")," (using ",(0,r.kt)("inlineCode",{parentName:"p"},"newSolver"),") and running it on the given ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),"."),(0,r.kt)("p",null,"TypePal can be configured using a ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."),(0,r.kt)("h2",{id:"reporting"},"Reporting"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"How to format and report errors, warnings and info messages."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"Reporting may be done both in the Collector and the Solver. It uses values of the datatype ",(0,r.kt)("inlineCode",{parentName:"p"},"FailMessage")," that can be\ncreated as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"FailMessage error(value src, str msg, value args...);\nFailMessage warning(value src, str msg, value args...);\nFailMessage info(value src, str msg, value args...);\n")),(0,r.kt)("p",null,"Here,"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"src")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"loc")," that is the subject of the report.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"msg")," is an informative string to be printed. It may contain ",(0,r.kt)("em",{parentName:"p"},"insertion directives"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"args")," are zero or more values to be inserted in the insertion directives in ",(0,r.kt)("inlineCode",{parentName:"p"},"msg"),"."))),(0,r.kt)("p",null,"The following insertion directives are supported:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"%t"),": insert the ",(0,r.kt)("em",{parentName:"p"},"type")," of the next element of ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"%v"),": insert the ",(0,r.kt)("em",{parentName:"p"},"value")," of the next element of ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"%q"),": quote and insert the ",(0,r.kt)("em",{parentName:"p"},"type")," or ",(0,r.kt)("em",{parentName:"p"},"value")," of the next element of ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"%%"),": insert the character ",(0,r.kt)("inlineCode",{parentName:"p"},"%"),"."))),(0,r.kt)("h2",{id:"collector"},"Collector"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," collects constraints from source code and produces an initial ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," is a statefull object that provides all the functions described below to access and change its internal\nstate. The global services provided by a ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Register facts, calculators, and requirements as collected from the source program.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Maintain a global (key,value) store to store global information relevant for the collection process. Typical\nexamples are:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Configuration information.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The files that have been imported.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Manage scopes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Maintain a single value per scope. This enables decoupling the collection of information from separate but related\nlanguage constructs. Typical examples are:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"While collecting information from a function declaration: create a new function scope and associate the required\nreturn type with it so that return statements in the function body can check that (a) they occur inside a\nfunction; (b) that the type of their returned value is compatible with the required return type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"While collecting information from an optionally labelled loop statement: create a new loop scope and associate\nthe label with it so that break/continue statements can check that: (a) they occur inside a loop statement; (b)\nwhich loop statement they should (dis)continue.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Reporting."))),(0,r.kt)("p",null,"The functions provided by a ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," are summarized below:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"800",src:a(4633).Z,width:"562",height:"573"})),(0,r.kt)("p",null,"Three dozen functions are available that fall into the following categories:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Lifecycle of Collector"),": create a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector"),", use it to ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," information from a source program, and\nproduce a TModel.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Configuration"),": retrieve or modify configuration settings.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Scoping"),": enter or leave a scope, ask for current scope.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Scope Info"),": add information to the current scope or retrieve that information.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Nested Info"),": maintain nested information during collection; this is only available during collection.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Composition"),": add another TModel to the current one.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Reporting"),": report errors, warnings and info messages.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Add Path"),": add paths to the scope graph.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Define"),": define identifiers in various ways.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Use"),": use identifiers in various ways.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Inference"),": create new type variables for type inference.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Facts"),": establish facts.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Calculate"),": define calculators.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Require"),": define requirements."))),(0,r.kt)("p",null,"Technically, ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," is a datatype with a single constructur and a number of functions as fields, For instance,\ngiven a ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," named ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"define")," function amounts to: ",(0,r.kt)("inlineCode",{parentName:"p"},"c.define(the-arguments-of-define)"),". All\nCollector functions are prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"/* Collector field */")," to emphasize that they are a field of the Collector\ndatatype."),(0,r.kt)("h3",{id:"lifecycle-of-collector"},"LifeCycle of Collector"),(0,r.kt)("p",null,"A new ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector")," is created using the function ",(0,r.kt)("inlineCode",{parentName:"p"},"newCollector"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Collector newCollector(str modelName, Tree pt, TypePalConfig config = tconfig());\n")),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"modelName")," is the name of the TModel to be created (used for logging);")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"pt")," is the parse tree of the source program to be type checked;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"config")," is a ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."))),(0,r.kt)("p",null,"Once a Collector has been created, the user-defined ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," function is invoked with the current parse tree of a\nsource program and the Collector as arguments. The ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," function is applied recursively until all information has\nbeen collected from the source program."),(0,r.kt)("p",null,"Finally, ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," creates the desired ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel")," that will be used by the ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Solver"},"Solver"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ TModel () run;\n")),(0,r.kt)("p",null,"A typical scenario is (for a given a parse tree ",(0,r.kt)("inlineCode",{parentName:"p"},"pt")," of the program to be checked):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'c = newCollector("my_model", pt);   // create Collector\ncollect(pt, c);                     // collect constraints\nmodel = c.run();                    // create initial TModel to be handled by the Solver\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," function has to be supplied by the author of the type checker and looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(LanguageConstruct lc, Collector c){ ... }\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"lc")," is a syntactic type from the language under consideration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"c")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Collector"),"."))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Important")),(0,r.kt)("p",{parentName:"blockquote"},"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," function is responsible for collecting constraints from its subtrees.")),(0,r.kt)("h3",{id:"configuration"},"Configuration"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration")," can be retrieved or adjusted by the following two functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ TypePalConfig () getConfig;\n/* Collector field */ void (TypePalConfig cfg) setConfig;\n")),(0,r.kt)("p",null,"The former returns the current TypePal configuration, the latter sets the current configuration to a new configuration."),(0,r.kt)("h3",{id:"scoping"},"Scoping"),(0,r.kt)("p",null,"Scope management amounts to entering a new scope, leave the current scope and retrieving the current scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree inner) enterScope;\n/* Collector field */ void (Tree inner) leaveScope;\n/* Collector field */ loc () getScope,\n")),(0,r.kt)("p",null,"In order to check consistency, ",(0,r.kt)("inlineCode",{parentName:"p"},"leaveScope")," has the inner scope that it is supposed to be leaving as argument."),(0,r.kt)("p",null,"Here is an example how the ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," expression in ",(0,r.kt)("a",{parentName:"p",href:"#_fun"},"Fun")," handles subscopes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Expression) `let <Id name> : <Type tp> = <Expression exp1> in <Expression exp2> end`, Collector c) {\n     c.enterScope(current);\n         c.define("<name>", variableId(), name, defType(tp));\n         c.calculate("let", current, [exp2], AType(Solver s) { return s.getType(exp2); } );\n         collect(tp, exp1, exp2, c);\n     c.leaveScope(current);\n}\n')),(0,r.kt)("h3",{id:"scope-info"},"Scope Info"),(0,r.kt)("p",null,"It is possible to associate auxiliary information with each scope. This enables the downward propagation of information\nduring the topdown traversal of the source program by ",(0,r.kt)("inlineCode",{parentName:"p"},"collect"),". Typical use cases are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"recording the return type of a function declaration and checking that all return statements in the body of that\nfunction have a type that is compatible with the declared return type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"recording the label of a loop statement for the benefit of nested break or continue statements."))),(0,r.kt)("p",null,"Scopes are identified by their source location and ",(0,r.kt)("inlineCode",{parentName:"p"},"ScopeRole"),": a user-defined data type that distinsguishes possible\nroles such as ",(0,r.kt)("inlineCode",{parentName:"p"},"functionScope()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"labelScope()"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"setScopeInfo")," sets the information for a scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (loc scope, ScopeRole scopeRole, value info) setScopeInfo;\n")),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scope")," is the scope for which information is to be set.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scopeRole")," is the role of that scope.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"info")," is the associated information."))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getScopeInfo")," retrieves associated scope information:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ lrel[loc scope, value scopeInfo]  (ScopeRole scopeRole) getScopeInfo;\n")),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"scopeRole")," is the role of the scope we are looking for.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getScopeInfo")," returns a list relation containing scope/scopeInfo pairs (ordered from innermost to outermost scope)."),(0,r.kt)("p",null,"Let\u2019s illustrate ScopeInfo with a stripped down version of how the Rascal type checker handles ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"break"),"\nstatements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'data LoopInfo = loopInfo(str name); \n\nvoid collect(current: (Statement) `<Label label> while( <{Expression ","}+ conditions> ) <Statement body>`,  Collector c){\n    c.enterScope(current);\n        ...\n        loopName = "<label.name>";\n        c.setScopeInfo(c.getScope(), loopScope(), loopInfo(loopName)); \n        ...\n    c.leaveScope(current);\n}\n\nvoid collect(current:(Statement) `break <Target target>;`, Collector c){\n    ...\n    loopName = "<target.name>"\n    for(<scope, scopeInfo> <- c.getScopeInfo(loopScope())){ \n        if(loopInfo(loopName1) := scopeInfo){\n            if(loopName == "" || loopName == loopName1){\n                collect(target, c);\n                return;\n             }\n        } else {\n            throw rascalCheckerInternalError(getLoc(current), "Inconsistent info from loop scope: <scopeInfo>");\n        }\n    }\n    c.report(error(current, "Break outside a while/do/for statement"));\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Introduces a data type to represent loop information.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When handling a while statement, the current scope is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"loopScope")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"loopInfo")," is associated with it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When handling a ",(0,r.kt)("inlineCode",{parentName:"p"},"break")," statement, we get all available ScopeInfo for loopScopes (innermost first) and check the\nassociated loopInfo."))),(0,r.kt)("h3",{id:"nested-info"},"Nested Info"),(0,r.kt)("p",null,'An arbitrary number of push down stacks can be maintained during the topdown traversal of the source code that is being\ntype checked. A use case is recording that a certain syntax type is encountered and make children aware of this, e.g.\n"we are inside a parameter list".'),(0,r.kt)("p",null,"Each stack has a string name (",(0,r.kt)("inlineCode",{parentName:"p"},"key"),") and is created on demand."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (str key, value val) push\n/* Collector field */ value (str key) pop,\n/* Collector field */ value (str key) top,\n/* Collector field */ list[value] (str key) getStack,\n/* Collector field */ void (str key) clearStack,\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"push"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"pop"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"top")," perform standard stack operations. ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," creates a stack when needed, while ",(0,r.kt)("inlineCode",{parentName:"p"},"top")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pop"),"\nrequire the existence of the named stack. ",(0,r.kt)("inlineCode",{parentName:"p"},"getStack")," returns all values in the named stack, while ",(0,r.kt)("inlineCode",{parentName:"p"},"clearStack")," resets it\nto empty."),(0,r.kt)("h3",{id:"composition"},"Composition"),(0,r.kt)("p",null,"TModels can be composed by adding the information from one TModel to the other. A use case is module compoisition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (TModel tm) addTModel;\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"addTModel")," adds the information in ",(0,r.kt)("inlineCode",{parentName:"p"},"tm")," to the current Collector."),(0,r.kt)("h3",{id:"reporting-1"},"Reporting"),(0,r.kt)("p",null,"One or more reports can be added by ",(0,r.kt)("inlineCode",{parentName:"p"},"report")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reports"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (FailMessage fmsg) report;\n/* Collector field */ void (list[FailMessage] fmgs) reports;\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Reporting"},"Reporting")," for a description of ",(0,r.kt)("inlineCode",{parentName:"p"},"FailMessage"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Important")),(0,r.kt)("p",{parentName:"blockquote"},"If one of the messages is ",(0,r.kt)("inlineCode",{parentName:"p"},"error")," the execution of the current calculator or requirement is immediately terminated.")),(0,r.kt)("h3",{id:"add-path"},"Add Path"),(0,r.kt)("p",null,"TypePal is based on nested scopes and path between scopes. The former represent textual nesting as present in block\nstructure and function scopes. The latter represent non-local semantic links between program parts as present in import\nstatements between modules or Pascal\u2019s with statement. The following functions add to the scope graph a path from the\ncurrent scope to another scope."),(0,r.kt)("h3",{id:"add-a-path-to-a-definition"},"Add a path to a definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree occ, set[IdRole] idRoles, PathRole pathRole) addPathToDef;\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"addPathToDef")," is typically used to create an ",(0,r.kt)("em",{parentName:"p"},"import")," or ",(0,r.kt)("em",{parentName:"p"},"extend")," path between program parts. ",(0,r.kt)("inlineCode",{parentName:"p"},"occ")," is an occurence of\na name that should be defined elsewhere in one of the given roles. The effect is to add a ",(0,r.kt)("inlineCode",{parentName:"p"},"pathRole")," path between the\ncurrent scope and the definition."),(0,r.kt)("p",null,"Here is an example taken from ",(0,r.kt)("a",{parentName:"p",href:"#_modfun"},"ModFun"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: (ImportDecl) `import <ModId mid> ;`, Collector c){\n     c.addPathToDef(mid, {moduleId()}, importPath());\n}\n")),(0,r.kt)("h3",{id:"add-a-path-to-a-qualified-definition"},"Add a path to a qualified definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (list[str] ids, Tree occ, set[IdRole] idRoles, set[IdRole] qualifierRoles, PathRole pathRole) addPathToQualifiedDef;\n")),(0,r.kt)("p",null,"Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"addPathToDef")," for the occurrence of a qualified names rather than a simple name."),(0,r.kt)("h3",{id:"add-a-path-to-a-type"},"Add a path to a type"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree occ, PathRole pathRole) addPathToType\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"occ")," is a parse tree with has a certain type. The effect is to add a ",(0,r.kt)("inlineCode",{parentName:"p"},"pathRole")," path between the current scope and the\ndefinition of that type."),(0,r.kt)("p",null,"A prime example is type checking of ",(0,r.kt)("a",{parentName:"p",href:"#_pascal"},"Pascal"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"with")," statement which ",(0,r.kt)("em",{parentName:"p"},"opens")," the definition of a record type\nand makes all defined fields available in the body of the ",(0,r.kt)("inlineCode",{parentName:"p"},"with")," statement. Here we create a ",(0,r.kt)("inlineCode",{parentName:"p"},"withPath")," between the\nscope of the with statement and all definitions of the record types of the given record variables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (WithStatement) `with <{RecordVariable ","}+ recordVars> do <Statement withStat>`, Collector c){\n    c.enterScope(current);\n        for(rv <- recordVars){\n            c.addPathToType(rv, withPath());\n        }\n        collect(recordVars, withStat, c);\n    c.leaveScope(current);\n}\n')),(0,r.kt)("h3",{id:"define"},"Define"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"define")," adds the definition of a name in the ",(0,r.kt)("em",{parentName:"p"},"current")," scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */  void (str id, IdRole idRole, value def, DefInfo info) define;\n")),(0,r.kt)("p",null,"where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"id")," is the textual appearance of the name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRole")," is the role played by the name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"def")," is the part of the parse tree that corresponds to the definition of the name.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"info")," is the definition information ",(0,r.kt)("a",{parentName:"p",href:"#_definfo"},"DefInfo")," to be associated with this definition."))),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"defineInScope")," adds the definition of a name in a ",(0,r.kt)("em",{parentName:"p"},"given")," scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */  void (value scope, str id, IdRole idRole, value def, DefInfo info) defineInScope\n")),(0,r.kt)("h3",{id:"use"},"Use"),(0,r.kt)("h3",{id:"use-an-unqualified-name"},"Use an unqualified name"),(0,r.kt)("p",null,"There are three functions to describe the occurrence of a name in a parse tree as a use. The most elementary use of a\nname is described by:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree occ, set[IdRole] idRoles) use,\n")),(0,r.kt)("p",null,"The parse tree ",(0,r.kt)("inlineCode",{parentName:"p"},"occ")," is a use to be resolved in the current scope in one of the given roles ",(0,r.kt)("inlineCode",{parentName:"p"},"idRoles"),". The use of a\nvariable in an expression is typically modelled with this use function."),(0,r.kt)("p",null,"Here is an example from ",(0,r.kt)("a",{parentName:"p",href:"#_calc"},"Calc"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: (Exp) `<Id name>`, Collector c){\n    c.use(name, {variableId()});\n}\n")),(0,r.kt)("h3",{id:"use-a-qualified-name"},"Use a qualified name"),(0,r.kt)("p",null,"Next we consider the use of qualified names, i.e., a list of identifiers that will be resolved from left to right. We\nwill call these identifiers (except the last one) ",(0,r.kt)("em",{parentName:"p"},"qualifiers")," and the last one the ",(0,r.kt)("em",{parentName:"p"},"qualified identifier"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (list[str] ids, Tree occ, set[IdRole] idRoles, set[IdRole] qualifierRoles) useQualified;\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"ids")," is the list of strings that form the qualified name, ",(0,r.kt)("inlineCode",{parentName:"p"},"occ")," is the actual occurrence, and there are two sets\nof roles: ",(0,r.kt)("inlineCode",{parentName:"p"},"idRoles")," are the possible roles for the qualified identifier itself and ","`","qualifierRoles are the possible\nroles for the qualifiers."),(0,r.kt)("h3",{id:"use-a-name-via-another-type"},"Use a name via another type"),(0,r.kt)("p",null,"Many languages support ",(0,r.kt)("em",{parentName:"p"},"named types")," and names that can be defined inside such a named type. Examples are field names in\nrecords or method names in classes. ",(0,r.kt)("inlineCode",{parentName:"p"},"useViaType")," handles the use of names defined in a named type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree container, Tree selector, set[IdRole] idRolesSel) useViaType\n")),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"container"),": has a named type as type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector"),": is the name to be selected from that named type.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRolesSel"),": are the IdRoles allowed for the selector."))),(0,r.kt)("p",null,"Here is an example of field selection from a record in ",(0,r.kt)("a",{parentName:"p",href:"#_struct"},"Struct"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current:(Expression)`<Expression lhs> . <Id fieldName>`, Collector c) {\n    c.useViaType(lhs, fieldName, {fieldId()}); \n    c.fact(current, fieldName); \n    collect(lhs, c);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Determine the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"lhs"),", say ",(0,r.kt)("em",{parentName:"p"},"T"),". Now look for a definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldName")," (as ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldId"),") in the definition of\n",(0,r.kt)("em",{parentName:"p"},"T"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The type of the whole expressions becomes the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldId"),"."))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useViaType")," can be configured with ",(0,r.kt)("a",{parentName:"p",href:"#_gettypenamesandrole"},"getTypeNamesAndRole")," and\n",(0,r.kt)("a",{parentName:"p",href:"#_gettypeinnamelesstype"},"getTypeInNamelessType")," that determine the precise mapping between a named or unnamed type and\nits fields."),(0,r.kt)("h3",{id:"uselub"},"UseLub"),(0,r.kt)("p",null,"In some languages (think Rascal) local type inference and subtyping are needed to determine the type of variables: when\nno explicit definition is present, the type of these variables is inferred from their use and the least-upper-bound\n(LUB) of all the uses of a variable is taken as its type. ",(0,r.kt)("inlineCode",{parentName:"p"},"useLub")," marks variable uses for which this regime has to be\napplied:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree occ, set[IdRole] idRoles) useLub\n")),(0,r.kt)("p",null,"See the Rascal type checker for examples."),(0,r.kt)("h3",{id:"inference"},"Inference"),(0,r.kt)("p",null,"ATypes may contain type variables and new type variables can be created using ",(0,r.kt)("inlineCode",{parentName:"p"},"newTypeVar"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ AType (value src) newTypeVar;\n")),(0,r.kt)("p",null,"Type variables can be bound via unification."),(0,r.kt)("p",null,"Here is an example of a call expression taken from ",(0,r.kt)("a",{parentName:"p",href:"#_untypedfun"},"UntypedFun"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Expression) `<Expression exp1>(<Expression exp2>)`, Collector c) {\n     tau1 = c.newTypeVar(exp1);\n     tau2 = c.newTypeVar(exp2);\n\n     c.calculateEager("application", current, [exp1, exp2],\n        AType (Solver s) {\n              s.requireUnify(functionType(tau1, tau2), exp1, error(exp1, "Function type expected, found %t", exp1));\n              s.requireUnify(tau1, exp2, error(exp2, "Incorrect type of actual parameter"));\n              return tau2;\n            });\n      collect(exp1, exp2, c);\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"calculate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," are only evaluated when all their dependencies are available and they are fully instantiated,\ni.e., ",(0,r.kt)("strong",{parentName:"p"},"do not contain type variables"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"calculateEager")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEager")," are also only evaluated when all their dependencies are available ",(0,r.kt)("strong",{parentName:"p"},"but those may\ncontain type variables"),"."),(0,r.kt)("p",null,"The bindings that are accumulated during ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateEager")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEager")," are effectuated upon successfull completion\nof that ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateEager")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEager"),"."),(0,r.kt)("h3",{id:"fact"},"Fact"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"fact")," registers known type information for a program fragment ",(0,r.kt)("inlineCode",{parentName:"p"},"src"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (Tree src, value atype) fact;\n")),(0,r.kt)("p",null,"where ",(0,r.kt)("inlineCode",{parentName:"p"},"atype")," can be either an ",(0,r.kt)("inlineCode",{parentName:"p"},"AType")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),". In the latter case the type of that Tree is used when available."),(0,r.kt)("p",null,"Here are two examples from ",(0,r.kt)("a",{parentName:"p",href:"#_calc"},"Calc"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"void collect(current: (Exp) `<Integer integer>`, Collector c){\n    c.fact(current, intType()); \n}\n\nvoid collect(current: (Exp) `( <Exp e> )`, Collector c){\n    c.fact(current, e);        \n    collect(e, c);\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Registers the fact that the current expression has type ",(0,r.kt)("inlineCode",{parentName:"p"},"intType"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Registers the fact that the current expression has the same type as the embedded expression ",(0,r.kt)("inlineCode",{parentName:"p"},"e"),"."))),(0,r.kt)("h3",{id:"calculate"},"Calculate"),(0,r.kt)("p",null,"A calculator computes the type of a subtree ",(0,r.kt)("inlineCode",{parentName:"p"},"src")," by way of an AType-returning function ",(0,r.kt)("inlineCode",{parentName:"p"},"calculator"),". A list of\ndependencies is given whose types have to be known before this calculator can be computed. There are two versions: for\n",(0,r.kt)("inlineCode",{parentName:"p"},"calculate")," all dependencies should be fully resolved and instantiated, while ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateEager")," can also handle\ndependencies that still contain type variables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (str name, Tree src, list[value] dependencies, AType(Solver s) calculator) calculate;\n/* Collector field */ void (str name, Tree src, list[value] dependencies, AType(Solver s) calculator) calculateEager;\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-PocketCalculator"},"A Calculator Language")," and ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Examples"},"Examples of Typecheckers")," for examples of\ncalculator definitions."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#_inference"},"Inference")," for details about type variables."),(0,r.kt)("h3",{id:"require"},"Require"),(0,r.kt)("p",null,"A requirement is a predicate regarding the type or properties of a source tree fragment ",(0,r.kt)("inlineCode",{parentName:"p"},"src"),". There are two versions:\nfor ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," all dependencies should be fully resolved and instantiated, while ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEager")," can also handle\ndependencies that still contain type variables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (str name, Tree src, list[value] dependencies, void(Solver s) pred) require;\n/* Collector field */ void (str name, Tree src, list[value] dependencies, void(Solver s) pred) requireEager;\n")),(0,r.kt)("p",null,"where"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"name")," is the name of the requirement (for reporting purposes).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," is a list of dependencies whose types have to be known before this requirement can be computed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"pred")," is a function that actually checks the requirement; when it is violated this will be reported via its Solver\nargument."))),(0,r.kt)("p",null,"More specific requiremens can be expressed for checking that two subtrees or types are equal, comparable, that the one\nis a subtype of the other, or that they can be unified:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Collector field */ void (value l, value r, FailMessage fmsg) requireEqual;\n/* Collector field */ void (value l, value r, FailMessage fmsg) requireComparable;\n/* Collector field */ void (value l, value r, FailMessage fmsg) requireSubType;\n/* Collector field */ void (value l, value r, FailMessage fmsg) requireUnify;\n")),(0,r.kt)("p",null,"The arguments ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," should either be an AType or a subtree whose type is known."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-PocketCalculator"},"A Calculator Language")," and ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Examples"},"Examples of Typecheckers")," for examples of\nrequirement definitions. See ",(0,r.kt)("a",{parentName:"p",href:"#_inference"},"Inference")," for details about type variables."),(0,r.kt)("h2",{id:"solver"},"Solver"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," tries to solve the constraints in a ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel"),"; unsolved constraints produce error messages"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"The purpose of a Solver is to solve the constraints that have been gathered by the ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Collector"},"Collector")," and\nto produce a TModel. The functions provided by a Solver are summarized below:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"800",src:a(3670).Z,width:"605",height:"448"})),(0,r.kt)("p",null,"Two dozen functions (some very similar to the ones provided for ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Collector"},"Collector"),") are available that fall\ninto the following categories:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Lifecycle of Solver"),": create a new Solver and use it to solve the constraints in a given TModel.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Fact"),": establish facts.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Calculate"),": calculate types.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Require"),": check requirements.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Types"),": retrieve the type of a program fragment in various ways, if that type is available.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Inference"),": create new type variables for type inference.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Reporting"),": report errors, warnings and info messages.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Global Info"),": access global information such as the current ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),",\navailable type facts, and the global store (EXPLAIN)."))),(0,r.kt)("p",null,"In identical style as used for ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Collector"},"Collector"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," is a datatype with a single constructur and\nwith a number of functions as fields, For instance, given a ",(0,r.kt)("inlineCode",{parentName:"p"},"Solver")," named ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),", calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"getType")," function amounts\nto: ",(0,r.kt)("inlineCode",{parentName:"p"},"s.getType(argument-of-getType)"),". All Solver functions are prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"/* Solver field */")," to emphasize that they\nare a field of the Solver datatype."),(0,r.kt)("p",null,"The result of the Solver is an enriched ",(0,r.kt)("inlineCode",{parentName:"p"},"TModel")," that contains, amongst others, messages regarding violated requirements\nor types that could not be computed. It can also be used to generate other usefull information about the program such as\na use-def relation and the used vocabulary (used for name completion)."),(0,r.kt)("h3",{id:"lifecycle-of-solver"},"Lifecycle of Solver"),(0,r.kt)("p",null,"Once, an initial TModel has been created by a ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Collector"},"Collector"),", a Solver takes over to solve constraints\nand produce a final TModel. A new Solver can be created by ",(0,r.kt)("inlineCode",{parentName:"p"},"newSolver")," that comes in two flavours:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Solver newSolver(Tree pt, TModel tm)\nSolver newSolver(map[str,Tree] namedTrees, TModel tm){\n")),(0,r.kt)("p",null,"The former takes a parse tree and an initial TModel and is intended to solve the constraints for a single parse tree.\nThe latter takes a map of named parse trees and an initial TModel and can handle the situation of multiple trees with\nmutual dependencies."),(0,r.kt)("p",null,"Finally, ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," creates the final TModel by solving the constraints in the initial TModel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ TModel () run\n")),(0,r.kt)("p",null,"A complete type checking scenario (for a given a parse tree ",(0,r.kt)("inlineCode",{parentName:"p"},"pt")," of the program to be checked) is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'c = newCollector("my_model", pt);  // create Collector\ncollect(pt, c);                    // collect constraints\ninitial_model = c.run();           // create initial TModel\ns = newSolver(pt, initial_model);  // create Solver\nfinal_model = s.run();             // solve constraints and produce final TModel\n')),(0,r.kt)("p",null,"The final TModel contains valuable information such as"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"messages (errors, warnings, info);")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"type facts for subtrees of the given parse tree;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"use/def relations."))),(0,r.kt)("h3",{id:"fact-1"},"Fact"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"fact")," registers known type information for a program fragment ",(0,r.kt)("inlineCode",{parentName:"p"},"src"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ void (value src, AType atype) fact\n")),(0,r.kt)("p",null,"Here"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"src")," may either be a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," (i.e., a parse tree fragment) or a ",(0,r.kt)("inlineCode",{parentName:"p"},"loc")," (the source location of a parse tree\nfragment).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"atype")," is the AType to be associated with ",(0,r.kt)("inlineCode",{parentName:"p"},"src"),"."))),(0,r.kt)("h3",{id:"calculate-1"},"Calculate"),(0,r.kt)("p",null,"All calculate (and require) functions use the following typing convention: an argument of type ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," can either be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"an ",(0,r.kt)("inlineCode",{parentName:"p"},"AType"),", or")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),"."))),(0,r.kt)("p",null,"In the former case, the AType is used as is. In the latter case, the type of the tree is used provided that it exists.\nOtherwise a ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeUnavailable()")," exception is generated and the calculator or requirement in which the predicate occurs\nis re-evaluated at a later time."),(0,r.kt)("h3",{id:"equal"},"equal"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ bool (value l, value r) equal\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"equal")," determines whether the types of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," are equal, the result is a Boolean value."),(0,r.kt)("h3",{id:"subtype"},"subtype"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ bool (value l, value r) subtype\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"subtype")," determines whether the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is a subtype of the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"; it calls the user-provided\nfunction ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubType"),", see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."),(0,r.kt)("h3",{id:"comparable"},"comparable"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ bool (value l, value r) comparable\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"comparable")," determines whether the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is comparable with the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"; it calls the\nuser-provided function ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubType")," twice, see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."),(0,r.kt)("h3",{id:"unify"},"unify"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ bool (value l, value r) unify\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"unify")," determines whether the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," can be unified with the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," it calls the user-provided\nfunctions ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubType")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getLub"),", see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),". The bindings that may result\nfrom unification are effectuated when the enclosing calculate succeeds."),(0,r.kt)("h3",{id:"lub"},"lub"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ AType (value l, value r) lub\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"lub")," return the least upper bound of the types of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"; it calls the user-provided function\n",(0,r.kt)("inlineCode",{parentName:"p"},"getLub"),", see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."),(0,r.kt)("h3",{id:"require-1"},"Require"),(0,r.kt)("h3",{id:"requireequal"},"requireEqual"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ void (value l, value r, FailMessage fmsg) requireEqual\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEqual")," returns when the types of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," are equal, otherwise a FailMessage is reported."),(0,r.kt)("h3",{id:"requiresubtype"},"requireSubType"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ void (value l, value r, FailMessage fmsg) requireSubType\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"requireSubtype")," returns when the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),", otherwise the FailMessage is reported;\nit calls the user-provided function ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubType"),", see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."),(0,r.kt)("h3",{id:"requirecompare"},"requireCompare"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ void (value l, value r, FailMessage fmsg) requireComparable\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"requireComparable")," returns when the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is comparable with the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),", otherwise the\nFailMessage is generated; it calls the user-provided function ","`","getSubType","`","twice, see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal\nConfiguration"),"."),(0,r.kt)("h3",{id:"requireunify"},"requireUnify"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ void (value l, value r, FailMessage fmsg) requireUnify\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"requireUnify just returns when the type of `l")," can be unified with the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),", otherwise the\nFailMessage is reported; it calls the user-provided functions ",(0,r.kt)("inlineCode",{parentName:"p"},"getSubType")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"getLub"),", see ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal\nConfiguration"),". The bindings that may result from unification are effectuated when the enclosing\nrequire succeeds."),(0,r.kt)("h3",{id:"requiretrue-and-requirefalse"},"requireTrue and requireFalse"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ void (bool b, FailMessage fmsg) requireTrue\n/* Solver field */ void (bool b, FailMessage fmsg) requireFalse\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"requireTrue")," returns when its condition is true, otherwise the FailMessage is reported. The function\n",(0,r.kt)("inlineCode",{parentName:"p"},"requireFalse")," returns when its condition is false, otherwise the FailMessage is reported."),(0,r.kt)("h3",{id:"types-1"},"Types"),(0,r.kt)("p",null,"Type-related functions try to retrieve various forms of type information from parts of the source program. When that\ninformation is available, it is returned as result. When it is not available, the internal exception ",(0,r.kt)("inlineCode",{parentName:"p"},"TypeUnavailable()"),"\nis thrown. This will abort the execution of the current requirement or calculator which will then be tried later again."),(0,r.kt)("h3",{id:"gettype"},"getType"),(0,r.kt)("p",null,"The workhorse of TypePal is the function ",(0,r.kt)("inlineCode",{parentName:"p"},"getType")," that determines the type of a given source code fragment in the\ncurrent scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ AType(value src) getType\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"src")," may either be a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree")," (i.e., a parse tree fragment) or a ",(0,r.kt)("inlineCode",{parentName:"p"},"loc")," (the source location of a parse tree fragment)."),(0,r.kt)("p",null,"Here is how ",(0,r.kt)("inlineCode",{parentName:"p"},"getType")," is used in ",(0,r.kt)("a",{parentName:"p",href:"#_pico"},"Pico")," to check the addition operator:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"two integer arguments give an integer result;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"two string arguments give a string result;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"other combinations are incorrect."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'void collect(current: (Expression) `<Expression lhs> + <Expression rhs>`, Collector c){\n     c.calculate("addition", current, [lhs, rhs],\n        AType (Solver s) { switch([s.getType(lhs), s.getType(rhs)]){\n                   case [intType(), intType()]: return intType();\n                   case [strType(), strType()]: return strType();\n                   default:\n                       s.report(error(current, "Operator `+` cannot be applied to %t and %t", lhs, rhs));\n                   }\n                 });\n     collect(lhs, rhs, c);\n}\n')),(0,r.kt)("h3",{id:"gettypeinscope"},"getTypeInScope"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInScope")," determines the type of a given source code fragment in a given scope and given roles:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ AType (Tree occ, loc scope, set[IdRole] idRoles) getTypeInScope\n")),(0,r.kt)("p",null,"Here"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"occ")," is a parse tree fragment;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scope")," is the desired scope;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRoles")," is a set of allowed identifier roles."))),(0,r.kt)("h3",{id:"gettypeinscopefromname"},"getTypeInScopeFromName"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInScopeFromName")," determines the type of a given name that has been bound via given identifier roles\nin a given scope. It is typically used to map a name of a type to its actual type, e.g., mapping the name ",(0,r.kt)("inlineCode",{parentName:"p"},"POINT")," as it\noccurs in a declaration to the actual record type of ",(0,r.kt)("inlineCode",{parentName:"p"},"POINT"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ AType (str name, loc scope, set[IdRole] idRoles) getTypeInScopeFromName\n")),(0,r.kt)("p",null,"Here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"name")," is the name of the desired element;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scope")," is the desired scope;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRoles")," is a set of allowed identifier roles."))),(0,r.kt)("h3",{id:"gettypeintype"},"getTypeInType"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInType")," is typically used to determine parts of a container type such as, e.g., the fields in a\nnamed record type or the methods in a named class type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ AType (AType containerType, Tree selector, set[IdRole] idRolesSel, loc scope) getTypeInType\n")),(0,r.kt)("p",null,"Here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"containerType")," is a given container type;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"selector")," is a parse tree fragment to select a part from the container type (e.g., a field or method name);")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRolesSel")," is a set of allowed identifier roles for the selector (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldId()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"methodId()"),");")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scope")," is the desired scope."))),(0,r.kt)("h3",{id:"getalldefinedintype"},"getAllDefinedInType"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"getAllDefinedInType")," is typically used to determine ",(0,r.kt)("strong",{parentName:"p"},"all")," named types that are defined in a container\ntype, e.g., all fields in a record type or all methods in a class type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ rel[str id, AType atype] (AType containerType, loc scope, set[IdRole] idRoles) getAllDefinedInType\n")),(0,r.kt)("p",null,"Here:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"containerType")," is a given container type;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"scope")," is the desired scope;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"idRoles")," is a set of allowed identifier roles for the selectoed types."))),(0,r.kt)("h3",{id:"inference-1"},"Inference"),(0,r.kt)("p",null,"Type inference is supported by the introduction of type variables using ",(0,r.kt)("inlineCode",{parentName:"p"},"newTypeVar")," in combination with unification\nprimitives inside ",(0,r.kt)("inlineCode",{parentName:"p"},"calculateEager")," ",(0,r.kt)("a",{parentName:"p",href:"#_calculate"},"Calculate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"requireEager")," ",(0,r.kt)("a",{parentName:"p",href:"#_require"},"Require")," such as\n",(0,r.kt)("inlineCode",{parentName:"p"},"requireUnify")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"unify"),". The following functions support the computation with types possibly containing type\nvariables."),(0,r.kt)("h3",{id:"instantiate"},"instantiate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ AType (AType atype) instantiate\n")),(0,r.kt)("p",null,"replaces all type variables occurring in ",(0,r.kt)("inlineCode",{parentName:"p"},"atype")," by their binding (when present)."),(0,r.kt)("h3",{id:"isfullyinstantiated"},"isFullyInstantiated"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ bool (AType atype) isFullyInstantiated\n")),(0,r.kt)("p",null,"checks whether ",(0,r.kt)("inlineCode",{parentName:"p"},"atype")," contains any occurrences of type variables."),(0,r.kt)("h3",{id:"reporting-2"},"Reporting"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ bool(FailMessage fmsg) report\n/* Solver field */ bool (list[FailMessage] fmsgs) reports\n")),(0,r.kt)("h3",{id:"global-info"},"Global Info"),(0,r.kt)("h3",{id:"getconfig"},"getConfig"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ TypePalConfig () getConfig\n")),(0,r.kt)("p",null,"Returns the current ",(0,r.kt)("a",{parentName:"p",href:"#TypePal-Configuration"},"TypePal Configuration"),"."),(0,r.kt)("h3",{id:"getfacts"},"getFacts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ map[loc, AType]() getFacts\n")),(0,r.kt)("p",null,"Returns the type facts known to the Solver as mapping from source location to AType."),(0,r.kt)("h3",{id:"getstore"},"getStore"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Solver field */ map[str,value]() getStore\n")),(0,r.kt)("p",null,"Returns the global store of the Solver. The following elements may occur in the store:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Remaining ",(0,r.kt)("a",{parentName:"li",href:"#_nested_info"},"Nested Info")," from the collect phase. For instance, a single ",(0,r.kt)("inlineCode",{parentName:"li"},"push")," to a stack during the\ncollect phase will be visible during the solve phase and can me (mis)used to communicate information between the two\nphases.")),(0,r.kt)("h2",{id:"typepal-configuration"},"TypePal Configuration"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Configuration options for TypePal"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"TypePal provides configuration options for"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Name Resolution & Overloading"),": configures how names are resolved and which overloading is allowed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Operations on Types"),": configures how operations like subtype and least-upper-bound (lub) are defined.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Retrieval of Types"),": configures how named and structured types are handled.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Extension Points"),": configures operations before an after solving.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Miscellaneous"),": utility functions that can be configured.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"Verbosity"),": configures the verbosity of TypePal."))),(0,r.kt)("p",null,"Here is an overview:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"600",src:a(3718).Z,width:"539",height:"321"})),(0,r.kt)("h3",{id:"name-resolution--overloading"},"Name Resolution & Overloading"),(0,r.kt)("h3",{id:"isacceptablesimple"},"isAcceptableSimple"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ Accept (TModel tm, loc def, Use use) isAcceptableSimple\n")),(0,r.kt)("p",null,"Here"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"tm")," is a given TModel")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"def")," is a proposed definition")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"use")," is the use (characterized by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Use")," data type that contains, name, occurrence, scope and identifier roles\nof the use, see ",(0,r.kt)("a",{parentName:"p",href:"#_identifier_use"},"Identifier Use"),") for which the definition is proposed."))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"isAcceptableSimple")," accepts or rejects a proposed definition for the use of a simple name in a particular role. The\nreturned ",(0,r.kt)("inlineCode",{parentName:"p"},"Accept")," data type is defined as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data Accept\n    = acceptBinding()\n    | ignoreContinue()\n    | ignoreSkipPath()\n    ;\n")),(0,r.kt)("p",null,"The default ",(0,r.kt)("inlineCode",{parentName:"p"},"isAcceptableSimple")," returns acceptBinding()","`","."),(0,r.kt)("p",null,"Typical concerns addressed by ",(0,r.kt)("inlineCode",{parentName:"p"},"isAcceptableSimple")," are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"enforce definition before use;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"check access rights, e.g. visibility."))),(0,r.kt)("p",null,"By comparing the offset of the source locations of definition, respectively, the use, we enforce definition before use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Accept myIsAcceptableSimple(TModel tm, loc def, Use use)\n    = use.occ.offset > def.offset ? acceptBinding() : ignoreContinue();\n")),(0,r.kt)("h3",{id:"isacceptablequalified"},"isAcceptableQualified"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ Accept (TModel tm, loc def, Use use) isAcceptableQualified\n")),(0,r.kt)("p",null,"Here"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"tm")," is a given TModel")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"def")," is a proposed definition")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"use")," is the use for which the definition is proposed."))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"isAcceptableQualified")," accepts or rejects a proposed definition for the use of a qualified name in a particular role."),(0,r.kt)("h3",{id:"isacceptablepath"},"isAcceptablePath"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */\nAccept (TModel tm, loc defScope, loc def, Use use, PathRole pathRole) isAcceptablePath\n")),(0,r.kt)("p",null,"Here"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"tm")," is a given TModel;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"defScope")," is the scope in which the proposed definition occurs;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"def")," is a proposed definition;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"use")," is the use for which the definition is proposed;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"pathRole")," is the role of the semantic path."))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"isAcceptablePath")," accepts or rejects a proposed access path between use and definition."),(0,r.kt)("p",null,"To illustrate this, assume a language with modules and imports. A module may contain variable definitions but these are\nnot visible from outside the module. This can be enforced as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"Accept myIsAcceptablePath(TModel tm, loc def, Use use, PathRole pathRole) {\n    return variableId() in use.idRoles ? ignoreContinue() : acceptBinding();\n}\n")),(0,r.kt)("h3",{id:"mayoverload"},"mayOverload"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool (set[loc] defs, map[loc, Define] defines) mayOverload\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"mayOverload")," determines whether a set of definitions (",(0,r.kt)("inlineCode",{parentName:"p"},"defs"),") are allowed to be overloaded, given their definitions\n(",(0,r.kt)("inlineCode",{parentName:"p"},"defines"),")."),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"#_fwjava"},"FWJava")," the only allowed overloading is between class names and constructor names."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"bool fwjMayOverload (set[loc] defs, map[loc, Define] defines) {\n    roles = {defines[def].idRole | def <- defs};  \n    return roles == {classId(), constructorId()}; \n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"First collect all the roles in which the overloaded names have been defined.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Only allow the combination of class name and constructor name."))),(0,r.kt)("h3",{id:"operations-on-types"},"Operations on Types"),(0,r.kt)("p",null,"Various operations on types can be configured by way of user-defined functions."),(0,r.kt)("h3",{id:"issubtype"},"isSubType"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool (AType l, AType r) isSubType\n")),(0,r.kt)("p",null,"Function that checks whether ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," is a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"."),(0,r.kt)("h3",{id:"getlub"},"getLub"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ AType (AType l, AType r) getLub\n")),(0,r.kt)("p",null,"Function that computes the least upperbound of two types and ",(0,r.kt)("inlineCode",{parentName:"p"},"l")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),"."),(0,r.kt)("h3",{id:"getminatype"},"getMinAType"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ AType() getMinAType\n")),(0,r.kt)("p",null,"Function that returns the ",(0,r.kt)("em",{parentName:"p"},"smallest")," type of the type lattice."),(0,r.kt)("h3",{id:"getmaxatype"},"getMaxAType"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ AType() getMaxAType\n")),(0,r.kt)("p",null,"Function that returns the ",(0,r.kt)("em",{parentName:"p"},"largest")," type of the type lattice."),(0,r.kt)("h3",{id:"instantiatetypeparameters"},"instantiateTypeParameters"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ AType (Tree current, AType def, AType ins, AType act, Solver s) instantiateTypeParameters\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiateTypeParameters")," defines instantiation of ",(0,r.kt)("strong",{parentName:"p"},"language-specific")," type parameters, where:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"current")," is a source code fragment for which type ",(0,r.kt)("inlineCode",{parentName:"p"},"act")," has already been determined, but any ",(0,r.kt)("strong",{parentName:"p"},"language-specific"),"\ntype parameters in ",(0,r.kt)("inlineCode",{parentName:"p"},"act")," may still need to be instantiated.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"def")," is the parameterized type of ",(0,r.kt)("inlineCode",{parentName:"p"},"act"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ins")," is an instantiated version of the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"act")," (i.e., with bound type parameters).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"act")," is the actual type found for ",(0,r.kt)("inlineCode",{parentName:"p"},"current")," that needs to be instantiated."))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"instantiateTypeParameters")," will match ",(0,r.kt)("inlineCode",{parentName:"p"},"def")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"ins")," and the resulting bindings will be used to instantiate ",(0,r.kt)("inlineCode",{parentName:"p"},"act"),".\nThe instantiated version of ",(0,r.kt)("inlineCode",{parentName:"p"},"act")," is returned."),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"#_structparameters"},"StructParameters")," parameterized structs (records) are defined. The formal type of such a struct\nis ",(0,r.kt)("inlineCode",{parentName:"p"},"structDef(str name, list[str] formals)"),", i.e., a struct has a name and a list of named formal type parameters. The\nactual type of a struct is ",(0,r.kt)("inlineCode",{parentName:"p"},"structType(str name, list[AType] actuals)"),", i.e., a struct name followed by actual types for\nthe parameters."),(0,r.kt)("p",null,"The definition of ",(0,r.kt)("inlineCode",{parentName:"p"},"instantiateTypeParameters")," for this example is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"AType structParametersInstantiateTypeParameters(Tree current, structDef(str name1, list[str] formals), structType(str name2, list[AType] actuals), AType t, Solver s){\n    if(size(formals) != size(actuals)) throw checkFailed([]);\n    bindings = (formals[i] : actuals [i] | int i <- index(formals));\n\n    return visit(t) { case typeFormal(str x) => bindings[x] };\n}\n\ndefault AType structParametersInstantiateTypeParameters(Tree current, AType def, AType ins, AType act, Solver s) = act;\n")),(0,r.kt)("h3",{id:"retrieval-of-types"},"Retrieval of Types"),(0,r.kt)("h3",{id:"gettypenamesandrole"},"getTypeNamesAndRole"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */  tuple[list[str] typeNames, set[IdRole] idRoles] (AType atype) getTypeNamesAndRole\n")),(0,r.kt)("p",null,"This function determines whether a given ",(0,r.kt)("inlineCode",{parentName:"p"},"atype")," is a named type or not. This is needed for the customization of\nindirect type computations such as ",(0,r.kt)("a",{parentName:"p",href:"#useViaType"},"???")," and ",(0,r.kt)("a",{parentName:"p",href:"#_gettypeintype"},"getTypeInType"),". When ",(0,r.kt)("inlineCode",{parentName:"p"},"atype")," is a named type\n",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeNamesAndRole")," returns:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A list of names that may be associated with it. In most languages this will contain just a single element, the name\nof the type. In more sophisticated cases the list may contain a list of named types to be considered.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A list of roles in which the type name can be bound."))),(0,r.kt)("p",null,"Here are the definitions for \\<\\<Struct",">",":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"tuple[list[str] typeNames, set[IdRole] idRoles] structGetTypeNamesAndRole(structType(str name)){\n    return <[name], {structId()}>; \n}\n\ndefault tuple[list[str] typeNames, set[IdRole] idRoles] structGetTypeNamesAndRole(AType t){\n    return <[], {}>;               \n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A ",(0,r.kt)("inlineCode",{parentName:"p"},"structType(name)")," has a name that is bound in the role ",(0,r.kt)("inlineCode",{parentName:"p"},"structId()"),". Return the name and role.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Any other type is unnamed; return an empty list of type names."))),(0,r.kt)("p",null,"Another example is the Rascal type checker, where we need to model the case that all abstract data types are a subtype\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),". In that case ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeNamesAndRole")," will return ",(0,r.kt)("inlineCode",{parentName:"p"},'<["A", "Tree"], roles>')," for an abstract data type ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),". The\nnet effect is that when the search for a name in ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," fails, the search is continued in ",(0,r.kt)("inlineCode",{parentName:"p"},"Tree"),"."),(0,r.kt)("h3",{id:"gettypeintypefromdefine"},"getTypeInTypeFromDefine"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */  AType (Define containerDef, str selectorName, set[IdRole] idRolesSel, Solver s) getTypeInTypeFromDefine\n")),(0,r.kt)("p",null,"In some extreme cases (think Rascal) the type of a field selection cannot be determined by considering all the fields\ndefined in a container type and as a last resort one needs to fall back to information that has been associated with the\noriginal definition of the container type. ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInTypeFromDefine")," is called as a last resort from ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInType"),"."),(0,r.kt)("p",null,"In the Rascal type checker common keyword parameters of data declarations are handled using ",(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInTypeFromDefine"),"."),(0,r.kt)("h3",{id:"gettypeinnamelesstype"},"getTypeInNamelessType"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ AType(AType containerType, Tree selector, loc scope, Solver s) getTypeInNamelessType\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getTypeInNamelessType")," describes field selection on built-types that have not been explicitly declared with a name. A\ncase in point is a ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," field on a built-in string type."),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"#_staticfields"},"StaticFields")," this is done as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},'AType staticFieldsGetTypeInNamelessType(AType containerType, Tree selector, loc scope, Solver s){\n    if(containerType == strType() && "<selector>" == "length") return intType();\n    s.report(error(selector, "Undefined field %q on %t", selector, containerType));\n}\n')),(0,r.kt)("h3",{id:"extension-points"},"Extension Points"),(0,r.kt)("h3",{id:"presolver"},"preSolver"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ TModel(map[str,Tree] namedTrees, TModel tm) preSolver\n")),(0,r.kt)("p",null,"A function ",(0,r.kt)("inlineCode",{parentName:"p"},"preSolver")," that can enrich or transform the TModel before the Solver is applied to it."),(0,r.kt)("h3",{id:"postsolver"},"postSolver"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ void (map[str,Tree] namedTrees, Solver s) postSolver\n")),(0,r.kt)("p",null,"A function ",(0,r.kt)("inlineCode",{parentName:"p"},"postSolver")," that can enrich or transform the TModel after constraint solving is complete."),(0,r.kt)("h3",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("h3",{id:"unescapename"},"unescapeName"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */  str(str) unescapeName\n")),(0,r.kt)("p",null,"A function ",(0,r.kt)("em",{parentName:"p"},"unescapeName")," to define language-specific escape rules for names. By default, all backslashes are removed\nfrom names."),(0,r.kt)("h3",{id:"validateconstraints"},"validateConstraints"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool validateConstraints = true\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"validateConstraints")," is true, the validity of all constraints is checked before solving starts. For all\ndependencies (in facts, calculators and requirements) a calculator needs to be present to solve that dependency."),(0,r.kt)("h3",{id:"verbosity"},"Verbosity"),(0,r.kt)("p",null,"The verbosity of TypePal can be controlled with several configurations settings."),(0,r.kt)("h3",{id:"showtimes"},"showTimes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool showTimes = false\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"showTimes")," is true, the time of the Collector and Solver phases is printed."),(0,r.kt)("h3",{id:"showsolversteps"},"showSolverSteps"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool showSolverSteps = false\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"showSolverSteps")," is true, each step of the Solver is printed."),(0,r.kt)("h3",{id:"showsolveriterations"},"showSolverIterations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool showSolverIterations = false\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"showSolverIterations")," is true, information is printed about each iteration of the Solver."),(0,r.kt)("h3",{id:"showattempts"},"showAttempts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool showAttempts = false\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"showAttempts")," is true, the number of evaluation attempts per calculator or requirement is printed when solving is\ncomplete."),(0,r.kt)("h3",{id:"showtmodel"},"showTModel"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"/* Configuration field */ bool showTModel = false\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"showTModel")," is true, the resulting TModel is printed when solving is complete."),(0,r.kt)("h2",{id:"utilities"},"Utilities"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Some utility functions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"TypePal provides some utility functions to address common scenarios."),(0,r.kt)("h3",{id:"collectandsolve"},"collectAndSolve"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"TModel collectAndSolve(Tree pt, TypePalConfig config = tconfig(), bool debug = false)\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"collectAndSolve")," implements the most simple type checking scenario without any customization. For a given parse tree\n",(0,r.kt)("inlineCode",{parentName:"p"},"pt"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Create a Collector and use it to create a TModel by applying ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," to parse tree ",(0,r.kt)("inlineCode",{parentName:"p"},"pt"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Create a Solver and solve the constraints in that TModel.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Return the extended TModel."))),(0,r.kt)("h3",{id:"getusedef"},"getUseDef"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"rel[loc, loc] getUseDef(TModel tm)\n")),(0,r.kt)("p",null,"Get all use-def relations in a given TModel. This may be used in an IDE for creating hyperlinks between use locations\nand definitions."),(0,r.kt)("h3",{id:"getvocabulary"},"getVocabulary"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"set[str] getVocabulary(TModel tm)\n")),(0,r.kt)("p",null,"Get all defined names in a given TModel. This may be used in an IDE for text completion."),(0,r.kt)("h3",{id:"getfacts-1"},"getFacts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"map[loc, AType] getFacts(TModel tm)\n")),(0,r.kt)("p",null,"Get all the locations and their type in a given TModel."),(0,r.kt)("h3",{id:"getmessages"},"getMessages"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"list[Message] getMessages(TModel tm)\n")),(0,r.kt)("p",null,"Get all the messages in a TModel (as added by the Solver)."),(0,r.kt)("h2",{id:"examples-of-typecheckers"},"Examples of Typecheckers"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Synopsis.")),(0,r.kt)("p",null,"Examples of type checkers built with TypePal."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Description.")),(0,r.kt)("p",null,"TypePal is used in a new type checker for the Rascal meta-programming language and also in type checkers for half a\ndozen domain-specific languages created by ",(0,r.kt)("a",{parentName:"p",href:"http://swat.engineering"},"http://swat.engineering")," in the domains finance, forensics and privacy."),(0,r.kt)("p",null,"To get you started more quickly, we give below a list of complete TypePal-based type checkers ranging from very simple\n(intended only to illustrate specific TypePal features) to type checkers for FeatherweightJava and the complete Pascal\nprogramming language. For each example we give a description, the most distinctive TypePal features that are used, and\nits source at GitHub. Each example has the same structure:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Syntax.rsc")," the syntax of the example language.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Checker.rsc")," the type checker for the language.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Test.rsc")," functions to call the type checker and test framework.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"tests.ttl")," test cases for the type checker.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"examples")," (optionally) a directory with example."))),(0,r.kt)("h3",{id:"calc"},"Calc"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"The pocket calculator language Calc; we already covered it ",(0,r.kt)("a",{parentName:"td",href:"#A%20simple%20pocket%20calculator%20language"},"???"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"fact, define, use, requireEqual, calculate, getType, report")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/calc"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/calc"))))),(0,r.kt)("h3",{id:"pico"},"Pico"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"Toy language with declared variables in single scope, assignment, if and while statement")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"fact, define, use, enterScope, leaveScope, requireEqual, calculate, getType, report")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/pico"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/pico"))))),(0,r.kt)("h3",{id:"ql"},"QL"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"A questionnaire language, for describing forms with text entry fields and computed values")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"fact, define, use, requireEqual, requireTrue, calculate, getType, report")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/ql"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/ql"))))),(0,r.kt)("h3",{id:"fun"},"Fun"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"Functional language with explicit types, function declarations and calls, let and if expressions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"fact, define, use, enterScope, leaveScope, requireEqual, calculate, getType, report")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/fun"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/fun"))))),(0,r.kt)("h3",{id:"modfun"},"ModFun"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"Extension of ",(0,r.kt)("a",{parentName:"td",href:"#_fun"},"Fun")," with modules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"PathRole, addPathToDef")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/modfun"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/modfun"))))),(0,r.kt)("h3",{id:"struct"},"Struct"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"Simple named records")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, TypePalConfig, getTypeNamesAndRole")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/struct"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/struct"))))),(0,r.kt)("h3",{id:"aliases"},"Aliases"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#_struct"},"Struct")," extended with type aliases")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, TypePalConfig, getTypeNamesAndRole")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/aliases"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/aliases"))))),(0,r.kt)("h3",{id:"staticfields"},"StaticFields"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#_struct"},"Struct")," extended with fields on non-record type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, TypePalConfig, getTypeNamesAndRole, getTypeInNamelessType")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/staticFields"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/staticFields"))))),(0,r.kt)("h3",{id:"structparameters"},"StructParameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"#_struct"},"Struct")," with parameterized records")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, TypePalConfig, getTypeNamesAndRole, getTypeInNamelessType, instantiateTypeParameters")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/structParameters"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/structParameters"))))),(0,r.kt)("h3",{id:"smalloo"},"SmallOO"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"Small OO language without inheritance")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, TypePalConfig, getTypeNamesAndRole")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/smallOO"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/smallOO"))))),(0,r.kt)("h3",{id:"fwjava"},"FWJava"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"FeatherWeight Java, a minimal, Java-like, language with inheritance and constructors")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, addPathToDef, isSubType, TypePalConfig, getTypeNamesAndRole, mayOverload, preSolver, setScopeInfo, getScopeInfo")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/fwjava"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/fwjava"))))),(0,r.kt)("h3",{id:"pascal"},"Pascal"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"The Pascal language (Second Edition, 1978)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"useViaType, addPathToType, PathRole, isSubType, TypePalConfig, preCollectInitialization getTypeNamesAndRole")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/pascal"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/pascal"))))),(0,r.kt)("h3",{id:"untypedfun"},"UntypedFun"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"What")),(0,r.kt)("td",{parentName:"tr",align:null},"Functional language with implicit (inferred) types, function declarations and calls, let and if expressions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Illustrates")),(0,r.kt)("td",{parentName:"tr",align:null},"fact, define, use, enterScope, leaveScope, requireEqual, calculate, getType, report, newTypeVar, calculateEager, requireUnify, unify")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/cwi-swat/typepal/tree/master/src/examples/untypedFun"},"https://github.com/cwi-swat/typepal/tree/master/src/examples/untypedFun"))))))}u.isMDXComponent=!0},2866:function(e,t,a){t.Z=a.p+"assets/images/Architecture-51a77f24a0832f64fad8457232285e73.png"},4633:function(e,t,a){t.Z=a.p+"assets/images/Collector-59322b84ff51347cd9021affca0e191e.png"},7943:function(e,t,a){t.Z=a.p+"assets/images/NameResolution-f9b3b4ea0d30b1d1a57f7871cf241bc4.png"},3670:function(e,t,a){t.Z=a.p+"assets/images/Solver-374c84ef6a85079567d8514546b1919b.png"},3718:function(e,t,a){t.Z=a.p+"assets/images/TypePalConfig-d6a54ea28650ccf092176144eeea7b0b.png"}}]);