"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[53851],{3905:(e,n,t)=>{t.d(n,{Zo:()=>i,kt:()=>c});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function m(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?m(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},m=Object.keys(e);for(a=0;a<m.length;a++)t=m[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(a=0;a<m.length;a++)t=m[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var v=a.createContext({}),s=function(e){var n=a.useContext(v),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},i=function(e){var n=s(e.components);return a.createElement(v.Provider,{value:n},e.children)},o={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,m=e.originalType,v=e.parentName,i=p(e,["components","mdxType","originalType","parentName"]),u=s(t),c=r,d=u["".concat(v,".").concat(c)]||u[c]||o[c]||m;return t?a.createElement(d,l(l({ref:n},i),{},{components:t})):a.createElement(d,l({ref:n},i))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var m=t.length,l=new Array(m);l[0]=u;var p={};for(var v in n)hasOwnProperty.call(n,v)&&(p[v]=n[v]);p.originalType=e,p.mdxType="string"==typeof e?e:r,l[1]=p;for(var s=2;s<m;s++)l[s]=t[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},82504:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>v,contentTitle:()=>l,default:()=>o,frontMatter:()=>m,metadata:()=>p,toc:()=>s});var a=t(87462),r=(t(67294),t(3905));const m={title:"Eval3"},l=void 0,p={unversionedId:"Recipes/Languages/Func/Eval3/index",id:"Recipes/Languages/Func/Eval3/index",title:"Eval3",description:"Synopsis",source:"@site/docs/Recipes/Languages/Func/Eval3/index.md",sourceDirName:"Recipes/Languages/Func/Eval3",slug:"/Recipes/Languages/Func/Eval3/",permalink:"/docs/Recipes/Languages/Func/Eval3/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Recipes/Languages/Func/Eval3/index.md",tags:[],version:"current",frontMatter:{title:"Eval3"},sidebar:"tutorialSidebar",previous:{title:"Eval2",permalink:"/docs/Recipes/Languages/Func/Eval2/"},next:{title:"Load AST",permalink:"/docs/Recipes/Languages/Func/LoadAST/"}},v={},s=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4}],i={toc:s};function o(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},i,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"synopsis"},"Synopsis"),(0,r.kt)("p",null,"A complete Func interpreter including support for the address and dereference operators."),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Interpreter Eval3 supports the following features of Func: "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Feature"),(0,r.kt)("th",{parentName:"tr",align:null},"Eval3"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"function declaration"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"integer constant"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"variable"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arithmetic operators"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"comparison operators"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"call"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"if"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"let"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sequence"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"address operator")),(0,r.kt)("td",{parentName:"tr",align:null},"y")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"dereference operator")),(0,r.kt)("td",{parentName:"tr",align:null},"y")))),(0,r.kt)("p",null,"The main additions are the address and dereference operators."),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"// tag::module[]\nmodule demo::lang::Func::Eval3\n\n// pointers into the stack\n\nimport demo::lang::Func::AST;\n\nimport List;\n\nalias Env = map[str, Address];\nalias PEnv = map[str, Func];\n\nalias Result3 = tuple[Mem, int];\n\nalias Address = int;\nalias Mem = list[int];\n\nAddress push(Mem mem) {\n  return size(mem);\n}\n\ntuple[Mem, Address] alloc(Mem mem, int v) {\n  mem += [v];\n  return <mem, size(mem) - 1>;\n}\n\nMem pop(Mem mem, Address scope) {\n  return slice(mem, 0, scope);\n}\n\nResult3 eval3(str main, list[int] args, Prog prog) {\n  penv = ( f.name: f | f <- prog.funcs );\n  f = penv[main];\n  mem = [];\n  <mem, env> = bind(f.formals, args, mem); \n  return eval3(f.body, env, penv, mem);\n}\n\ntuple[Mem, Env] bind(list[str] fs, list[int] args, Mem mem) {\n  env = ();\n  for (i <- index(fs)) {\n    <mem, a> = alloc(mem, args[i]);\n    env[fs[i]] = a;\n  }\n  return <mem, env>;\n}\n\nResult3 eval3(nat(int nat), Env env, PEnv penv, Mem mem) = <mem, nat>;\n \nResult3 eval3(var(str name), Env env, PEnv penv, Mem mem) = <mem, mem[env[name]]>;\n       \n       \nResult3 eval3(mul(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x * y>;\n} \n      \nResult3 eval3(div(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x / y>;\n} \n      \nResult3 eval3(add(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x + y>;\n} \n      \nResult3 eval3(sub(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, x - y>;\n} \n      \nResult3 eval3(gt(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x > y) ? 1 : 0>;\n} \n  \nResult3 eval3(lt(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x < y) ? 1 : 0>;\n} \n  \nResult3 eval3(geq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x >= y) ? 1 : 0>;\n} \n  \nResult3 eval3(leq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, x> = eval3(lhs, env, penv, mem);\n  <mem, y> = eval3(rhs, env, penv, mem);\n  return <mem, (x <= y) ? 1 : 0>;\n} \n  \nResult3 eval3(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv, Mem mem) {\n  <mem, c> = eval3(cond, env, penv, mem);\n  return (c != 0) ? eval3(then, env, penv, mem) : eval3(otherwise, env, penv, mem);\n}\n  \nResult3 eval3(call(str name, list[Exp] args), Env env, PEnv penv, Mem mem) {\n   f = penv[name];\n   scope = push(mem);\n   vs = for (a <- args) {\n     <mem, v> = eval3(a, env, penv, mem);\n     append v;\n   }\n   <mem, env> = bind(f.formals, vs, mem);\n   <mem, v> = eval3(f.body, env, penv, mem);\n   return <pop(mem, scope), v>; \n}\n    \nResult3 eval3(address(str var), Env env, PEnv penv, Mem mem) = <mem, env[var]>;\n  \nResult3 eval3(deref(Exp exp), Env env, PEnv penv, Mem mem) {\n  <mem, v> = eval3(exp, env, penv, mem);\n  return <mem, mem[v]>; \n}\n     \nResult3 eval3(let(list[Binding] bindings, Exp exp), Env env, PEnv penv, Mem mem) {\n   scope = push(mem);\n   for (b <- bindings) {\n     <mem, v> = eval3(b.exp, env, penv, mem);\n     <mem, a> = alloc(mem, v);\n     env[b.var] = a;\n   }\n   <mem, v> = eval3(exp, env, penv, mem);\n   return <pop(mem, scope), v>;\n} \n\nResult3 eval3(seq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {\n  <mem, _> = eval3(lhs, env, penv, mem);\n  return eval3(rhs, env, penv, mem);\n}\n\nResult3 eval3(assign(var(str name), Exp e), Env env, PEnv penv, Mem mem) {\n  <mem, v> = eval3(e, env, penv, mem);\n  mem[env[name]] = v;\n  return <mem, v>;\n}\n\nResult3 eval3(assign(deref(Exp lvalue), Exp e), Env env, PEnv penv, Mem mem) {\n  <mem, addr> = eval3(lvalue, env, penv, mem);\n  <mem, v> = eval3(e, env, penv, mem);\n  mem[addr] = v;\n  return <mem, v>;\n}\n// end::module[]\n\n")),(0,r.kt)("p",null,"We apply ",(0,r.kt)("inlineCode",{parentName:"p"},"eval3")," to example ",(0,r.kt)("inlineCode",{parentName:"p"},"F3"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"swap(a, b) =\n          let \n            temp = *a\n          in\n            *a := *b;\n            *b := temp\n          end\n\nfact(n) = let\n            x = 1,\n            y = 0\n          in\n            if n <= 1 then \n               x := 1\n            else \n               x := n * fact(n-1)\n            end;\n            swap(&x, &y);\n            y\n          end\n")),(0,r.kt)("p",null,"Let's try this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal-shell"},'rascal>import demo::lang::Func::Load;\nok\nrascal>import demo::lang::Func::Eval3;\nok\nrascal>import demo::lang::Func::programs::F3;\nok\nrascal>eval3("fact", [10], load(F3));\ntuple[list[int],int]: <[10],3628800>\n')))}o.isMDXComponent=!0}}]);