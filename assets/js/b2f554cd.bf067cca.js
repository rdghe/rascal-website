"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2017/03/01/what-is-vallang","metadata":{"permalink":"/blog/2017/03/01/what-is-vallang","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2017-03-01-what-is-vallang.md","source":"@site/blog/2017-03-01-what-is-vallang.md","title":"What is ValLang?","description":"Vallang () is a highly integrated and mostly-closed collection of mutually recursive fundamental data-types on the Java Virtual Machine:","date":"2017-03-01T00:00:00.000Z","formattedDate":"March 1, 2017","tags":[],"readingTime":11.365,"hasTruncateMarker":false,"authors":[{"name":"Jurgen Vinju","title":"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team","url":"http://homepages.cwi.nl/~jurgenv","imageURL":"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg","key":"jvinju"}],"frontMatter":{"title":"What is ValLang?","authors":["jvinju"]},"nextItem":{"title":"Navigating the WordPress Plugin Landscape","permalink":"/blog/2016/05/16/navigating-the-wordpress-plugin-landscape"}},"content":"**Vallang** (<https://github.com/usethesource/vallang>) is a highly integrated and mostly-closed collection of mutually recursive fundamental data-types on the Java Virtual Machine:\\n\\n* locations represented by URIs: `|java+class://java/lang/String|` and `|file:///tmp/HelloWorld.java|`\\n* integers of arbitrary size: `1,2,3, 134812345123841234`\\n* reals of arbitrary size, precision and scale: `1., 1.0, 1e10`\\n* rational numbers: `1r1, 1r7`\\n* unicode strings: `\\"hello \ud83c\udf10\\"`\\n* lists: `[1,2, 1.0, \\"hello \ud83c\udf10\\"]`, `[]`\\n* sets: `{1,2, 1.0, \\"hello \ud83c\udf10\\"}`, `{}`\\n* maps: `(1:0, \\"a\\":\\"b\\")`, `()`\\n* n-ary tuples with named fields: `<1,2,\\"a\\",1.0>`, `<>`\\n* n-ary relations (represented as sets of n-ary tuples): `{<1,2,\\"a\\",1.0>, <>}`\\n* tree nodes: `\\"myNode\\"(1,2,3)`\\n* many-sorted algebraic terms, acting as typed tree nodes: `myNode(1,2,3)`.\\n* keyword fields or properties to tree nodes and algebraic data-types: `\\"myNode\\"(name=\\"Winston\\")`, `myNode(age=12)`\\n\\nOperations on these data-types are too many to list here. A selection is listed below, but you should expect the features to be pretty low level; i.e. directly accessing and manipulating the data rather than providing analysis algorithms. Algorithms in the library are added only if programming them below the abstraction layer of **vallang** provides a major efficiency benefit or it can factors out highly common client code into a reusable feature. More on this design decision later. \\n\\n* relational calculus operators such as transitive (reflexive) closure, query and projections, compositions and joins\\n* generic tree traversal and primitives for implementing pattern matching\\n\\n**Vallang** has a type system based on type systems in functional programming, but note that each value has a most specific dynamic type associated always at run-time. More on the design of the type system below, but here is a list of **vallang** types:\\n\\n* `void` - the bottom type with no values\\n* `value` - the top type for all values\\n* `loc` - the type for URI locations\\n* `int`, `real`, `rat` are all sub-types of the aggregate type `num`\\n* `tuple[t1,...,tn]` and `tuple[t1 l1, ..., tn ln]` to represent tuples of fixed but arbitrary arity\\n* `list[t]`, `set[t]`, `map[t1,t2]` as incomparable alternative collection types.\\n* `node` for trees\\n* user-defined many-sorted mutually recursive algebraic data-types, acting as grammars for instances of tree nodes: `data MyADT = myNode(int a, int b, int c, int age=...)`\\n* alias types for short-handed type equivalences\\n* `rel[t1, ..., tn]` is an alias for `set[tuple[t1,...tn]]`\\n* open type parameters with upper bounds, `&T <: node`, can be used to type parameterize composite types (used in type aliases) and to construct higher-order abstract algebraic datatypes.\\n\\nSub-typing is _co-variant_ for the container types `list`, `map`, `set` and `tuple`. Otherwise these rules define the entire type system:\\n\\n* `value` is a strict supertype of all other types other than itself\\n* `node` is the common supertype of all algebraic data-types\\n* each algebraic constructor is a strict sub-type of its abstract sort\\n* `void` is the sub-type of all types\\n* `num` is the supertype of `rat`, `int` and `real`\\n* an alias `alias X = Y` is a type equivalence\\n* constructor types are sub-types if they have the same name and arity, and they are comparable in their argument types. \\n   * Within a single abstract sort no two alternative constructors may be sub-types of each other. \\n\\nThere exists an extension mechanism for adding type kinds and their associated value kinds to the **vallang** system. Rascal, for example, uses this to represent functions and co-routines at run-time. The extension mechanism works by declaring a bi-directional transformation between the extensions and a symbolic representation of choice (chosen freely from the core representation mechanisms of **vallang**). This bidirectional mapping is mostly used when serializing and deserializing values (see below).\\n\\nThe types of **vallang** in Java are represented by a Composite design pattern with maximally shared instances of (the otherwise opaque) abstract class `Type`. These types expose fast implementations of sub-type and type equivalence for implementing fast pattern matching. \\n\\nThe values of **vallang** are all instances of `IValue` and sub-interfaces thereof. For every kind of value there is an interface, e.g. `ISet`, `IList`, `ITuple` and `IConstructor` but they are not type-parametrized because Java\'s type system can not represent the aforementioned co-variant sub-typing rules we require. \\n\\n## Why does Vallang exist?\\n\\n**vallang** is a [UseTheSource](http://www.usethesource.io) project recently renamed from **rascal-values**, which was known earlier as **pdb.values**. \\n\\nThe project started as a part of the [IDE metatooling platform](http://homepages.cwi.nl/~jurgenv/papers/OOPSLA-2009.pdf) in 2007 as a *generic library for representing symbolic facts about source code*, for use in the construction of IDE services in Eclipse, then it continued to form the basis of the run-time system for [Rascal](http://www.rascal-mpl.org) starting 2009, and finally was renamed to **vallang** to serve a wider scope.\\n\\nWe designed of **vallang** based on experience with and studying the [ATerm library](http://www.meta-environment.org/Meta-Environment/ATerms.html) and [ASF+SDF](http://www.meta-environment.org/Meta-Environment/WebHome.html), but also by learning from RSF (Rigi Standard Format), Rscript and GXL and S-expressions. Perhaps JSON and YAML have also had a minor influence.\\n\\n> The main purpose of **vallang** is to provide a flexible and fully typed collection of _symbolic_ representations of data, specifically \\"ready\\" to represent facts about software systems but amenable to basically any form of symbolic data analysis purposes.\\n\\nThis purpose aligns with the mission of the [Rascal metaprogramming language](http://www.rascalmpl.org) which is made to _analyze_ and _manipulate_ exactly such symbolic representations. Therefore **vallang** is the run-time environment for both interpreted and compiled Rascal programs. \\n\\nNote that while **vallang** is a great fit for symbolic data analysis, it is currently not the best fit for numerical data analysis as it features only a uniform symbolic represetation of numbers of arbitrary precision and size (ints, reals, rationals). In other words, the numbers and collections of numbers in **vallang** are optimized for storage size, clarity and equational reasoning rather than optimal computational efficiency. This also means that indirect numerical encodings of data (i.e. using numerical vectors and matrices), which are often used in symbolic analyses to optimize computational efficiency are not the right strategy when using **vallang**: it\'s better to stick with a more direct symbolic representation and let **vallang** maintainers optimize them. \\n\\nNext to the maintainers of Rascal, the main users of **vallang** are currently programmers who write data acquisition and (de)serialisation adapters for the Rascal ecosystem:\\n\\n* connecting open-compiler front-ends to Rascal\\n* providing external data-sources such as SQL and MongoDB databases\\n* connecting reusable interaction and visualization front-ends to Rascal\\n\\n> Nevertheless **vallang** is a generic and Rascal-independent library which may serve as the run-time system for other programming languages or analysis systems, such as term rewriting systems, relational calculus systems, constraint solvers, model checkers, model transformations, etc.\\n\\nThe latter perspective is the reason for the re-branding of **rascal-values** to **vallang**. You might consider **vallang** as a functional replacement for ECore, an alternative to the ATerm library on the JVM, or an alternative to JSON-based noSQL in-memory database systems, or a way of implementing graph databases. \\n\\nFinally, **vallang** is a JVM library because that is where we needed it for Rascal and the Eclipse IDE Metatooling Platform. We hope other JVM programmers will also benefit from it and we have no plans of porting it at the moment to any other technological space. \\n\\n\\n## What are the main design considerations of Vallang?\\n\\n#### Vallang values are symbolic and immutable.\\n\\nWe think software analysis is complex enough to be confusing to even the most experienced programmers. Manipulating huge stores of hierarchical and relational data about softwar easily goes wrong; trivial bugs due to aliasing and sharing data between different stages of an analysis or transformation can take weeks to resolve, or worse: will never even be diagnosed. \\n\\nSince our goal is to provide many more variants of all kind of software analyses, we wish to focus on the interesting algorithmic details rather than the trivial mistakes we make. Therefore, **vallang** values are _immutable_. Sharing of values or parts of values is allowed under-the-hood but is not observable. The library is implemented using persistent and/or maximally shared data structures for reasons of efficiency. \\n\\nUsers of **vallang** freely share references to their data to other parts of an analysis because they know the data can not change due to an unforeseen interaction. We also believe that the immutable values can be shared freely between threads on the JVM, but there are not enough tests yet to make such a bold claim with full confidence. \\n\\n#### Vallang values are generated via the AbstractFactory design pattern and do not leak implementation representations\\n\\nThe reason is that client code _must_ abstract from the implementation details to arrive at the mathematical precision of symbolic reasoning which **vallang** should provide.\\n\\nThis also serves a maintenance and evolution purpose for implementations of the library. We can plug in a new implementation of the library without affecting client code.\\n\\nNote that for efficiency reasons values produced from different implementations of an abstract value factory (different implementations of `IValueFactory`) are not required to interact correctly.\\n\\n#### Vallang values uniquely deserialize/serialize from/to a standard and simple expression language\\n\\nThe general rule is that for any two JVM object reference `o` and `p` to any **vallang** object the following rule holds: `o.toString().equals(p.toString) <==> o.equals(p)`\\n\\nWe currently random test this rule and it sometimes fails due to a deprecated feature called \\"annotations\\" which we are removing to make the above contract true.\\n\\nThe intended effects of the toString/equals contract of **vallang** are the following:\\n\\n* What-you-see-is-what-you-get: debugging values by printing them means that you get as a programmer full disclosure about the meaning of the object\\n* Structural equality and equational reasoning: the context in which values are created can not have any influence on their identity\\n* Sharing is safe\\n* Serialisation and deserialisation is never lossy\\n* The sub-type relation for types of values coincides exactly with sublanguage concept of the set of sentences for all values of the given types. \\n\\nThe latter point is one of the main reasons why **vallang** is called a **lang**uage. The result of `anyValue.toString()` is a members of a precisely defined textual languages. The full textual language is generated from the `value` type, and sub-languages are generated from the respective sub-types. `void` is the empty language. In this manner the types of **vallang** act like non-terminals of a precise context-free grammar. The **vallang** language as defined above is a strict sub-language of the `Expression` sub-language of Rascal.\\n\\nThe other reason why **vallang** is names as a language is because the implementations of the `IValue` interface and its sub-interfaces are seen as a closed combinator language for computations on the values, and their implementations are interpreters for this language. \\n\\n#### Vallang values always know their most-precise concrete ad-hoc run-time type\\n\\n* This is nice for debugging purposes, the types are descriptions of values and if matching or equality checking fails then the type abstraction usually explains why without having to go into reading the entire value.\\n* Types may be computed lazily or eagerly, cashed or not. This is not functionally observable but it may affect run-time efficiency\\n* Having precise run-time types for every (nested) value, and having efficient access to this, is a prerequisite for building fast and type-safe rank-2 polymorphic higher order functional computations. Or in functional terms: you need this to make folds and maps work on heterogenous recursive and open data-types. Or in simpler terms: using this we can build statically type-safe data traversal and daya transformation features into Rascal. \\n\\n#### Vallang values include both trees and relations\\n\\nEven though both trees and relations are generic enought to represent any data, sometimes a graph or table is more natural than a tree and sometimes the other way around. \\n\\n* trees are nice for abstract and concrete syntax representations\\n* trees are nice for abstract symbolic domains, such as terms for constraint variables and binary constraints\\n* relations are nice for graph-like unstructred data, such as project dependencies, call graphs, etc.\\n* relations are nice for access to external data stored in spreadsheets and databases\\n* trees are nice for access to web data stored in HTML, XML, JSON formats etc.\\n* trees are good for transformation purposes, where we parse something, rewrite it and unparse it again\\n* relations are good for analysis purposes, where we extract facts, elaborate on them and finally report the result.\\n\\nRascal is a language which can be used to easily switch between different representations of the same information, using pattern matching, querying, comprehensions, etc. From **vallang** you should not expect any help in this regard: the choice of representation for any information is a key design decision for the user of **vallang**.\\n\\n## Who contributed to Vallang?\\n\\n* Robert M. Fuhrer (IBM TJ Watson)\\n* Jurgen J. Vinju (IBM TJ Watson and Centrum Wiskunde & Informatica)\\n* Arnold Lankamp (Centrum Wiskunde & Informatica)\\n* Michael Steindorfer (Centrum Wiskunde & Informatica and TU Delft)\\n* Davy Landman (Centrum Wiskunde & Informatica and SWAT.engineering)\\n* Paul Klint (Centrum Wiskunde & Informatica)\\n\\nand occasional contributions from others please see [github\'s factual overview](https://github.com/usethesource/rascal-value/graphs/contributors)\\n\\n## What is in the near future for Vallang?\\n\\n1. Removal of the \\"annotations\\" feature, which is completely replaces by the \\"keyword fields\\" feature. The main differences between these features are:\\n   * While they both offer extensibility to the set of names and typed fields of nodes and constructors, annotations can never influence `equals()` while keyword fields always do. \\n   * Syntactically the notation for keyword fields is more compact: `f()[@myAnno=1]` versus `f(myField=1)`\\n2. Further integration of the capabilities of [Capsule](http://www.usethesource.io/projects/capsule) for persistent and optimized immutable collections under the hood of `IMap`, `ISet`, `IRelationAlgebra`:\\n   * Reflexive relations with two indices (for both columns)\\n   * Heterogeneous collections of numbers (unboxing down to primitive types to safe space)\\n   * Smooth and incremental transitions from map to multimap representations\\n3. `IBag`, the `bag[&T]` type"},{"id":"/2016/05/16/navigating-the-wordpress-plugin-landscape","metadata":{"permalink":"/blog/2016/05/16/navigating-the-wordpress-plugin-landscape","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2016-05-16-navigating-the-wordpress-plugin-landscape.md","source":"@site/blog/2016-05-16-navigating-the-wordpress-plugin-landscape.md","title":"Navigating the WordPress Plugin Landscape","description":"Helping PHP developers using Rascal-based code analysis.","date":"2016-05-16T00:00:00.000Z","formattedDate":"May 16, 2016","tags":[],"readingTime":0.9,"hasTruncateMarker":false,"authors":[{"name":"Mark Hills","title":"Associate Professor @ East Caroline University, Rascal Contributor","url":"http://www.cs.ecu.edu/hillsma/","imageURL":"https://s.gravatar.com/avatar/cf27b8d5ab19b451087c19f5493d32a9?s=270%27","key":"mhills"}],"frontMatter":{"title":"Navigating the WordPress Plugin Landscape","authors":["mhills"]},"prevItem":{"title":"What is ValLang?","permalink":"/blog/2017/03/01/what-is-vallang"},"nextItem":{"title":"Performance Modeling of Maximal Sharing - Experience Report","permalink":"/blog/2016/03/12/performance-modeling-of-maximal-sharing"}},"content":"Helping PHP developers using Rascal-based code analysis.\\n\\n```\\n@inproceedings{hillsicpc2016,\\n  author = \\"Mark Hills\\",\\n  title = \\"Navigating the WordPress Plugin Landscape\\",\\n  fulltext = \\"http://www.cs.ecu.edu/hillsma/publications/icpc-plugins-2016.pdf\\",\\n  booktitle = \\"Proceedings of the 2015 {IEEE} 23rd International Conference on Program\\n               Comprehension\\"\\n  year = 2016,\\n  location = Austin,\\n  month = may,\\n}\\n```\\n\\nWordPress includes a plugin mechanism that allows user-provided code to be executed in response to specific system events and input/output requests. The large number of extension points provided by WordPress makes it challenging for new plugin developers to understand which extension points they should use, while the thousands of existing plugins make it hard to find existing extension point handler implementations for use as examples when creating a new plugin. In this paper, we present a lightweight analysis, supplemented with information mined from source comments and the webpages hosted by WordPress for each plugin, that guides developers to the right extension points and to existing implementations of handlers for these extension points. We also present empirical information about how plugins are used in practice, providing guidance to both tool and prospective plugin developers."},{"id":"/2016/03/12/performance-modeling-of-maximal-sharing","metadata":{"permalink":"/blog/2016/03/12/performance-modeling-of-maximal-sharing","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2016-03-12-performance-modeling-of-maximal-sharing.md","source":"@site/blog/2016-03-12-performance-modeling-of-maximal-sharing.md","title":"Performance Modeling of Maximal Sharing - Experience Report","description":"This paper won a Best Paper award at ICPE 2016 in Delft.","date":"2016-03-12T00:00:00.000Z","formattedDate":"March 12, 2016","tags":[],"readingTime":1.135,"hasTruncateMarker":false,"authors":[{"name":"Micheal Steindorfer","title":"Researcher @ TU Delft, Rascal Contributor","url":"https://github.com/msteindorfer","imageURL":"https://avatars.githubusercontent.com/u/1998004?v=4","key":"msteindorfer"}],"frontMatter":{"title":"Performance Modeling of Maximal Sharing - Experience Report","authors":["msteindorfer"]},"prevItem":{"title":"Navigating the WordPress Plugin Landscape","permalink":"/blog/2016/05/16/navigating-the-wordpress-plugin-landscape"},"nextItem":{"title":"Empirical analysis of the relationship between CC and SLOC","permalink":"/blog/2016/01/01/empirical-analysis-of-the-relationship-between-CC-and-SLOC"}},"content":"This paper won a Best Paper award at ICPE 2016 in Delft. \\n\\n```\\n@inproceedings{icpe2016-steindorfer,\\n author = {Michael Steindorfer and Jurgen J. Vinju.},\\n title = {Performance Modeling of Maximal Sharing},\\n booktitle = {7th ACM/SPEC International Conference on Performance Engineering (ICPE)},\\n year = 2016,\\n fulltext = \\"http://homepages.cwi.nl/~jurgenv/papers/ICPE16.pdf\\"\\n}\\n```\\n\\nIt is noticeably hard to predict the effect of optimization strategies in Java without implementing them. \u201cMaximal sharing\u201d (a.k.a. \u201chash-consing\u201d) is one of these strategies that may have great benefit in terms of time and space, or may have detrimental overhead. It all depends on the redundancy of data and the use of equality. We used a combination of new techniques to predict the impact of maximal sharing on existing code: Object Re- dundancy Profiling (ORP) to model the effect on memory when sharing all immutable objects, and Equals-Call Profil- ing (ECP) to reason about how removing redundancy impacts runtime performance. With comparatively low effort, using the MAximal SHaring Oracle (MASHO), a prototype pro- filer based on ORP and ECP, we can uncover optimization opportunities that otherwise would remain hidden. We report on the experience of applying MASHO to real and complex case: we conclude that ORP and ECP combined can accurately predict gains and losses of maximal sharing, and also that (by isolating variables) a cheap predictive model can sometimes provide more accurate information than an expensive experiment can."},{"id":"/2016/01/01/empirical-analysis-of-the-relationship-between-CC-and-SLOC","metadata":{"permalink":"/blog/2016/01/01/empirical-analysis-of-the-relationship-between-CC-and-SLOC","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2016-01-01-empirical-analysis-of-the-relationship-between-CC-and-SLOC.md","source":"@site/blog/2016-01-01-empirical-analysis-of-the-relationship-between-CC-and-SLOC.md","title":"Empirical analysis of the relationship between CC and SLOC","description":"Check out these two related articles on the empirical relation between the CC and SLOC source code metrics.","date":"2016-01-01T00:00:00.000Z","formattedDate":"January 1, 2016","tags":[],"readingTime":1.655,"hasTruncateMarker":false,"authors":[{"name":"Davy Landman","title":"Language Engineer & CEO of swat.engineering, Rascal Core Team","url":"https://homepages.cwi.nl/~landman/","imageURL":"https://homepages.cwi.nl/~landman/images/davylandman.png","key":"dlandman"}],"frontMatter":{"title":"Empirical analysis of the relationship between CC and SLOC","authors":["dlandman"]},"prevItem":{"title":"Performance Modeling of Maximal Sharing - Experience Report","permalink":"/blog/2016/03/12/performance-modeling-of-maximal-sharing"},"nextItem":{"title":"Optimizing Hash Tries","permalink":"/blog/2015/10/30/optimizing-hash-tries"}},"content":"Check out these two related articles on the empirical relation between the CC and SLOC source code metrics.\\n\\n```\\n@ARTICLE{jsep2015-landman,\\n  author = { Davy Landman and Alexander Serebrenik and Eric Bouwers and Jurgen J. Vinju },\\n  title = { {Empirical analysis of the relationship between CC and SLOC in a large corpus of Java methods and C functions} },\\n  journal = { Journal of Software: Evolution and Process },\\n  year = { 2015 },\\n  doi = { 10.1002/smr.1760 },\\n  fulltext  = \\"http://homepages.cwi.nl/~landman/docs/Landman2015-ccsloc-jsep2015-preprint.pdf\\",\\n  datalink = { http://homepages.cwi.nl/~landman/jsep2015/ },\\n}\\n\\n@INPROCEEDINGS{Landman2014,\\n  author = { Davy Landman and Alexander Serebrenik and Jurgen J. Vinju },\\n  title = { {Empirical analysis of the relationship between CC and SLOC in a large corpus of Java methods} },\\n  booktitle = { 30th IEEE International Conference on Software Maintenance and\\n  Evolution, ICSME 2014 },\\n  year = { 2014 },\\n  datalink = { http://homepages.cwi.nl/~landman/icsme2014/ },\\n  fulltext= \\"http://homepages.cwi.nl/~landman/docs/Landman2014-ccsloc-icsme2014-preprint.pdf\\"\\n}\\n```\\n\\nMeasuring the internal quality of source code is one of the traditional \\ngoals of making software development into an engineering discipline. \\nCyclomatic Complexity (CC) is an often used source code quality metric, next \\nto Source Lines of Code (SLOC). However, the use of the CC metric is \\nchallenged by the repeated claim that CC is redundant with respect to SLOC \\ndue to strong linear correlation.\\n\\n\\nWe conducted an extensive literature study of the CC/SLOC correlation results. \\nNext, we tested correlation on large Java (17.6 M methods) and C (6.3 M \\nfunctions) corpora. Our results show that linear correlation between SLOC and CC \\nis only moderate as caused by increasingly high variance. We further observe \\nthat aggregating CC and SLOC as well as performing a power transform improves \\nthe correlation.\\n\\nOur conclusion is that the observed linear correlation between CC and SLOC \\nof Java methods or C functions is not strong enough to conclude that CC is \\nredundant with SLOC. This conclusion contradicts earlier claims from \\nliterature, but concurs with the widely accepted practice of measuring of CC \\nnext to SLOC."},{"id":"/2015/10/30/optimizing-hash-tries","metadata":{"permalink":"/blog/2015/10/30/optimizing-hash-tries","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2015-10-30-optimizing-hash-tries.md","source":"@site/blog/2015-10-30-optimizing-hash-tries.md","title":"Optimizing Hash Tries","description":"Hash-tries are the data-structure under Rascal\'s sets, maps and relations. These papers explain how they work and how we make them lean and fast on the JVM. Others have blogged about these results as well. The code can be found in the Capsule project.","date":"2015-10-30T00:00:00.000Z","formattedDate":"October 30, 2015","tags":[],"readingTime":1.535,"hasTruncateMarker":false,"authors":[{"name":"Jurgen Vinju","title":"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team","url":"http://homepages.cwi.nl/~jurgenv","imageURL":"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg","key":"jvinju"}],"frontMatter":{"title":"Optimizing Hash Tries","authors":["jvinju"]},"prevItem":{"title":"Empirical analysis of the relationship between CC and SLOC","permalink":"/blog/2016/01/01/empirical-analysis-of-the-relationship-between-CC-and-SLOC"},"nextItem":{"title":"From imperative programming to functional programming","permalink":"/blog/2015/03/02/from-imperative-to-functional"}},"content":"Hash-tries are the data-structure under Rascal\'s sets, maps and relations. These papers explain how they work and how we make them lean and fast on the JVM. [Others](https://blog.acolyer.org/2015/11/27/hamt/) have blogged about these results as well. The code can be found in the [Capsule project](http://www.usethesource.io/projects/capsule).\\n\\n```\\n@inproceedings{oopsla2015,\\n  title = {Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections}\\n  author = {Michael Steindorder and Jurgen J. Vinju}.\\n  year = 2015,\\n  booktitle = {Proceedings of the Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA)},\\n  editor = {Patrick Eugster},\\n  fulltext = \\"http://michael.steindorfer.name/publications/oopsla15.pdf\\",\\n}\\n\\n@inproceedings{gpce14,\\n author = {Steindorfer, Michael J. and Vinju, Jurgen J.},\\n title = {Code Specialization for Memory Efficient Hash Tries},\\n booktitle = {Proceedings of the 2014 International Conference on Generative Programming: Concepts and Experiences},\\n series = {GPCE 2014},\\n year = {2014},\\n pages = {11--14},\\n numpages = {4},\\n doi = {10.1145/2658761.2658763},\\n publisher = {ACM},\\n fulltext = \\"http://michael.steindorfer.name/publications/gpce14.pdf\\"\\n} \\n```\\n\\nThe data structures under-pinning collection API (e.g. lists, sets, maps) in the standard libraries of programming languages are used intensively in many applications. The standard libraries of recent Java Virtual Machine languages, such as Clojure or Scala, contain scalable and well-performing immutable collection data structures that are implemented as Hash-Array Mapped Tries (HAMTs). HAMTs already feature efficient lookup, insert, and delete operations, however due to their tree-based nature their memory footprints and the runtime performance of iteration and equality checking lag behind array-based counterparts. This particularly prohibits their application in programs which process larger data sets. In this paper, we propose changes to the HAMT design that increase the overall performance of immutable sets and maps. The resulting general purpose design increases cache locality and features a canonical representation. It outperforms Scala\u2019s and Clojure\u2019s data structure implementations in terms of memory footprint and runtime efficiency of iteration (1.3\u2013 6.7 x) and equality checking (3\u201325.4 x)."},{"id":"/2015/03/02/from-imperative-to-functional","metadata":{"permalink":"/blog/2015/03/02/from-imperative-to-functional","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2015-03-02-from-imperative-to-functional.md","source":"@site/blog/2015-03-02-from-imperative-to-functional.md","title":"From imperative programming to functional programming","description":"Rascal features immutable data, but at the same time a number of language constructs which are a lot like \\"traditional\\" structured imperative programming: while, if, etc. Without going into the full power of these constructs in Rascal (featuring lexically scoped backtracking, for example) in this post we go into how in the same language we can program imperatively and functionally at the same time.","date":"2015-03-02T00:00:00.000Z","formattedDate":"March 2, 2015","tags":[],"readingTime":3.47,"hasTruncateMarker":false,"authors":[{"name":"Jurgen Vinju","title":"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team","url":"http://homepages.cwi.nl/~jurgenv","imageURL":"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg","key":"jvinju"}],"frontMatter":{"authors":["jvinju"],"title":"From imperative programming to functional programming"},"prevItem":{"title":"Optimizing Hash Tries","permalink":"/blog/2015/10/30/optimizing-hash-tries"},"nextItem":{"title":"The Language Interaction Design of Concrete Syntax","permalink":"/blog/2013/08/02/the-language-interaction-design-of-concrete-syntax"}},"content":"Rascal features immutable data, but at the same time a number of language constructs which are a lot like \\"traditional\\" structured imperative programming: `while`, `if`, etc. Without going into the full power of these constructs in Rascal (featuring lexically scoped backtracking, for example) in this post we go into how _in the same language_ we can program imperatively and functionally at the same time.\\n\\nThe reason Rascal features these two styles is that we want to make it easy for programmers who are used to the imperative paradigm to step into the language. More importantly, we want to make it easy to type classical textbook examples of program analysis and transformations pseudocode rather directly into Rascal syntax. \\n\\n### A story about even numbers\\n\\nLet\'s write a function that generates all the even numbers in a list up to a certain maximum. We will do it in a few alternative \\nways: from very imperative to very declarative and some steps in between.\\n\\n```\\nlist[int] even0(int max) {\\n  list[int] result = [];\\n  for (int i <- [0..max])\\n    if (i % 2 == 0)\\n      result += i;\\n  return result;\\n}\\n```\\n\\nNow lets remove the temporary type declarations:\\n\\n```\\nlist[int] even1(int max) {\\n  result = [];\\n  for (i <- [0..max])\\n    if (i % 2 == 0)\\n      result += i;\\n  return result;\\n}\\n```\\n\\nTo make the code shorter, we can inline the condition in the for loop:\\n\\n```\\nlist[int] even2(int max) {\\n  result = [];\\n  for (i <- [0..max], i % 2 == 0)\\n    result += i;\\n  return result;\\n}\\n```\\n\\nIn fact, for loops may produce lists as values, using the append statement:\\n\\n```\\nlist[int] even3(int max) {\\n  result = for (i <- [0..max], i % 2 == 0)\\n    append i;\\n  return result;\\n}\\n```\\n\\nSo now, the result temporary is not necessary anymore:\\n\\n```\\nlist[int] even4(int max) {\\n  return for (i <- [0..max], i % 2 == 0)\\n           append i;\\n}\\n```\\n\\nThis code is actually very close to a list comprehension already:\\n\\n```\\nlist[int] even5(int max) {\\n  return [ i | i <- [0..max], i % 2 == 0];\\n}\\n```\\n\\nAnd now we can just define even using an expression only:\\n\\n```\\nlist[int] even6(int max) = [i | i <- [0..max], i % 2 == 0];\\n```\\n\\nOr, perhaps we like a set instead of a list:\\n\\n```\\nset[int] even7(int max) = {i | i <- [0..max], i % 2 == 0};\\n```\\n\\n### What just happened?\\n\\nIn summary:\\n\\n* We went from 5 lines of code to 1\\n* We went from 3 control flow constructs (for, if, return) to 0\\n* We introduced a list comprehension\\n* All expressions have remained equal\\n* Intermediate temporary variables dissappeared\\n\\nWhat did not happen is any magic. The code still executes the same \\"algorithm\\" if you will. The functional programming style in Rascal can be seen as a shorter notation for a more bloated use of imperative control flow constructs.\\n\\n### The usefulness of imperative control flow constructs\\n\\nUp front, Rascal\'s control flow constructs are more powerful than general purpose programming languages control flow constructs. They feature lexically scoped backtracking, lists of conditions, etc.\\n\\nEven without those advanced features, it is sometimes very handy to split a computation in parts without having to introduce another function abstraction. While exploring a new algorithm, temporary variables can be printed and inspected at debug time, etc.\\n\\nIn Rascal, people often use imperative control flow to _explore_ solutions or _copy_ them from text books, and when they are happy with the algorithm they try and improve the formulation by finding the right functional abstractions. \\n\\n### The benefit of functional abstraction over imperative control flow\\n\\nThe real benefits, above brevity and elegance, of the functional style over the imperative style are reusability and extensibility. Smaller functional abstractions are easier to reuse and easier to override. Also, using Rascal\'s dynamic dispatch using pattern matching (a.k.a. term rewriting) adding new options to algebraic data types can be complemented with adding new cases for functions. In the imperative style such an extension would imply editing existing code, while in the functional style this would not be necessary. See also this other [post](http://www.rascal-mpl.org/from-functions-to-term-rewriting-and-back)."},{"id":"/2013/08/02/the-language-interaction-design-of-concrete-syntax","metadata":{"permalink":"/blog/2013/08/02/the-language-interaction-design-of-concrete-syntax","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2013-08-02-the-language-interaction-design-of-concrete-syntax.md","source":"@site/blog/2013-08-02-the-language-interaction-design-of-concrete-syntax.md","title":"The Language Interaction Design of Concrete Syntax","description":"This post dives into some of the design decisions regarding the manipulation of parse trees and abstract syntax trees in Rascal using concrete syntax notation.","date":"2013-08-02T00:00:00.000Z","formattedDate":"August 2, 2013","tags":[],"readingTime":3.22,"hasTruncateMarker":false,"authors":[{"name":"Jurgen Vinju","title":"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team","url":"http://homepages.cwi.nl/~jurgenv","imageURL":"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg","key":"jvinju"}],"frontMatter":{"authors":["jvinju"],"title":"The Language Interaction Design of Concrete Syntax"},"prevItem":{"title":"From imperative programming to functional programming","permalink":"/blog/2015/03/02/from-imperative-to-functional"},"nextItem":{"title":"A DSL in 36 lines of code","permalink":"/blog/2013/07/29/dsl-in-36-lines-of-code"}},"content":"This post dives into some of the design decisions regarding the manipulation of parse trees and abstract syntax trees in Rascal using _concrete syntax_ notation. \\n\\n## Definitions\\n\\nWhat we call _concrete syntax_ is a notation for syntax trees that is embedded into the expression notation of meta programming languages. This notation should be equal, or mostly equal, to the surface syntax of the language that is represented by the syntax trees, _and the expressions are still syntactically and statically checked for correctness_. As far as notations for syntax trees go, concrete syntax is a clear winner. Let\'s compare some expressions representing a piece of C code.\\n\\n### Concrete syntax\\n\\n```\\nif (a && b) { \\n  println(\\"a and b\\"); \\n}\\n```\\n\\n### Lisp S-expressions\\n\\n```\\n(if ((and (id \\"a\\") (id \\"b\\")) \\n    (block \\n      ((call (id \\"println\\") (args (strconst \\"a and b\\")))\\n    )\\n)\\n```\\n\\n### XML\\n\\n```\\n<if>\\n  <and>\\n    <id>a</id>\\n    <id>b</id>\\n  </and>\\n  <block>\\n    <call>\\n      <id>println</id>\\n      <args>\\n        <strconst>a and b</strconst>\\n      </args>\\n    </call>\\n  </block>\\n</if>\\n```\\n\\n### YAML/JSON\\n\\n```\\nif:\\n  - and:\\n     - id: a\\n     - id: b\\n  - block:\\n     - call:\\n        - id: println\\n        - args:\\n          - strconst: a and b \\n```\\n\\nFor the degenerate case of a single node with no children, of course any abstract notation wins. As soon as we have nesting, even marginally interesting code snippets, however, concrete syntax wins by landslide in terms of brevity and cognitive overload.\\n\\n## Meta Variables\\n\\nThe above examples showed only literal program fragments. One distinguishing feature, however, of concrete syntax is ...\\n\\n## History\\n\\nThe concrete syntax feature appeared first, as far as I know and please correct me if I am wrong, in the early 1980\'s in experimental meta programming systems and  algebraic specification systems. There was a concept of _mix fix_ operator syntax where algebraic operators would not only be exclusively prefix, postfix or infix, but all at the same time. This would allow, for example, to define readable algebraic operators with arity larger than two such as `if _ then _ else _`. Some systems started to use BNF to define mix fix functions, and concrete syntax was born. In extreme cases, such as ASF+SDF any context-free grammar rule was allowed to be an operator, while in other systems more restrictions could apply. \\n\\nIf you are interested in what this all looked like, also in the years after that, the following is a list of names of systems that used or use mixfix operators or concrete syntax in some form or another:\\n\\n* ASF+SDF\\n* TXL\\n* StrategoXT\\n* Maude\\n* ELAN\\n* OBJ\\n* Smarttools\\n* Repleo\\n* SugarJ\\n* K\\n\\nPeople that I know by heart who published on the concrete syntax feature are Annika Aasa, Kent Petersson, Dan Synek, Chris Verhoef, Paul Klint, Eelco Visser, Peter Borovansky, Jan Rekers, Martin Bravenboer, Rob Vermaas, Radu Mereuta, Dorel Lucanu, Jeroen Arnoldus, and yours truly. There must be more.\\n\\nConcrete syntax should not be confused with string or file templates, such as found in PHP-like template expanders. The difference is that such templates are flat strings that are not statically checked or parsed. With concrete syntax you can not write a pattern that will never match, and you can not write a pattern that will construct a syntactically incorrect output.\\n\\nConcrete syntax is also strongly related to the older concept of _syntax macros_ (1970\'s). The similarity is that with syntax macros the user can also define the syntax of functions. The difference is that syntax macros are always expanded into the host language, while with concrete syntax the objects can be manipulated in an arbitrary way, often not to expand into the host language but rather to output a transformed output form.  \\n\\nSo, concrete syntax is not new or novel in any way. It is a good idea nevertheless, and it comes with interesting language usability trade-offs.\\n\\n## Quotes \\n\\n## Types\\n\\n## Rascal"},{"id":"/2013/07/29/dsl-in-36-lines-of-code","metadata":{"permalink":"/blog/2013/07/29/dsl-in-36-lines-of-code","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2013-07-29-dsl-in-36-lines-of-code.md","source":"@site/blog/2013-07-29-dsl-in-36-lines-of-code.md","title":"A DSL in 36 lines of code","description":"One of the goals of Rascal is to allow the definition of Domain-Specific Languages.","date":"2013-07-29T00:00:00.000Z","formattedDate":"July 29, 2013","tags":[],"readingTime":3.37,"hasTruncateMarker":false,"authors":[{"name":"Tijs van der Storm","title":"Senior researcher @ CWI-SWAT, professor @ RUG, Rascal Core Team","url":"https://homepages.cwi.nl/~storm/","imageURL":"https://www.uva.nl/binaries/_ht_1610011694919/extralarge/content/gallery/personen/s/t/tijs-van-der-storm_low_res.jpg","key":"tvdstorm"}],"frontMatter":{"title":"A DSL in 36 lines of code","authors":["tvdstorm"]},"prevItem":{"title":"The Language Interaction Design of Concrete Syntax","permalink":"/blog/2013/08/02/the-language-interaction-design-of-concrete-syntax"},"nextItem":{"title":"From functions to term rewriting and back in Rascal","permalink":"/blog/2013/05/15/from-functions-to-term-rewriting-and-back"}},"content":"One of the goals of Rascal is to allow the definition of [Domain-Specific Languages](https://en.wikipedia.org/wiki/Domain-specific_language). \\nIn this small post we give a flavor of how you can use Rascal to define the syntax of a DSL, a simple semantic check and how to compile the DSL to Java.\\n\\nThe following example shows how to define a simple DSL for state machines. It includes a parser, a check for unreachable states and a compiler to Java code. \\n\\nThe grammar of the DSL is defined using Rascal\'s grammar formalism which is fully integrated in the language.\\nShown below is the syntax definition of a simple state machine language, inspired by  Martin Fowler\'s example language for [gothic security](http://www.informit.com/articles/article.aspx?p=1592379).\\n\\n```rascal\\nmodule Syntax\\n\\nextend lang::std::Layout;\\nextend lang::std::Id;\\n\\nstart syntax Machine = machine: State+ states;\\nsyntax State = @Foldable state: \\"state\\" Id name Trans* out;\\nsyntax Trans = trans: Id event \\":\\" Id to;\\n```\\n\\nA state machine consists of a number of named state declarations, where each state contains transitions to other states (identified by name) when a certain event happens. \\nThe grammar reuses identifier syntax and whitespace convention from the standard library.\\nEach non-terminal defines a *type*. Parse trees are typed values like any other value in Rascal.\\nAs a result, you can write functions that process such trees. \\nAn example would be a semantic check on state machines, such as finding all unreachable states: \\n\\n```rascal\\nmodule Analyze\\n\\nimport Syntax;\\n\\nset[Id] unreachable(Machine m) {\\n  r = { <q1,q2> | (State)`state <Id q1> <Trans* ts>` <- m.states, \\n\\t\\t\\t\\t  (Trans)`<Id _>: <Id q2>` <- ts }+;\\n  qs = [ q.name | q &- m.states ];\\n  return { q | q <- qs, q notin r[qs[0]] };\\n}\\n```\\n\\nTo check for unreachable states, we first create a binary relation between states using a comprehension. \\nThis comprehension uses *concrete syntax* matching to find a state\'s transitions. \\nThe pattern between backticks is written in the object language, which in this case is the statemachine language defined in the grammar above (Note the embedded syntax highlighting!). \\nThe variables `q1` and `ts` in between `<` and `>` are bound for each state that is found in the machine `m`. \\nA similar pattern is used to find the target state `q2` is found in each transition in `ts`.\\nThe post-fix `+` then computes the transitive closure of the relation. \\n\\nThe relation `r` is based on the transitions in a state machine. \\nThis means that it does not include declared (final) states which have no outgoing transitions.\\nWe collect the names of all defined states in `qs` , again using a comprehension. \\n\\nThe initial state is (conventionally) defined to be the state that is declared first. \\nAn unreachable state is then defined as a state that is not in the right image of the initial state in the transitive closure of the transition relation. \\nThis is exactly what is described by the last comprehension! \\nThe notation `r[x]`, where `r` is a relation  is short hand for `{ y | <x, y> <- r }`.\\n\\n\\nThere are various ways of compiling a DSL to target code in Rascal. The simplest is using string templates and generate code in a general purpose language. The following snippet shows the generation of a Java while loop to execute a state machine.\\n\\n```rascal\\nmodule Compile\\n\\nimport Syntax;\\n\\nstr compile(Machine m) =\\n  \\"while (true) {\\n  \'  event = input.next();\\n  \'  switch (current) { \\n  \'    <for (q <- m.states) {>\\n  \'    case \\\\\\"<q.name>\\\\\\":\\n  \'      <for (t <- q.out) {>\\n  \'      if (event.equals(\\\\\\"<t.event>\\\\\\"))\\n  \'        current = \\\\\\"<t.to>\\\\\\";\\n  \'      <}>\\n  \'      break;\\n  \'    <}>\\n  \'  }\\n  \'}\\"; \\n```\\n\\nString templates allow arbitrary Rascal values and control-flow constructs to be interpolated in string literals. Note how this code does not use concrete matching, but instead uses the labels defined in the grammar (i.e., `states`, `out`, `event`, and `to`).\\n\\nAnd that\'s it! A complete DSL in 36 lines of code. Of course, the parser and the `unreachable` and `compile` functions can be connected to the IDE. This provides custom syntax highlighting, error-marking and automatic building in state machine editors."},{"id":"/2013/05/15/from-functions-to-term-rewriting-and-back","metadata":{"permalink":"/blog/2013/05/15/from-functions-to-term-rewriting-and-back","editUrl":"https://github.com/usethesource/rascal-website/tree/website-v2/blog/blog/2013-05-15-from-functions-to-term-rewriting-and-back.md","source":"@site/blog/2013-05-15-from-functions-to-term-rewriting-and-back.md","title":"From functions to term rewriting and back in Rascal","description":"Here\'s a nifty design element from Rascal that I personally like: functions are actually rewrite rules. The bottom line here is that pattern matching drives dynamic dispatch which results in openly extensible meta programs.","date":"2013-05-15T00:00:00.000Z","formattedDate":"May 15, 2013","tags":[],"readingTime":5.335,"hasTruncateMarker":false,"authors":[{"name":"Jurgen Vinju","title":"Groupleader @ CWI-SWAT, professor @ TU/E, Rascal Core Team","url":"http://homepages.cwi.nl/~jurgenv","imageURL":"https://www.cwi.nl/news/2014/jurgen-vinju-appointed-professor/@@images/5e1fe43d-a00b-4989-a5b9-eb526725c6ee.jpeg","key":"jvinju"}],"frontMatter":{"authors":["jvinju"],"title":"From functions to term rewriting and back in Rascal"},"prevItem":{"title":"A DSL in 36 lines of code","permalink":"/blog/2013/07/29/dsl-in-36-lines-of-code"}},"content":"Here\'s a nifty design element from Rascal that I personally like: functions are actually rewrite rules. The bottom line here is that pattern matching drives dynamic dispatch which results in openly extensible meta programs.\\n\\nThe design choice seems obvious for people who have been programming in ASF+SDF, Stratego and TXL who argue that rewrite rules and strategies were actually just functions.\\n\\n## Complete functions\\n\\nIn Rascal we write functions in a Java/C/C# like syntax:\\n\\n```\\nint fac(int n) {\\n  if (n == 0)\\n    return 1;\\n  else\\n    return n * f(n - 1);\\n }\\n```\\n\\nOr slightly shorter and more elegant we could write:\\n\\n```\\nint f(int n) = n == 0 ? 1 : n * f(n - 1);\\n```\\n\\nIn fact, function definitions are just rewrite rules with a funny syntax, the `int n` is actually a pattern that matches integers only and binds them to the variable `n`. This means we can write more concrete patterns and separate the case distinction:\\n\\n```\\nint f(0) = 1;\\ndefault int f(int n) = n * f(n - 1);\\n```\\n\\nThe default keyword here indicates to try this alternative only after the other ones, which is obligatory here since Rascal\'s rules are statically mutually non-overlapping.\\n\\n## Functions with normal forms\\n\\nSo far we have written a function which is total, i.e. it has to provide a result for all elements of the parameter types. To make this more rewriting-like, where we have normal forms, consider the interaction with constructor functions in the following example:\\n\\n```\\ndata Bool\\n  = t()\\n  | f()\\n  | and(Bool l, Bool r)\\n  |   or(Bool l, Bool r)\\n  ;\\n  \\nBool and(f(), Bool _) = f();\\nBool and(t(), Bool b) = b;\\n```\\n\\nHere we see the `and` function defined for two cases, where the first argument matches either `t()` or `f()`. It is not defined for any other cases, for example the first argument could be an `or(t(),t())`, so in this sense it is partial. However, the data definition provides a `default` case for the and function, namely to construct the `and` term.\\n\\nFor those of us who are used to rewrite rules, we see rules that are labeled by the sort of the terms that are being rewritten.\\nHere are some example expressions executed in the console:\\n\\n```\\nrascal>and(t(),t())\\nBool: t();\\nrascal>and(f(),t())\\nBool: f();\\nrascal>and(or(t(),t()),t())\\nBool: and(or(t(),t()),t())\\n```\\n\\n## Modularity by open extensibility\\n\\nThe key benefit of being able to use pattern matching for dynamic dispatch, is extensibility. Suppose we add \\"maybe\\" to our logical language in a separate module. This is possible since data signatures are extensible:\\n\\n```\\ndata Bool = maybe();\\n```\\n\\nNow we need to reconsider the semantics of the `and` function, and without changing the original definitions for `and` we simply type these extensions to implement three-valued logic:\\n\\n```\\nBool and(maybe(), maybe()) = maybe()\\nBool and(maybe(), true()) = maybe()\\nBool and(maybe(), false()) = false()\\n```\\n\\n## Pattern matching galore\\n\\nIn Rascal we have a powerful pattern matching operator suite, including:\\n\\n* list matching (associative), for example: `[*_, elem, _*, elem, _*]`\\n* set matching (commutative, associative, idempotent), for example: `f({e,*other, f({e,*nested})})`\\n* deep matching (recursive), as in `/t()` \\n* negative matching, as in `!and(_,_)`\\n* non-linear matching (see above list matching example)\\n* etc.\\n\\nThese operators may occur in the parameter positions of function definitions, just as they can in switch, visit, {list,set,map} comprehensions, loops, conditionals, etc. As such they give a very broad means to the programmer on how to dispatch between cases. This is only limited by the rule that patterns needs to be mutually exclusive for a certain function.\\n\\nHere is a function to remove double elements from a list, term rewriting style:\\n\\n```\\nlist[value] dup([*value a, value e, *value b, e, *value c]) = dup([*a, e, *b, *c])\\ndefault list[value] dup(list[value] l) = l;\\n```\\n\\nAnd here is the same function but type parametrized:\\n\\n```\\nlist[&T] dup([*&T a, &T e, *&T b, e, *&T c]) = dup([*a, e, *b, *c])\\ndefault list[&T] dup(list[&T] l) = l\\n```\\n\\n## From unlabeled to labeled rules\\n\\nThe big issue with rewrite rules is that they are applied automatically and this is sometimes cumbersome. Functions do not have this issue. Perhaps we should not have defined the boolean semantics so directly, and have wrapped it in a function:\\n\\n```\\ndata Bool\\n  = t()\\n  | f()\\n  | and(Bool l, Bool r)\\n  | or(Bool l, Bool r)\\n  ;\\n  \\nBool eval(and(f(), Bool _)) = f();\\nBool eval(and(t(), Bool b)) = b;\\n```\\n\\nThis reads as labeled rules, we have two rules called \\"eval\\" that could be applied but will never be applied automatically unless somebody calls them as a function.\\n\\n```\\nrascal>eval(and(f(),t()))\\nBool: f()\\n```\\n\\nOr, if we wish to apply this rule bottom-up through an entire boolean expression:\\n\\n```\\nrascal>visit (and(and(f(),t()),t())) { case Bool b => eval(b); }\\nBool: f();\\n```\\n\\nIn the above we used visit to automate the recursion, but we could have manually implemented the recursion as well:\\n\\n```\\nBool eval(and(t(), Bool b)) = eval(b);\\n```\\n\\n## Higher order functions are higher-order rewrite rules\\n\\nSince our \\"rules\\" are actually just functions, we can pass them and combine them just like in any other language that supports higher-order functions. This brings us dangerously close to the expressive power of what term rewriting people call strategies. Anonymous functions (lambdas) can use pattern matching just as any other function by the way.\\nSo we can write expressions such as `(f + g)(x)` where we non-deterministically choose between applying `f` and `g` using pattern matching.\\n\\n\\n## A note on types\\n\\nRascal is a statically typed language, supporting type inference only within the body of functions. We made this choice in order to help keep bodies of functions slim, but without introducing difficult to understand error messages that can be caused by a too smart type inference algorithm. \\n\\nThis is the reason why all pattern variables in function definitions need to be typed while in normal patterns (nested in the bodies of functions) the types of pattern variables is inferred.\\n\\n## Conclusion\\n\\nThese were some thoughts on the correspondence between functions and rewrite rules as we put it into Rascal.  We came from a term rewriting world and wanted to keep using their power of pattern matching and open extensibility. Now we are in a world of functional and imperative programming where we can control their application with the flick of a for loop."}]}')}}]);