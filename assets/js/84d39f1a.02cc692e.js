"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[67695],{3905:(e,o,n)=>{n.d(o,{Zo:()=>c,kt:()=>f});var t=n(67294);function r(e,o,n){return o in e?Object.defineProperty(e,o,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[o]=n,e}function l(e,o){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);o&&(t=t.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),n.push.apply(n,t)}return n}function a(e){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?l(Object(n),!0).forEach((function(o){r(e,o,n[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(n,o))}))}return e}function i(e,o){if(null==e)return{};var n,t,r=function(e,o){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],o.indexOf(n)>=0||(r[n]=e[n]);return r}(e,o);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],o.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),d=function(e){var o=t.useContext(s),n=o;return e&&(n="function"==typeof e?e(o):a(a({},o),e)),n},c=function(e){var o=d(e.components);return t.createElement(s.Provider,{value:o},e.children)},p={inlineCode:"code",wrapper:function(e){var o=e.children;return t.createElement(t.Fragment,{},o)}},u=t.forwardRef((function(e,o){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=d(n),f=r,y=u["".concat(s,".").concat(f)]||u[f]||p[f]||l;return n?t.createElement(y,a(a({ref:o},c),{},{components:n})):t.createElement(y,a({ref:o},c))}));function f(e,o){var n=arguments,r=o&&o.mdxType;if("string"==typeof e||r){var l=n.length,a=new Array(l);a[0]=u;var i={};for(var s in o)hasOwnProperty.call(o,s)&&(i[s]=o[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,a[1]=i;for(var d=2;d<l;d++)a[d]=n[d];return t.createElement.apply(null,a)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},37092:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>d});var t=n(83117),r=(n(67294),n(3905));const l={title:"module analysis::flow::ControlFlow"},a=void 0,i={unversionedId:"Library/analysis/flow/ControlFlow",id:"Library/analysis/flow/ControlFlow",title:"module analysis::flow::ControlFlow",description:"Usage",source:"@site/docs/Library/analysis/flow/ControlFlow.md",sourceDirName:"Library/analysis/flow",slug:"/Library/analysis/flow/ControlFlow",permalink:"/docs/Library/analysis/flow/ControlFlow",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Library/analysis/flow/ControlFlow.md",tags:[],version:"current",frontMatter:{title:"module analysis::flow::ControlFlow"},sidebar:"tutorialSidebar",previous:{title:"analysis::flow",permalink:"/docs/Library/analysis/flow/"},next:{title:"module analysis::flow::ObjectFlow",permalink:"/docs/Library/analysis/flow/ObjectFlow"}},s={},d=[{value:"Usage",id:"usage",level:4},{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"data ControlNode",id:"analysis-flow-ControlFlow-ControlNode",level:2},{value:"Synopsis",id:"synopsis-1",level:4},{value:"Description",id:"description-1",level:4},{value:"data ControlEdge",id:"analysis-flow-ControlFlow-ControlEdge",level:2},{value:"Synopsis",id:"synopsis-2",level:4},{value:"Description",id:"description-2",level:4},{value:"alias ControlFlow",id:"analysis-flow-ControlFlow-ControlFlow",level:2},{value:"data CFG",id:"analysis-flow-ControlFlow-CFG",level:2}],c={toc:d};function p(e){let{components:o,...n}=e;return(0,r.kt)("wrapper",(0,t.Z)({},c,n,{components:o,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"usage"},"Usage"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"import analysis::flow::ControlFlow;")),(0,r.kt)("h4",{id:"synopsis"},"Synopsis"),(0,r.kt)("p",null,"Intermediate notation for control flow graphs"),(0,r.kt)("h4",{id:"description"},"Description"),(0,r.kt)("p",null,"Control flow graphs are a unifying concept for units of executable\ncode in programming languages. This module defines a common\nintermediate representation which is designed to be produced from ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/analysis/m3/Core#analysis::m3::Core-M3"},"Core-M3"),"\nmodels and ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/analysis/m3/AST"},"AST")," for real programming languages. If (and only if) the translation\nis faithful to the semantics of the respective programming language,\nthen downstream analyses and visualizations are accurate."),(0,r.kt)("h2",{id:"analysis-flow-ControlFlow-ControlNode"},"data ControlNode"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data ControlNode  \n     = \\block(loc id)\n     | \\entry(loc id)\n     | \\exit(loc id)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-1"},"Synopsis"),(0,r.kt)("p",null,"control points in source code"),(0,r.kt)("h4",{id:"description-1"},"Description"),(0,r.kt)("p",null,"Control points in executable units of code are either straightline\ncode (block), or forks. Each executable unit has an entry and an exit\nnode. This is the simplest model for control flow nodes which may hold\nall the possible structures we find in real executable units, but it\ndoes require an analysis which resolves the locations of each block\nand the labels which are used to jump to. "),(0,r.kt)("h2",{id:"analysis-flow-ControlFlow-ControlEdge"},"data ControlEdge"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data ControlEdge  \n     = \\choice(loc id, bool condition)\n     | \\case(loc id)\n     | \\jump(loc id)\n     ;\n")),(0,r.kt)("h4",{id:"synopsis-2"},"Synopsis"),(0,r.kt)("p",null,"identify control edges"),(0,r.kt)("h4",{id:"description-2"},"Description"),(0,r.kt)("p",null,"A control edge goes from ControlEdge to ControlEdge and is identified\nby the condition which activates it. For normal structured control\nflow (",(0,r.kt)("inlineCode",{parentName:"p"},"choice"),") like if, while and do-while this is a boolean condition going either\nleft (true) or right (false). We also have edges labeled by ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," (data)\nand edges which are unconditional (",(0,r.kt)("inlineCode",{parentName:"p"},"jump"),"). "),(0,r.kt)("p",null,"Each edge is identified by\na location which should resolve to the identifying source code. For\n",(0,r.kt)("inlineCode",{parentName:"p"},"choice")," this would be the code of the conditional, for ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," the label\nof the code to jump to and for ",(0,r.kt)("inlineCode",{parentName:"p"},"jump")," the code of the jump instruction. Note that\nedge identification is redundant information, making it easier to index\nback into ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/analysis/m3/Core#analysis::m3::Core-M3"},"M3")," models or M3 ",(0,r.kt)("a",{parentName:"p",href:"/docs/Library/analysis/m3/AST"},"AST")," models."),(0,r.kt)("h2",{id:"analysis-flow-ControlFlow-ControlFlow"},"alias ControlFlow"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rel[ControlNode from, ControlEdge edge, ControlNode to]"))),(0,r.kt)("h2",{id:"analysis-flow-ControlFlow-CFG"},"data CFG"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rascal"},"data CFG  \n     = cfg(loc id, ControlFlow graph = {}, ControlNode \\start = entry(id), ControlNode end = exit(id))\n     ;\n")))}p.isMDXComponent=!0}}]);