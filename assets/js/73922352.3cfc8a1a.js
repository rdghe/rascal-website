"use strict";(self.webpackChunkrascal_website=self.webpackChunkrascal_website||[]).push([[58302],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>f});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)r=s[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(r),f=n,m=d["".concat(l,".").concat(f)]||d[f]||u[f]||s;return r?a.createElement(m,i(i({ref:t},p),{},{components:r})):a.createElement(m,i({ref:t},p))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=r.length,i=new Array(s);i[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var c=2;c<s;c++)i[c]=r[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},61520:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=r(87462),n=(r(67294),r(3905));const s={title:"Abstract Syntax Tree"},i=void 0,o={unversionedId:"Rascalopedia/AbstractSyntaxTree/index",id:"Rascalopedia/AbstractSyntaxTree/index",title:"Abstract Syntax Tree",description:"Synopsis",source:"@site/docs/Rascalopedia/AbstractSyntaxTree/index.md",sourceDirName:"Rascalopedia/AbstractSyntaxTree",slug:"/Rascalopedia/AbstractSyntaxTree/",permalink:"/docs/Rascalopedia/AbstractSyntaxTree/",draft:!1,editUrl:"https://github.com/usethesource/rascal/tree/main/src/org/rascalmpl/courses/docs/Rascalopedia/AbstractSyntaxTree/index.md",tags:[],version:"current",frontMatter:{title:"Abstract Syntax Tree"},sidebar:"tutorialSidebar",previous:{title:"Abstract Data Type",permalink:"/docs/Rascalopedia/AbstractDataType/"},next:{title:"Algebraic Data Type",permalink:"/docs/Rascalopedia/AlgebraicDataType/"}},l={},c=[{value:"Synopsis",id:"synopsis",level:4},{value:"Description",id:"description",level:4},{value:"Examples",id:"examples",level:4},{value:"Benefits",id:"benefits",level:4},{value:"Pitfalls",id:"pitfalls",level:4}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h4",{id:"synopsis"},"Synopsis"),(0,n.kt)("p",null,"Representation of the abstract syntactic structure of a program."),(0,n.kt)("h4",{id:"description"},"Description"),(0,n.kt)("p",null,"A ",(0,n.kt)("a",{parentName:"p",href:"/docs/Rascalopedia/ParseTree/"},"ParseTree")," is a detailed and very precise represention of the concrete syntactic structure of a program.\nIt may even be so detailed that it contains every space, comment and parenthesis in the original source text.\nIn many cases a less detailed representation is sufficient and an abstract syntax tree (or AST for short) is used."),(0,n.kt)("h4",{id:"examples"},"Examples"),(0,n.kt)("p",null,"For the input sentence"),(0,n.kt)("p",null,"![null][text.png]","(/assets/Rascalopedia/ParseTree/example-text.png)"),(0,n.kt)("p",null,"the parse tree (left) and abstract syntax tree (right) may look as follows:"),(0,n.kt)("p",null,"![null][ast.png]","(/assets/Rascalopedia/AbstractSyntaxTree/parse-ast.png)"),(0,n.kt)("p",null,"Note that the parse tree on the left did not preserve the spaces in the original text but there\nare parse tree formats (including the one used by Rascal) that preserve all textual information."),(0,n.kt)("h4",{id:"benefits"},"Benefits"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"parse trees are nice for grammar debugging, because they are an executing trace of the parsing algorithm."),(0,n.kt)("li",{parentName:"ul"},'parse trees are good for source-to-source transformation, because they do not a priori remove important details such as whitespace indentation and source code comments. A transformation based on parse trees is sometimes called "high fidelity" because of this.')),(0,n.kt)("h4",{id:"pitfalls"},"Pitfalls"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"parse trees are sometimes hard to read in abstract form, due to their inherent low-level of detail and complexity. When confronted with a large one, it's best to first try and minimize the input sentence before trying to debug a parse tree.")))}u.isMDXComponent=!0}}]);